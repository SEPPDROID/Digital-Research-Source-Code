
include equates.a86
include system.a86


		dseg
		extrn	rlr:word
		extrn	bdos_conowner:word
		extrn	date_days:word
		extrn	lp_xios_entry:dword
		extrn	pq_filesystem:word
		extrn	pq_error:word

		cseg
		public	bdos_init
		public	bdos_main

		extrn	bdos_callback:near

bdos_init:					; DATA XREF: dseg:001Ao
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
bdos_functions	dw offset DRV_ALLRESET	; DATA XREF: bdos_main+2o bdos:25F7o
		db 1
		dw offset DRV_SET
		db 1
		dw offset F_OPEN
		db 15h
		dw offset F_CLOSE
		db 15h
		dw offset F_SFIRST
		db 05h
		dw offset F_SNEXT
		db 01h
		dw offset F_DELETE
		db 15h
		dw offset F_READ
		db 17h
		dw offset F_WRITE
		db 17h
		dw offset F_MAKE
		db 05h
		dw offset F_RENAME
		db 15h
		dw offset DRV_ALLOCVEC
		db 1
		dw offset DRV_SETRO
		db 1
		dw offset F_ATTRIB
		db 5
		dw offset DRV_DPB
		db 1
		dw offset F_READRAND
		db 1Bh
		dw offset F_WRITERAND
		db 1Bh
		dw offset F_SIZE
		db 19h
		dw offset F_RANDREC
		db 9
		dw offset DRV_RESET
		db 1
		dw offset F_nop
		db 1
		dw offset F_nop
		db 1
		dw offset F_WRITEZF
		db 1Bh
		dw offset F_nop
		db 19h
		dw offset F_nop
		db 19h
		dw offset DRV_SPACE
		db 1
		dw offset DRV_FLUSH
		db 1
		dw offset flush0	; Function 98 entry point
		db 1
		dw offset F_TRUNCATE
		db 9
		dw offset DRV_SETLABEL
		db 5
		dw offset DRV_GETLABEL
		db 1
		dw offset F_TIMEDATE
		db 5
		dw offset F_WRITEXFCB
		db 5
		dw offset F_PASSWD
		db 1
		dw offset F_BDOS_74
		db 15h
		dw offset flush0	; Function 98 entry point
		db 1

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

bdos_main:		; DATA XREF: dseg:0018o
		add	si, cx
		add	si, offset bdos_functions
		call	bdos_switch
		mov	ax, bx
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

bdos_switch:		; CODE XREF: bdos_main+6p
		inc	es:proc_indisk
		push	cx
		push	dx
		push	si
		mov	bx, offset pq_filesystem
		mov	cx, 204h
		call	bdos_callback
		pop	si
		pop	dx
		pop	cx
		mov	fs_function, cl
		pushf	
		pop	ax
		cli	
		mov	F_old_ss, ss
		mov	F_old_sp, sp

bdos_main_alt:				; CODE XREF: bdos:2606j
		mov	bx, ds
		mov	ss, bx

		mov	sp, offset F_old_sp
		push	ax
		popf	
		mov	ax, es:word ptr proc_drive
		mov	word ptr fs_fcbdrive, ax
		mov	ax, es:userDS
		mov	fs_param_ds, ax
		mov	ax, es:userES
		mov	f_ret_es, ax
		push	es
		push	si
		mov	ax, ds
		mov	bx, es
		mov	ds, bx

		mov	es, ax

		mov	si, offset proc_dma
		mov	di, offset userdma
		mov	cx, 18h
		rep movsb
		mov	ds, ax

		mov	ax, userdma
		mov	cl, 4
		shr	ax, cl
		add	userdmaseg, ax
		and	userdma, 0Fh
		mov	cx, 14h
		xor	ax, ax
		mov	di, offset fcbdsk
		rep stosb
		mov	fs_param_low, dx
		mov	linfo, dl
		pop	si
		push	si
		mov	ah, cs:2[si]	; Flags	for this call
		test	ah, 4		; Bit 2: 33-byte FCB present
		jz	no_33_fcb
		call	copy_fcb_33
		jmps	no_36_fcb
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

no_33_fcb:				; CODE XREF: bdos_switch+84j
		test	ah, 8
		jz	no_36_fcb	; Bit 3: 36-byte FCB present
		call	copy_fcb_36
		call	get_record_coun

no_36_fcb:				; CODE XREF: bdos_switch+89j
					; bdos_switch+8Ej
		pop	si
		cmp	fs_sectorcount,	1
		jz	single_call
		test	cs:byte ptr 2[si], 2; Bit 1: Call once	for each sector
					;	specified by BDOS sector count
		jz	single_call
		call	F_repeat_call
		jmps	post_multicall
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

single_call:				; CODE XREF: bdos_switch+9Cj
					; bdos_switch+A3j
		call	F_do_call

post_multicall:				; CODE XREF: bdos_switch+A8j
		mov	cl, cur_fcb_len
		or	cl, cl
		jz	fcb_len_0
		xor	ch, ch
		mov	si, offset user_fcb
		mov	di, fs_param_low
		mov	es, fs_param_ds

		rep movsb

fcb_len_0:				; CODE XREF: bdos_switch+B3j
					; bdos_switch+C7j
		pop	es
		mov	si, offset sys_fx
		mov	di, offset proc_fx
		mov	cx, 14h
		rep movsb
		mov	ax, f_ret_es
		mov	es:userES, ax
		mov	bx, aret
		pushf	
		pop	ax
		cli	
		mov	ss, F_old_ss

		mov	sp, F_old_sp
		push	ax
		popf	
		mov	al, err_major
		push	bx
		test	al, 0FFh
		jz	fs_release
		push	fs_param_ds
		mov	bx, 0FFFFh
		test	set_if_attrs, 0FFh
		jz	fs_ret_error
		mov	bx, fs_param_low

fs_ret_error:				; CODE XREF: bdos_switch+118j
		push	bx
		mov	ah, error_drive

fs_release:				; CODE XREF: bdos_switch+10Aj
		push	ax
		mov	bx, offset pq_filesystem
		mov	cx, 205h
		call	bdos_callback
		pop	ax
		test	al, 0FFh
		jnz	f_abort
		jmp	f_noabort
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_abort:				; CODE XREF: bdos_switch+130j
		push	ax
		mov	bx, offset pq_error
		mov	cx, 204h
		call	bdos_callback
		mov	dx, addr_cpm_error
		call	f_printstring
		pop	ax
		push	ax
		add	ah, 'A'
		mov	byte ptr strColonSpace,	ah
		mov	dx, offset strColonSpace
		call	f_printstring
		pop	ax
		push	ax
		mov	bl, al
		xor	bh, bh
		shl	bx, 1
		mov	bx, error_strings[bx]
		mov	dx, [bx]
		call	f_printstring
		mov	dx, addr_bdos_fn
		call	f_printstring
		pop	ax
		mov	al, es:proc_fx
		mov	ah, '0'
		cmp	al, 100
		jb	f_printdec
		push	ax
		mov	dl, '1'
		call	f_printchar
		pop	ax
		sub	al, 100

f_printdec:				; CODE XREF: bdos_switch+176j
					; bdos_switch+187j
		sub	al, 0Ah
		jb	f_printfile
		inc	ah
		jmps	f_printdec
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_printfile:				; CODE XREF: bdos_switch+183j
		push	ax
		mov	dl, ah
		call	f_printchar
		pop	dx
		add	dl, ':'
		call	f_printchar
		pop	si
		pop	dx
		inc	si
		jz	f_filedone
		mov	di, offset errFilename
		mov	ax, ds
		mov	bx, es
		mov	es, ax
		mov	ds, dx
		mov	cx, 4
		rep	movsw
		mov	es:byte ptr [di],'.'
		inc	di
		mov	cl, 3
		rep	movsb
		mov	ds, ax
		mov	es, bx
		mov	dx, addr_file
		call	f_printstring
		mov	dx, offset errFilename
		call	f_printstring

f_filedone:				; CODE XREF: bdos_switch+199j
		mov	bx, offset pq_error
		mov	cx, 205h
		call	bdos_callback

f_noabort:				; CODE XREF: bdos_switch+132j
		pop	bx
		push	bx
		mov	cx, 206h
		call	bdos_callback
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_do_call:		; CODE XREF: bdos_switch+AAp
					; F_repeat_call+17p
		mov	F_entry_sp, sp
		test	cs:byte ptr 2[si], 10h
		jz	fs_notfilefcb
		push	si
		call	reselect
		pop	si

fs_notfilefcb:				; CODE XREF: F_do_call+21j
		call	cs:word ptr [si]

F_return:				; CODE XREF: sel$error+27j
		cmp	set_if_attrs, 0
		jz	dont_set_attrs
		mov	al, xfcb_rdonly
		mov	bx, offset user_fcb
		or	7[bx],	al
		mov	al, high$ext
		cmp	al, 60h
		jnz	set_F12
		or	byte ptr 8[bx], 80h
		jmps	dont_set_ifattr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

set_F12:				; CODE XREF: F_do_call+40j
		or	12[bx], al

dont_set_ifattr:			; CODE XREF: F_do_call+46j
		mov	al, result_F0F
		or	15[bx], al
		mov	al, fcbdsk
		mov	[bx], al

dont_set_attrs:				; CODE XREF: F_do_call+30j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_repeat_call:		; CODE XREF: bdos_switch+A5p
		mov	call_flags, si
		mov	ah, cs:2[si]
		mov	al, fs_sectorcount

frc_loop:				; CODE XREF: F_repeat_call+40j
		mov	last_sec_count,	al
		push	ax
		mov	si, call_flags
		mov	dx, fs_param_low
		call	F_do_call
		mov	bl, byte ptr aret
		or	bl, bl
		pop	ax
		jz	frc_inc
		cmp	bl, 0FFh
		jz	frc_abandon
		mov	bh, fs_sectorcount
		sub	bh, al
		jmps	frc_okay
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

frc_inc:				; CODE XREF: F_repeat_call+21j
		test	ah, 8
		jz	frc_notinc
		call	inc_fcb_record

frc_notinc:				; CODE XREF: F_repeat_call+33j
		add	userdma, 80h
		dec	al
		jnz	frc_loop
		xor	bx, bx

frc_okay:				; CODE XREF: F_repeat_call+2Ej
		mov	aret, bx

frc_abandon:				; CODE XREF: F_repeat_call+26j
		test	ah, 8
		jz	frc_return
		call	fcb_recno_addr
		jmps	put_record_coun



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get_record_coun:		; CODE XREF: bdos_switch+93p
		call	fcb_recno_addr
		xchg	bx, dx

put_record_coun:			; CODE XREF: F_repeat_call+50j
		mov	cl, 3
		jmp	move		; Copy CL bytes	from DX	to BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fcb_recno_addr:		; CODE XREF: F_repeat_call+4Dp
					; get_record_counp
		mov	bx, offset user_fcb+21h
		mov	dx, offset fcb_randrec_num
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy_fcb_33:		; CODE XREF: bdos_switch+86p
					; bdos:462Ep
		mov	cl, 21h
		jmps	copy_fcb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy_fcb_36:		; CODE XREF: bdos_switch+90p
		mov	cl, 24h

copy_fcb:				; CODE XREF: copy_fcb_33+2j
					; F_PASSWD+2p
		mov	cur_fcb_len, cl
		xor	ch, ch
		mov	si, fs_param_low
		mov	di, offset user_fcb
		push	ds
		mov	ds, fs_param_ds
		rep movsb
		pop	ds

frc_return:				; CODE XREF: F_repeat_call+4Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

inc_fcb_record:		; CODE XREF: F_repeat_call+35p
		mov	bx, offset user_fcb+21h
		inc	word ptr [bx]
		jnz	ifr_ret
		inc	byte ptr 2[bx]

ifr_ret:				; CODE XREF: inc_fcb_record+5j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_printchar:		; CODE XREF: bdos_switch+17Bp
					; bdos_switch+18Cp ...
		mov	cx, 2
		jmp	bdos_callback



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_printstring:		; CODE XREF: bdos_switch+143p
					; bdos_switch+152p ...
		mov	bx, dx

f_prstr_loop:				; CODE XREF: f_printstring+Fj
		mov	dl, [bx]
		cmp	dl, '$'
		jz	f_prstr_end
		push	bx
		call	f_printchar
		pop	bx
		inc	bx
		jmps	f_prstr_loop
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_prstr_end:				; CODE XREF: f_printstring+7j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_call_xios:		; CODE XREF: drive_login+5p
					; DRV_FLUSH+9p	...
		push	es
		mov	es, rlr
		callf	dword ptr lp_xios_entry
		cld	
		pop	es
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

xios_rdwr:		; CODE XREF: wrbuff+2p	rdbuff+2p
					; ...
		mov	dx, bcb_record
		mov	ch, bcb_record_h
		mov	bl, curdsk
		mov	bh, 1
		xchg	bh, fs_rdwrcount
		push	bx
		push	fs_track
		push	fs_sector
		push	word ptr fs_buffer
		push	word ptr fs_buffer+2
		mov	es, rlr
		callf	dword ptr lp_xios_entry
		add	sp, 0Ah
		cld	
		push	ds
		pop	es

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fs_abort1:		; CODE XREF: rdbuff+74j
		mov	ah, 1
		jmps	goerr


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;

rod$error:	jmp	rod$err_patch
		nop
;
; Before being patched this was probably:
;
;;;		mov	ah, 2
;;;		jmps	goerr

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rof$error:		; CODE XREF: check$rodir+8j
					; fat_delete+34j ...
		mov	ah, 3
		jmps	goerr



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Report select	error

sel$error:		; CODE XREF: cwd_for_drive+2Bj
		mov	curdsk,	0FFh	; Invalidate curdsk to force select
					; call at next curselect call
		mov	ah, 4

goerr:					; CODE XREF: fs_abort1+2j rof$error+2j
					; ...
		mov	al, 0FFh
		mov	aret, ax
		cmp	fs_errormode, al
		jnz	error

rtn$phy$errs:				; CODE XREF: error+Fj error+23j
		mov	al, fs_function
		cmp	al, 0Bh		; Return 0ffffh	if function 27 or 31
		jz	fs_abort_ffff
		cmp	al, 0Eh
		jnz	goback

fs_abort_ffff:				; CODE XREF: sel$error+17j
		mov	aret, 0FFFFh

goback:					; CODE XREF: sel$error+1Bj
					; disk_error+10j ...
		mov	sp, F_entry_sp
		jmp	F_return



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

f_ret_1:		; CODE XREF: open$reel+79j
					; open$reel+97j ...
		mov	al, 1

sta$ret:				; CODE XREF: check_changed+11j
					; tst$inv$fcb+8j ...
		mov	byte ptr aret, al

F_nop:					; DATA XREF: bdos:25AAo bdos:25ADo
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

disk_error:		; CODE XREF: valid_dl_f_fcb+Aj
					; cpm_writerec+17j ...
		mov	al, 0FFh
		mov	aret, ax
		cmp	ah, 3		; Error	3 -> Error 12
		jnz	diskerr_not3
		mov	ah, 0Ch

diskerr_not3:				; CODE XREF: disk_error+8j
		cmp	fs_errormode, al
		jz	goback



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

error:		; CODE XREF: sel$error+10j
		mov	err_major, ah
		mov	al, fs_fcbdrive
		mov	error_drive, al
		cmp	fs_errormode, 0FEh
		jz	rtn$phy$errs
		push	ds
		mov	ds, rlr

		or	proc_flags, 1
		mov	proc_errcode, 0FFFDh
		pop	ds

		jmps	rtn$phy$errs



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Copy CL bytes	from DX	to BX

move:		; CODE XREF: get_record_coun+7j
					; deblock+100p	...
		xor	ch, ch
		mov	si, dx
		mov	di, bx
		rep movsb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare CL bytes at DX and BX

compare:		; CODE XREF: discard$data+Cp
					; get$bcba+5Bp	...
		xor	ch, ch
		mov	si, bx
		mov	di, dx
		rep cmpsb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

seek:		; CODE XREF: bdos:2C5Dp deblock$io+1p
					; ...
		mov	ax, bcb_record
		xor	dx, dx
		mov	dl, bcb_record_h
		div	dpb_spt
		add	ax, dpb_off
		mov	fs_track, ax
		mov	cl, dpb_psh
		shr	dx, cl		;This shift is using 16-bit sector
		mov	fs_sector, dx	;numbers, giving a maximum drive
		retn			;size of 32M.



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

atran:		; CODE XREF: bdos:3D15p cpm_writerec+96p
		mov	cl, dpb_bsh
		mov	ax, bcb_record
		mov	arecord1, ax
		xor	bh, bh
		mov	bl, ah
		shl	ax, cl
		shl	bx, cl
		mov	bcb_dirty, ax
		xchg	ax, bx
		mov	al, vrecord
		and	al, dpb_blm
		mov	blk$off, al
		or	bl, al
		mov	bcb_record, bx
		mov	bcb_record_h, ah
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

dm$position:		; CODE XREF: indexp check$nprs+77p
					; ...
		mov	cl, dpb_bsh
		mov	ch, vrecord
		shr	ch, cl
		neg	cl
		add	cl, 7
		mov	al, extval
		shl	al, cl
		add	al, ch
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Get block CX from FCB; returns in BX

get$dm:		; CODE XREF: index+Ap check$nprs+8Ap
					; ...
		mov	bx, offset user_fcb+10h
		add	bx, cx
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	bffcb_16bit
		mov	bl, [bx]
		xor	bh, bh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

bffcb_16bit:				; CODE XREF: get$dm+Aj
		add	bx, cx
		mov	bx, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute disk block number from current FCB

index:		; CODE XREF: bdos:3D10p cpm_writerec+42p
		call	dm$position
		mov	dminx, al
		mov	cl, al
		xor	ch, ch
		call	get$dm		; Get block CX from FCB; returns in BX
		mov	bcb_record, bx
		or	bx, bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$atts:		; CODE XREF: cpm_deletep F_MAKE+31p
					; ...
		mov	di, offset user_fcb+8
		mov	cx, 4
		xor	dl, dl
		std	

get_attrs0:				; CODE XREF: get$atts+12j
		mov	al, [di]
		shl	al, 1
		rcr	dl, 1
		shr	al, 1
		stosb
		loop	get_attrs0
		cld	
		mov	al, dl
		mov	attributes, al	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute directory extent from	FCB

get$dir$ext:		; CODE XREF: getfcb+Dp	open$copy+16p
					; ...
		mov	bx, offset user_fcb+20h
		mov	dx, 1001h	; Scan FCB disk	map backwards

get$de0:				; CODE XREF: get$dir$ext+10j
					; get$dir$ext+31j
		dec	dh
		dec	bx
		cmp	byte ptr [bx], 0
		jnz	get$de2		; fcb(dskmap(bx)) ~= 0
		or	dh, dh
		jnz	get$de0
		dec	dl		; DL=0 if all blocks are 0 in fcb
					; disk map

get$de2:				; CODE XREF: get$dir$ext+Cj
		mov	dminx, dl
		cmp	single,	0FFh	; Nonzero if using 8-bit blocks
		mov	al, dh
		jz	get$de3
		shr	al, 1		; not single, divide blk idx by	2
;
; Compute ext offset from last non-zero	block index
; by shifting blk idx right by (7 - block shift)
;

get$de3:				; CODE XREF: get$dir$ext+1Fj
		mov	cl, 7
		sub	cl, dpb_bsh
		shr	al, cl
		mov	ah, dpb_exm
		cmp	ah, al		; Verify computed extent <= ext	mask
		jb	get$de0
		mov	bx, offset user_fcb+0Ch
		mov	cl, [bx]	; Extent
		not	ah
		and	ah, 1Fh		; dir ext = (fcb ext & (~extmsk) & maxext) | ext offset
		and	ah, cl
		or	al, ah		; AL = directory extent
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare extent nos in	AL and CL
; Return nonzero if they do not	match

compext:		; CODE XREF: bdos:3702p open$reel+Fp
					; ...
		push	cx
		mov	ch, dpb_exm
		not	ch		; CH = mask for	physical extent	no#
		and	cl, ch
		and	al, ch
		sub	al, cl
		and	al, 1Fh		; Difference between 2 phys extents
		pop	cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Set variables	from currently addressed FCB

getfcb:		; CODE XREF: open$reel+58p
					; bdos:3CF6p ...
		mov	al, user_fcb+20h
		mov	vrecord, al
		cmp	user_fcb+0Fh, 0
		jnz	getfcb0
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		call	set$rc

getfcb0:				; CODE XREF: getfcb+Bj
		mov	al, user_fcb+0Fh
		cmp	al, 81h
		jb	getfcb1
		mov	al, 80h

getfcb1:				; CODE XREF: getfcb+1Aj
		mov	rcount,	al
		mov	al, dpb_exm
		and	al, user_fcb+0Ch
		mov	extval,	al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Place	values back into current FCB

setfcb:		; CODE XREF: bdos:2F06j bdos:3D2Bj
					; ...
		xor	al, al		; Don't change if random
		cmp	fs_function, 9	; Is function <	9? (sequential read/write)
		jnb	setfcb1
		inc	al		; Increase current record

setfcb1:				; CODE XREF: setfcb+7j
		add	al, vrecord
		mov	user_fcb+20h, al
		cmp	user_fcb+0Fh, 80h; Don't reset RC if > 7Fh
		jnb	setfcb2
		mov	al, rcount
		mov	user_fcb+0Fh, al

setfcb2:				; CODE XREF: setfcb+17j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cksum_cl_bytes:		; CODE XREF: compute$cs+Ep
		xor	ch, ch

cksum8_loop:				; CODE XREF: cksum_cl_bytes+5j
		add	al, [bx]
		inc	bx
		loop	cksum8_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compute checksum for current directory buffer

compute$cs:		; CODE XREF: r$dir+49p
		mov	bx, buffa
		mov	cx, 4
		xor	ah, ah		; AH=0,CX=4

compute$cs0:				; CODE XREF: compute$cs+14j
		push	cx
		xor	al, al
		mov	cl, 20h
		call	cksum_cl_bytes
		xor	ah, al
		pop	cx
		loop	compute$cs0
		xchg	al, ah		; Return with checksum in AL
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chek$fcb:		; CODE XREF: check_changedp
					; F_CLOSE+2Cp
		cmp	high$ext, 60h
		jnz	chek$fcb1
		xor	al, al
		mov	user_fcb, al

chek$fcb1:				; CODE XREF: chek$fcb+5j
		mov	bx, lsn$add
		mov	al, user_fcb+0Dh
		cmp	2[bx],	al

d_notchanged:				; CODE XREF: check_changed+3j
					; check_changed+Cj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check_changed:		; CODE XREF: F_READp F_WRITEp
					; ...
		call	chek$fcb
		jz	d_notchanged
		mov	dx, removable_drive
		call	test$vector	; Return bit curdsk of vector DX
		jnz	d_notchanged
		pop	bx

chk$media2:				; CODE XREF: chk$exit$fxs+Cj
		mov	al, 0Ah
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$lsn:		; CODE XREF: open$reel+55p
					; cpm_rwrand+ABp ...
		mov	bx, lsn$add
		mov	cl, 2[bx]
		mov	user_fcb+0Dh, cl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$cdisk:		; CODE XREF: media$change+12p
					; curselect+2Cp ...
		mov	cl, curdsk

set$cdisk1:				; CODE XREF: get$block+3Bp
		mov	ax, 1
		shl	ax, cl
		or	[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return true if drive is software R/O

nowrite:		; CODE XREF: check$writep r$dir+63p
					; ...
		mov	dx, readonly_vector



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return bit curdsk of vector DX

test$vector:		; CODE XREF: check_changed+9p
					; rdbuff+2Cp ...
		mov	cl, curdsk
		shr	dx, cl
		and	dx, 1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getdptra:		; CODE XREF: check$rodirp read$subdir+33p
					; ...
		mov	bl, dptr
		xor	bh, bh
		add	bx, buffa
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_getrdonly:		; CODE XREF: check$rodir+3p
		add	bx, 9
		mov	al, [bx]
		rcl	al, 1

can_write:				; CODE XREF: check$rodir+6j
					; check$write+3j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$rodir:		; CODE XREF: cpm_delete+1Dp
					; bdos:47E5p ...
		call	getdptra

check$rofile:				; CODE XREF: cpm_writerec+24p
					; fat_rdwr+22p
		call	cpm_getrdonly
		jnb	can_write
		jmp	rof$error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$write:		; CODE XREF: seek$copyp cpm_writerec+5p
					; ...
		call	nowrite		; Return true if drive is software R/O
		jz	can_write
		jmp	rod$error	; Report read/only disk	error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getmodnum:		; CODE XREF: setfwfp cpm_writerec+136p
		mov	bx, offset user_fcb+0Eh
		mov	al, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Clear	S2 byte	of FCB

clrmodnum:		; CODE XREF: F_OPEN+3p	F_SFIRST+30p
					; ...
		mov	user_fcb+0Eh, 0
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

clr$ext:		; CODE XREF: reselect+24p F_SFIRST+2Dp
					; ...
		and	user_fcb+0Ch, 1Fh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

setfwf:		; CODE XREF: open$copyp close$fcb+9Bp
					; ...
		call	getmodnum
		or	al, 80h
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cp_fcb10_ffff:		; CODE XREF: tst$inv$fcbp close+11p
					; ...
		mov	bx, offset user_fcb+10h
		jmps	cp_pbx_ffff



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$inv$fcb:		; CODE XREF: bdos:3CEEp cpm_writerec+27p
		call	cp_fcb10_ffff
		jnz	eod_ret
		pop	bx
		mov	al, 9
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

end$of$dir:		; CODE XREF: read$subdir+2Bp
					; cpm_login+4Bp ...
		mov	bx, offset dcnt

cp_pbx_ffff:				; CODE XREF: cp_fcb10_ffff+3j
		cmp	word ptr [bx], 0FFFFh

eod_ret:				; CODE XREF: tst$inv$fcb+3j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$end$dir:		; CODE XREF: rd$subdir1+3Bj
					; r$dir+11j ...
		mov	dcnt, 0FFFFh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set_dcnt_dblk:		; CODE XREF: does$xfcb$exist+7p
					; restore_dir_fcbp ...
		mov	ax, xdcnt
		and	al, 0FCh
		dec	ax
		mov	dcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

compcdr:		; CODE XREF: setcdrp searchn+20p
					; ...
		mov	dx, dcnt
		mov	bx, cdrmaxa
		cmp	dx, [bx]

tst$relog_ret:				; CODE XREF: setcdr+3j	tst$log$fxs+5j
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

setcdr:		; CODE XREF: cpm_login+72p
					; fat_login+4Cp ...
		call	compcdr
		jb	tst$relog_ret
		inc	dx
		mov	[bx], dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$log$fxs:		; CODE XREF: search$h_sub+23p
					; reselect+46p
		test	byte ptr dpb_cks+1, 80h
		jnz	tst$relog_ret
		mov	di, offset log$fxs



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$log0:		; CODE XREF: chk$exit$fxs+7p
					; chk$exit$fxs+12p
		mov	cl, [di]
		inc	di
		xor	ch, ch
		mov	al, fs_function
		repne scasb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$exit$fxs:		; CODE XREF: rdbuff+4Cp read$dir+Ap
					; ...
		mov	bx, offset goback
		push	bx
		mov	di, offset rw$fxs; Read	or write functions
		call	tst$log0
		jnz	chk_exit_fxs1
		jmp	chk$media2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk_exit_fxs1:				; CODE XREF: chk$exit$fxs+Aj
		mov	di, offset sc$fxs; Close or search functions
		call	tst$log0
		jnz	chk_exit_fxs2
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk_exit_fxs2:				; CODE XREF: chk$exit$fxs+15j
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tst$relog:		; CODE XREF: read$dir+Dp rd$parentdir+64j
		xor	al, al
		xchg	al, relog
		test	al, al
		jz	tst$relog_ret

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

drv$relog:		; CODE XREF: check$media+3Ap
		call	curselect
		xor	ax, ax
		mov	dcnt, ax
		mov	dptr, al
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

wrbuff:		; CODE XREF: bdos:2C63j deblock$io+Dj
					; ...
		mov	al, 0Bh
		call	xios_rdwr
		mov	ah, 0FFh
		jmps	diocomp1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rdbuff:		; CODE XREF: bdos:2C65j deblock$io+10p
					; ...
		mov	al, 0Ah
		call	xios_rdwr

diocomp:				; CODE XREF: DRV_FLUSH+Cp call_xios_flush+5p
		mov	ah, 0

diocomp1:				; CODE XREF: wrbuff+7j	write_FAT+3Fj
		or	al, al
		jnz	diocomp2
		mov	readf$sw, 0FFh
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp2:				; CODE XREF: rdbuff+9j
		push	ax
		cmp	al, 0FFh	; AL = 0FFh => media changed
		jnz	diocomp_nochang
		cmp	dpb_cks, 8000h
		jz	diocomp_nochang
		mov	dx, login_vector
		call	test$vector	; Return bit curdsk of vector DX
		jz	diocomp_nochang
		call	media$change
		cmp	fs_function, 1Ah; Was this a flush operation?
		jz	wasflush
		mov	al, bcb_drive
		cmp	al, fs_fcbdrive
		jz	diocomp_notrelg	; To another drive?
		mov	relog, 0

wasflush:				; CODE XREF: rdbuff+39j
		pop	ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp_notrelg:			; CODE XREF: rdbuff+42j
		call	chk$exit$fxs
		test	readf$sw, 0FFh	; Was this a directory read?
		jz	diocomp9
		call	lret$eq$ff
		jmp	goback
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp9:				; CODE XREF: rdbuff+54j
		pop	ax
		or	ah, ah
		jnz	j_rod$error
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diocomp_nochang:			; CODE XREF: rdbuff+1Ej rdbuff+26j
					; ...
		pop	ax
		cmp	al, 2
		jz	j_rod$error
		jmp	fs_abort1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_rod$error:				; CODE XREF: rdbuff+60j rdbuff+72j
		jmp	rod$error	; Report read/only disk	error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Release the BCB for bcb_drive, record	bcb_record

discard$databcb:		; CODE XREF: cpm_writerec+C4p
					; cpm_writerec+F8p ...
		mov	bx, dph_dtabcb
		mov	cl, 4
		jmps	bcb_rel_cl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Release all directory	BCBs for a drive

discard$dir:		; CODE XREF: bdos:291Dp cpm_login+19p
					; ...
		mov	bx, dph_dirbcb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Called with BX->BCB chain head. Release all BCBs for a drive

discard$data:		; CODE XREF: media$change+4p
					; cpm_login+16p ...
		mov	cl, 1

bcb_rel_cl:				; CODE XREF: discard$databcb+6j
		or	bx, bx
		jz	no_bcb_chain
		mov	bx, [bx]	; BX ->	first BCB

bcbrel_loop:				; CODE XREF: discard$data+1Aj
		push	cx
		mov	dx, offset bcb_drive
		call	compare		; Compare CL bytes at DX and BX
		pop	cx
		jnz	bcbrel_next
		mov	byte ptr [bx], 0FFh

bcbrel_next:				; CODE XREF: discard$data+10j
		mov	bx, 12[bx]	; Next BCB
		or	bx, bx
		jnz	bcbrel_loop

no_bcb_chain:				; CODE XREF: discard$data+4j
					; proc$discard+2j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Free BCBs on bcb_drive used by current process

proc$discard:		; CODE XREF: DRV_FLUSH+6Fp
		or	bx, bx
		jz	no_bcb_chain
		mov	bx, [bx]

fpbcb_loop:				; CODE XREF: proc$discard+2Fj
		mov	al, [bx]
		cmp	al, bcb_drive
		jnz	fpbcb_next
		mov	ax, 14[bx]	; Owned	by current process?
		cmp	ax, rlr
		jnz	fpbcb_next
		mov	word ptr 14[bx], 0
		mov	al, fs_function
		cmp	al, 1Ah		; Set DMA
		jz	fpbcb_freeit
		cmp	al, 15h		; F_WRITE
		jnz	fpbcb_next

fpbcb_freeit:				; CODE XREF: proc$discard+21j
		mov	byte ptr [bx], 0FFh

fpbcb_next:				; CODE XREF: proc$discard+Cj
					; proc$discard+15j ...
		mov	bx, 12[bx]
		or	bx, bx
		jnz	fpbcb_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$bcba:		; CODE XREF: deblock+90p
		mov	rootbcba, bx
		mov	di, bx
		sub	di, 0Ch
		mov	bx, [bx]	; BX->BCB. DI->prev BCB
		cmp	word ptr 12[bx], 0
		jnz	get$bcb05
		jmp	gcbca_end	; No BCB follows
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb05:				; CODE XREF: get$bcba+Fj
		xor	ax, ax
		mov	emptybcba, ax
		mov	seqbcba, ax
		mov	my_bcbs, al	; BCBs owned by	this process

get$bcb1:				; CODE XREF: get$bcba+CEj
		cmp	byte ptr [bx], 0FFh
		jz	got_free_bcb
		mov	ax, 14[bx]
		or	ax, ax
		jnz	has_owner
		mov	si, emptybcba
		or	si, si
		jz	got_free_bcb
		mov	si, 12[si]
		cmp	byte ptr [si], 0FFh
		jz	get$bcb14

got_free_bcb:				; CODE XREF: get$bcba+22j get$bcba+31j
		mov	emptybcba, di
		mov	byte ptr 5[bx], 0
		jmps	get$bcb14
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

has_owner:				; CODE XREF: get$bcba+29j
		cmp	ax, rlr
		jnz	get$bcb14
		inc	my_bcbs		; BCBs owned by	this process
		mov	seqbcba, di

get$bcb14:				; CODE XREF: get$bcba+39j get$bcba+43j
					; ...
		mov	curbcba, bx
		push	di
		call	set$arecord
		call	compare		; Compare CL bytes at DX and BX
		pop	di
		mov	bx, curbcba
		jnz	get$bcb17
		mov	al, 5[bx]
		cmp	al, 0FFh
		jz	get$bcb16
		mov	ah, phy$off
		cmp	al, ah
		jz	get$bcb16
		inc	al
		cmp	al, ah
		jz	get$bcb15
		mov	al, 0FFh

get$bcb15:				; CODE XREF: get$bcba+78j
		mov	5[bx],	al

get$bcb16:				; CODE XREF: get$bcba+6Aj get$bcba+72j
		jmp	get$bcb5
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb17:				; CODE XREF: get$bcba+63j
		mov	ax, 14[bx]
		cmp	ax, rlr
		jnz	get$bcb19
		mov	al, bcb_drive
		cmp	al, [bx]
		jnz	get$bcb19
		mov	al, dpb_phm
		or	al, al
		jz	get$bcb19
		cmp	al, 5[bx]
		jnz	get$bcb19
		mov	byte ptr 5[bx], 0
		cmp	word ptr 12[bx], 0
		jz	get$bcb21
		dec	my_bcbs		; BCBs owned by	this process
		xor	ax, ax
		xchg	ax, 12[bx]
		mov	12[di], ax
		xchg	ax, bx

get$bcb18:				; CODE XREF: get$bcba+BCj
		mov	si, bx
		mov	bx, 12[si]
		or	bx, bx
		jnz	get$bcb18
		mov	12[si], ax
		jmps	get$bcb20
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb19:				; CODE XREF: get$bcba+89j get$bcba+90j
					; ...
		cmp	word ptr 12[bx], 0
		jz	get$bcb21
		mov	di, bx

get$bcb20:				; CODE XREF: get$bcba+C1j
		mov	bx, 12[di]
		jmp	get$bcb1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$bcb21:				; CODE XREF: get$bcba+A6j get$bcba+C7j
		mov	si, emptybcba
		or	si, si
		jz	get$bcb22
		mov	di, si

get$bcb22:				; CODE XREF: get$bcba+D7j
		mov	si, rootbcba
		mov	al, my_bcbs	; BCBs owned by	this process
		cmp	al, 2[si]
		jb	get$bcb23
		mov	di, seqbcba

get$bcb23:				; CODE XREF: get$bcba+E5j
		mov	bx, 12[di]
		mov	al, phy$off
		mov	5[bx],	al

get$bcb5:				; CODE XREF: get$bcba+7Fj
		mov	si, rootbcba
		mov	ax, [si]
		cmp	ax, bx
		jz	gcbca_end
		xchg	ax, 12[bx]
		mov	12[di], ax
		mov	[si], bx

gcbca_end:				; CODE XREF: get$bcba+11j get$bcba+FCj
		mov	ax, rlr
		mov	14[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Take the last	LRU buffer, move to head of chain,
; allocate to drive bcb_drive block DX

lru_touch:		; CODE XREF: cpm_writerec+71p
		mov	bx, offset p_lru_first

lru_goto_end:				; CODE XREF: lru_touch+Aj
		mov	di, bx		; DI->previous entry
		mov	bx, [bx]
		cmp	word ptr [bx], 0
		jnz	lru_goto_end
;
; BX->last entry in LRU	chain
; DI->the one pointing to it
;
		mov	al, bcb_drive
		mov	4[bx],	al
		mov	2[bx],	dx
		xor	ax, ax
		mov	5[bx],	al
		mov	[di], ax	; Detach from chain
		mov	ax, bx
		xchg	ax, p_lru_first	; Move to head of chain
		mov	[bx], ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Free all LRU buffers for drive bcb_drive

lru_free:		; CODE XREF: copy$alv+1Fp cpm_writerec+FFp
		mov	al, bcb_drive
		mov	bx, offset p_lru_first

lru_free_loop:				; CODE XREF: lru_free+14j
		mov	bx, [bx]
		cmp	4[bx],	al
		jnz	lru_free_next
		mov	byte ptr 4[bx], 0FFh

lru_free_next:				; CODE XREF: lru_free+Bj
		cmp	word ptr [bx], 0
		jnz	lru_free_loop
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Returns Carry	set if buffer dirty?

lru_ckdirty:		; CODE XREF: deblock+11Ep deblock+133p
		mov	al, bcb_drive
		mov	bx, offset p_lru_first
		mov	dx, arecord1

lrufind_loop:				; CODE XREF: lru_ckdirty+3Dj
		mov	bx, [bx]
		cmp	4[bx],	al	; Drive	match?
		jnz	lrufind_next
		cmp	2[bx],	dx	; Record match?
		jnz	lrufind_next
		cmp	cl, 5[bx]
		jb	lrufind_end
		mov	al, dpb_phm
		mov	ah, al
		not	ah
		and	cl, ah
		inc	al
		add	al, cl
		mov	5[bx],	al

lrufind_end:				; CODE XREF: lru_ckdirty+27j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

lrufind_next:				; CODE XREF: lru_ckdirty+1Dj
					; lru_ckdirty+22j
		cmp	word ptr [bx], 0
		jnz	lrufind_loop
		stc	
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Read/write a sector and/or update the	current	BCB with its address
; AL=0:	Update BCB
; AL=1:	Read and update
; AL=2:	Write and update

deblock$io:		; CODE XREF: deblock+F6p deblock+125p
					; ...
		push	ax
		call	seek
		pop	ax
		dec	al
		js	rwb_fn0
		jnz	rwb_fn1
		mov	cl, 1
		jmp	wrbuff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

rwb_fn1:				; CODE XREF: deblock$io+9j
		call	rdbuff

rwb_fn0:				; CODE XREF: deblock$io+7j
		mov	si, offset fs_track
		mov	di, curbcba
		add	di, 6
		mov	cx, 2
		rep movsw
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

go_rdbuff:				; CODE XREF: bdos:3D1Fj
		mov	ah, 1
		call	deblock$dta
		jmp	setfcb		; Place	values back into current FCB

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

deblock:		; CODE XREF: bdos:3207p
		mov	word ptr fs_buffer, ds
		mov	bx, dph_dirbcb
		cmp	ah, 5
		jnz	deblock1a
		mov	bx, curbcba
		jmps	deblock1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock$dta:				; CODE XREF: bdos:2EFEj bdos:2F03p
					; ...
		mov	bx, dph_dtabcb
		mov	word ptr fs_buffer, 0
		cmp	ah, 4
		jnz	deblock1a

deblock$flush:				; CODE XREF: deblock+74j
		mov	bx, [bx]
		mov	fs_track, 0FFFFh
; Search for dirty BCB with lowest track number

deblock$flush1:				; CODE XREF: deblock+55j
		mov	al, bcb_drive	; Does current drive own BCB?
		cmp	al, [bx]
		jnz	deblock$flush2
		test	byte ptr 4[bx], 0FFh; Is buffer dirty?
		jz	deblock$flush2	; No
		mov	ax, 14[bx]	; Owned	by current process?
		cmp	ax, rlr
		jnz	deblock$flush2	; No
		mov	ax, 6[bx]	; Is bcb(6) < track?
		cmp	ax, fs_track
		jnb	deblock$flush2
		mov	fs_track, ax
		mov	fs_sector, bx

deblock$flush2:				; CODE XREF: deblock+2Fj deblock+35j
					; ...
		mov	bx, 12[bx]
		or	bx, bx		; Got to end yet?
		jnz	deblock$flush1
		cmp	fs_track, 0FFFFh
		jnz	deblock$flush3
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock$flush3:				; CODE XREF: deblock+5Cj
		mov	bx, fs_sector
		xor	al, al
		mov	ah, 4
		mov	word ptr fs_buffer, 0
		call	deblock1a	; Flush	BCB
		mov	bx, dph_dtabcb
		jmps	deblock$flush
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock1a:				; CODE XREF: deblock+Bj deblock+11j
					; ...
		mov	deblock_command, ah
		lahf	
		mov	cl, dpb_phm
		mov	al, byte ptr bcb_record
		and	al, cl
		mov	phy$off, al	; phy$off = low(arecord) & phymsk
		not	cl		; arecord &= ~phymsk
		and	byte ptr bcb_record, cl
		sahf	
		jz	deblock1b
		call	get$bcba

deblock1b:				; CODE XREF: deblock+8Ej
		mov	curbcba, bx
		mov	ax, 10[bx]
		cmp	word ptr fs_buffer, 0
		jnz	deblock1c
		mov	word ptr fs_buffer, ax
		xor	ax, ax

deblock1c:				; CODE XREF: deblock+9Fj
		mov	word ptr fs_buffer+2, ax
		mov	al, deblock_command
		cmp	al, 3
		jnz	deblock1d
		xor	ah, ah
		xchg	ah, dir_check_flag
		test	ah, 0F0h
		jnz	deblock25

deblock1d:				; CODE XREF: deblock+AEj
		call	set$arecord
		cmp	byte ptr [bx], 0FFh
		jz	deblock2
		cmp	al, 4
		jnb	deblock1e
		call	compare		; Compare CL bytes at DX and BX
		jz	deblock45

deblock1e:				; CODE XREF: deblock+C5j
		cmp	al, 5
		jz	deblock15
		test	byte ptr 4[bx], 0FFh
		jz	deblock2

deblock15:				; CODE XREF: deblock+CEj
		mov	byte ptr 4[bx], 0
		push	word ptr bcb_drive
		push	bcb_record+1
		mov	ax, 2[bx]
		mov	bcb_record+1, ax
		mov	ax, [bx]
		mov	word ptr bcb_drive, ax
		cmp	curdsk,	al
		jz	deblock15a
		call	disk$select1

deblock15a:				; CODE XREF: deblock+EDj
		mov	al, 1
		jnz	deblock15b
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update

deblock15b:				; CODE XREF: deblock+F4j
		pop	bcb_record+1
		pop	word ptr bcb_drive
		call	curselect

deblock2:				; CODE XREF: deblock+C1j deblock+D4j
		mov	al, deblock_command
		cmp	al, 4
		jb	deblock2a
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock2a:				; CODE XREF: deblock+113j
		cmp	al, 2
		jnz	deblock25
		mov	cl, blk$off
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		jb	deblock25
		xor	al, al		; Clean. Just update BCB trk/sec
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update
		jmps	deblock4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock25:				; CODE XREF: deblock+B9j deblock+118j
					; ...
		mov	bx, curbcba
		mov	byte ptr [bx], 0FFh
		mov	al, 2
		call	deblock$io	; Read/write a sector and/or update the	current	BCB with its address
					; AL=0:	Update BCB
					; AL=1:	Read and update
					; AL=2:	Write and update

deblock4:				; CODE XREF: deblock+128j
		call	set$arecord
		call	move		; Copy CL bytes	from DX	to BX
		mov	byte ptr [di], 0

deblock45:				; CODE XREF: deblock+12Cj deblock+137j
		xor	al, al
		mov	ah, phy$off
		shr	ax, 1
		mov	si, word ptr fs_buffer+2
		add	si, ax
		mov	al, deblock_command
		cmp	al, 3
		jnz	deblock6
		mov	buffa, si
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

deblock6:				; CODE XREF: deblock+161j
		mov	cx, 40h
		mov	di, userdma
		cmp	al, 1
		mov	ax, userdmaseg
		mov	dx, word ptr fs_buffer
		push	ds
		push	es
		jz	deblock7
		mov	byte ptr 4[bx], 0FFh
		xchg	di, si
		xchg	ax, dx

deblock7:				; CODE XREF: deblock+17Aj
		mov	ds, dx
		mov	es, ax
		rep movsw
		pop	es
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$arecord:		; CODE XREF: get$bcba+58p deblock+BBp
					; ...
		mov	bx, curbcba
		mov	dx, offset bcb_drive
		mov	cl, 4

read$dir_ret:				; CODE XREF: read$dir+8j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

read$dir:		; CODE XREF: read$subdir+28p
					; cpm_login+48p ...
		call	r$dir
		test	relog, 0FFh	; Inlined r$dir1
		jz	read$dir_ret
		call	chk$exit$fxs
		call	tst$relog



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

rd$dir:		; CODE XREF: r$dir+2Ep
		mov	ax, dcnt
		mov	cl, 2
		shr	ax, cl
		mov	drec, ax
		mov	bcb_record, ax
		mov	bcb_record_h, 0
		mov	ah, 3
		jmps	wrdir0

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

seek$copy:		; CODE XREF: delete11+1Dp copy$dir0+9j
					; ...
		call	check$write
		mov	cl, 0FFh
		call	checksum
		mov	ah, 5
wrdir0:		call	deblock

setdata:				; CODE XREF: bdos:2C5Ap bdos:3D22p
					; ...
		mov	ax, userdmaseg
		mov	word ptr fs_buffer, ax
		mov	ax, userdma
		mov	word ptr fs_buffer+2, ax
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

r$dir:		; CODE XREF: read$dirp	check$media+19p
		mov	dx, dpb_drm
		mov	bx, dcnt
		inc	bx
		mov	dcnt, bx
		sub	dx, bx
		jnb	read$dir0
		jmp	set$end$dir
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$dir0:				; CODE XREF: r$dir+Fj
		mov	al, byte ptr dcnt
		and	al, 3		; low(dcnt) and	dskmsk
		push	cx
		mov	cl, 5
		shl	al, cl		; Multiply by FCB size
		pop	cx
		mov	dptr, al
		test	dir_check_flag,	0FFh
		jnz	read$dir2
		or	al, al		; Return if not	a new record
		jnz	read_dir_ret1

read$dir2:				; CODE XREF: r$dir+27j
		push	cx
		call	rd$dir
		pop	cx
		test	relog, 0FFh
		jnz	read_dir_ret1

checksum:				; CODE XREF: seek$copy+20j
		mov	dx, drec
		mov	bx, dpb_cks
		and	bh, 7Fh		; Mask off fixed disk bit
		sub	dx, bx
		jnb	read_dir_ret	; Skip if > CSV	size
		push	cx
		call	compute$cs	; Compute checksum for current directory buffer
		mov	bx, drec
		add	bx, dph_csv
		pop	cx
		inc	cl
		jz	update$cs
		cmp	al, [bx]
		jz	read_dir_ret
		call	nowrite		; Return true if drive is software R/O
		jnz	read_dir_ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

media$change:		; CODE XREF: rdbuff+31p rd$parentdir+5Ep
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		mov	al, 0FFh
		mov	relog, al
		mov	hashl, al
		mov	bx, offset removable_drive
		call	set$cdisk
		jmp	reset37x

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

update$cs:		; CODE XREF: r$dir+5Dj
		mov	[bx], al
read_dir_ret:
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

getallocbit:		; CODE XREF: set$alloc$bit+1p
					; get$block+Dp	...
		mov	bx, cx
		and	cl, 7
		inc	cl
		mov	ch, cl
		mov	cl, 3
		shr	bx, cl
		add	bx, dph_alv
		mov	al, [bx]
		mov	cl, ch
		rol	al, cl
read_dir_ret1:
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$alloc$bit:		; CODE XREF: scandm$a+3Fp
		push	dx
		call	getallocbit
		and	al, 0FEh
		pop	dx
		or	al, dl

rotr:					; CODE XREF: get$block+2Cp
		ror	al, cl
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return ALV size in bytes

get$nalbs:		; CODE XREF: copy$alv+8p scandm$ab+6p
					; ...
		mov	bx, dpb_dsm
		mov	cl, 3
		shr	bx, cl
		inc	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$alv:		; CODE XREF: cpm_login+52j
					; DRV_FLUSH+31p ...
		pushf	
		call	get$nalbs	; Return ALV size in bytes
		mov	si, dph_alv
		mov	di, si
		add	di, bx
		mov	cx, bx
		popf
		jz	do_copy_alv
		xchg	si, di

do_copy_alv:				; CODE XREF: copy$alv+19j
		rep movsb

dont_copy_alv:				; CODE XREF: copy$alv+5j
		call	lru_free	; Free all LRU buffers for drive bcb_drive

scandm_ret:				; CODE XREF: scandm$a+10j
		retn	


;
; Set/Reset first ALV
;

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

scandm$a:		; CODE XREF: scandm$ab+1p scandm$ab+13p
					; ...
		call	getdptra
		add	bx, 10h
		push	cx
		mov	cl, 11h

scandm0:				; CODE XREF: scandm$a+45j
		pop	dx
		dec	cl
		jnz	scandm0a
		or	dl, dl
		jnz	scandm_ret
		mov	bx, dph_alv
		mov	ax, dpb_al0_al1
		or	[bx], ax
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scandm0a:				; CODE XREF: scandm$a+Cj
		push	dx
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	scandm1
		push	cx
		push	bx
		mov	cl, [bx]
		mov	ch, 0
		jmps	scandm2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

scandm1:				; CODE XREF: scandm$a+22j
		dec	cl
		push	cx
		mov	cx, [bx]
		inc	bx
		push	bx

scandm2:				; CODE XREF: scandm$a+2Aj
		or	cx, cx
		jz	scandm3
		mov	bx, dpb_dsm
		cmp	bx, cx
		jb	scandm3
		call	set$alloc$bit

scandm3:				; CODE XREF: scandm$a+35j scandm$a+3Dj
		pop	bx
		inc	bx
		pop	cx
		jmps	scandm0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

scandm$ab:		; CODE XREF: delete11+28p F_TRUNCATE+70p
					; ...
		push	cx
		call	scandm$a
		pop	cx

scandm$b:				; CODE XREF: close$fcb+A0p
		push	cx
		call	get$nalbs	; Return ALV size in bytes
		pop	cx
		mov	ax, dph_alv
		push	ax
		add	ax, bx
		mov	dph_alv, ax
		call	scandm$a
		pop	dph_alv
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_login:		; CODE XREF: curselect+15p
		cmp	dpb_cks, 8000h
		jnz	cpm_loginfixed
		mov	bx, lsn$add
		test	byte ptr 2[bx], 0FFh
		jnz	initial2a

cpm_loginfixed:				; CODE XREF: cpm_login+6j
		mov	bx, dph_dtabcb
		call	discard$data	; Called with BX->BCB chain head. Release all BCBs for a drive
		call	discard$dir	; Release all directory	BCBs for a drive
		call	get$nalbs	; Return ALV size in bytes
		mov	cx, bx
		mov	di, dph_alv
		mov	ax, dpb_al0_al1
		stosw			; Reserve directory blocks
		dec	cx
		dec	cx
		xor	ax, ax
		rep stosb		; Rest of ALV to zero
		mov	bx, lsn$add
		mov	[bx], al
		mov	1[bx],	al	; Home the disk
		mov	bcb_dirty, ax
		mov	bx, cdrmaxa
		mov	word ptr [bx], 4
		call	set$end$dir

initial2:				; CODE XREF: cpm_login+5Fj
					; cpm_login+63j ...
		mov	cl, 0FFh
		call	read$dir
		call	end$of$dir
		jnz	initial2b
		mov	bx, lsn$add
		inc	byte ptr 2[bx]
		xor	al, al

initial2a:				; CODE XREF: cpm_login+10j
		jmp	copy$alv
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

initial2b:				; CODE XREF: cpm_login+4Ej
		call	fix$hash
		call	getdptra
		mov	al, [bx]
		cmp	al, 21h		; Skip date/time records
		jz	initial2
		cmp	al, 0E5h	; Skip deleted files
		jz	initial2
		cmp	al, 20h		; Skip labels
		jz	drv$lbl
		test	al, 10h
		jnz	initial3
		mov	cl, 1		; Scan for allocated blocks
		call	scandm$a

initial3:				; CODE XREF: cpm_login+6Bj
					; cpm_login+80j
		call	setcdr
		jmps	initial2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

drv$lbl:				; CODE XREF: cpm_login+67j
		mov	al, 12[bx]
		mov	bx, lsn$add
		mov	[bx], al
		jmps	initial3

;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

copy$dir$loc:				; CODE XREF: delete10+2j bdos:47FCj
					; ...
		mov	al, dirloc
		jmp	sta$ret

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$wild_cpm:		; CODE XREF: set$hash+2Dp cpm_delete+2Ap
					; ...
		xor	dl, dl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$wild0:		; CODE XREF: valid_dl_f_fcb+3p
					; bdos:47B1p ...
		mov	cx, 0Bh
		mov	si, bx
		inc	si

chk_fcb_char:				; CODE XREF: check$wild0+19j
		lodsb
		and	al, 7Fh
		cmp	al, '?'
		jz	set$hashret
		or	dl, dl
		jz	chk_fcb_dl0
		cmp	al, '['
		jz	set$hashret
		cmp	al, ']'
		jz	set$hashret

chk_fcb_dl0:				; CODE XREF: check$wild0+Fj
		loop	chk_fcb_char
		or	al, 1

set$hashret:				; CODE XREF: check$wild0+Bj
					; check$wild0+13j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$wild:		; CODE XREF: F_OPEN+29p bdos:4790p
					; ...
		xor	dl, dl



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

valid_dl_f_fcb:		; CODE XREF: F_MAKE+10p
		mov	bx, offset user_fcb
		call	check$wild0
		jnz	set$hashret
		mov	ah, 9
		jmp	disk_error



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$hash:		; CODE XREF: searchi+10p
		cmp	dph_hash, 0
		jz	set$hashret
		or	cl, cl
		jz	set$hashret
		cmp	cl, 0Ch
		jb	set$hash2
		mov	al, 2
		jz	set$hash1
		mov	al, 3

set$hash1:				; CODE XREF: set$hash+12j
		mov	hashl, al
		mov	al, fs_function
		cmp	al, 3
		jz	get$hash
		cmp	al, 11h
		jz	set$hash15
		cmp	al, 7
		jnb	get$hash

set$hash15:				; CODE XREF: set$hash+22j
		mov	hashl, 2
		call	chk$wild_cpm
		jnz	get$hash

set$hash2:				; CODE XREF: set$hash+Ej
		mov	hashl, 0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$hash:		; CODE XREF: set$hash+1Ej set$hash+26j
					; ...
		mov	si, bx
		lodsb
		mov	hash, al
		xor	bx, bx
		and	al, 20h
		jz	get$hash0
		or	hash, 10h
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

get$hash0:				; CODE XREF: get$hash+Aj
		mov	dl, al
		mov	cx, 0Bh

get$hash1:				; CODE XREF: get$hash+40j
		cmp	cl, 6
		jz	get$hash3
		cmp	cl, 4
		jz	get$hash3
		shl	bx, 1
		rcl	dl, 1
		test	cl, 1
		jnz	get$hash3
		shl	bx, 1
		rcl	dl, 1

get$hash3:				; CODE XREF: get$hash+1Aj get$hash+1Fj
					; ...
		lodsb
		and	al, 7Fh
		sub	al, 20h
		ror	al, 1
		jnb	get$hash4
		rol	al, 1

get$hash4:				; CODE XREF: get$hash+35j
		xor	ah, ah
		add	bx, ax
		adc	dl, 0
		loop	get$hash1
		mov	word ptr hash+1, bx
		mov	bx, offset hash
		and	dl, 3
		ror	dl, 1
		ror	dl, 1
		or	[bx], dl
		lodsb
		and	al, 1Fh
		inc	si
		mov	ah, [si]
		and	ah, 3Fh
		mov	cl, 3
		shl	al, cl
		shr	ax, cl
		mov	dl, dpb_exm
		shl	ax, 1

get$hash5:				; CODE XREF: get$hash+6Bj
		shr	ax, 1
		shr	dl, 1
		jb	get$hash5
		and	ah, 1
		ror	ah, cl
		or	[bx], ah
		mov	3[bx],	al

get$hashret:				; CODE XREF: search$hash+5j
					; search$hash+Cj ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$hash:		; CODE XREF: searchn+5p
		cmp	dph_hash, 0
		jz	get$hashret
		mov	al, searchl
		or	al, al
		jz	get$hashret
		cmp	hashl, 0FFh
		jz	get$hashret
		mov	bx, cdrmaxa
		mov	cx, [bx]
		dec	al
		jnz	search$h0
		mov	cx, dpb_drm

search$h0:				; CODE XREF: search$hash+1Dj
		mov	bx, dcnt
		sub	cx, bx
		jz	get$hashret
		mov	es, dph_hash

		inc	bx
		mov	di, bx
		shl	di, 1
		shl	di, 1
		sub	di, 4
		call	search$h_sub
		mov	ax, ds
		mov	es, ax

		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$h_sub:		; CODE XREF: search$hash+39p
					; search$h_sub+16j
		add	di, 4
		mov	si, offset hash
		lodsb
		xor	al, es:[di]
		mov	dl, al
		and	al, 1Fh
		jnz	search$h2b
		call	search$h6
		jz	search$h2g

search$h2:				; CODE XREF: search$h_sub+39j
					; search$h_sub+3Fj ...
		inc	bx
		loop	search$h_sub
		cmp	dcnt, 0FFFFh
		jnz	search$h2a
		mov	ax, ds
		mov	es, ax
		call	tst$log$fxs
		jnz	search$h2a
		mov	hashl, 0FFh

search$h2a:				; CODE XREF: search$h_sub+1Dj
					; search$h_sub+26j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2b:				; CODE XREF: search$h_sub+Ej
		mov	al, byte ptr xdcnt+1
		inc	al
		jnz	search$h2c
		cmp	es:byte ptr [di], 0F5h
		jnz	search$h2
		jmps	search$h2d
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2c:				; CODE XREF: search$h_sub+33j
		inc	al
		jnz	search$h2
		call	search$h6
		jnz	search$h2
		mov	al, find$xfcb
		inc	al
		jnz	search$h2e
		test	es:byte ptr [di], 10h
		jz	search$h2
		test	dl, 0Fh
		jnz	search$h2

search$h2d:				; CODE XREF: search$h_sub+3Bj
		mov	xdcnt, bx
		jmps	search$h2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2e:				; CODE XREF: search$h_sub+4Bj
		inc	al
		jnz	search$h2f
		test	dl, 0Fh
		jnz	search$h2
		jmps	search$h2g
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$h2f:				; CODE XREF: search$h_sub+60j
		test	es:byte ptr [di], 1Fh
		jnz	search$h2

search$h2g:				; CODE XREF: search$h_sub+13j
					; search$h_sub+67j
		mov	dx, dcnt
		dec	bx
		mov	dcnt, bx
		mov	al, bl
		and	al, 3
		cmp	al, 3
		jz	search$hret
		and	bl, 0FCh
		and	dl, 0FCh
		cmp	bx, dx
		jz	search$hret
		or	dir_check_flag,	0Fh
		xor	al, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

search$h6:		; CODE XREF: search$h_sub+10p
					; search$h_sub+41p
		mov	al, hashl
		or	al, al
		jz	search$hret
		mov	ah, 0E0h
		cmp	al, 3
		jz	search$h6a
		mov	ah, 0C0h

search$h6a:				; CODE XREF: search$h6+Bj
		test	dl, ah
		jnz	search$hret
		xor	ah, ah
		xchg	ax, cx
		push	di
		inc	di
		rep cmpsb
		xchg	ax, cx
		pop	di

search$hret:				; CODE XREF: search$h_sub+7Ej
					; search$h_sub+88j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

fix$hash:		; CODE XREF: cpm_login+55p
					; delete11+2Bp	...
		cmp	dph_hash, 0
		jz	search$hret
		push	word ptr hash
		push	word ptr hash+2
		call	getdptra
		call	get$hash
		mov	ax, dcnt
		shl	ax, 1
		shl	ax, 1
		mov	di, ax
		mov	es, dph_hash

		mov	si, offset hash
		mov	cx, 2
		rep movsw
		mov	ax, ds
		mov	es, ax

		pop	word ptr hash+2
		pop	word ptr hash
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

save$dcnt$pos1:		; CODE XREF: searchn+34p searchn+56p
		cmp	byte ptr xdcnt+1, 0FFh
		jnz	search$hret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

save$dcnt$pos0:		; CODE XREF: bdos:3716p bdos:3737p
					; ...
		mov	ax, dcnt
		mov	xdcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

searchi:		; CODE XREF: search$extnum+2p
					; restore_dir_fcb+5p
					; ...
		mov	bx, offset user_fcb
		mov	searcha, bx

searchi1:				; CODE XREF: does$xfcb$exist+18p
					; bdos:47BAp
		mov	dirloc,	0FFh
		mov	searchl, cl
		call	set$hash
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find the first extent	of a file

find_extent_0:		; CODE XREF: update$stamp+16p
					; F_TIMEDATE+10p ...
		xor	ax, ax
		mov	user_fcb+0Ch, al
		mov	user_fcb+0Eh, al



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find a numbered extent

search$namlen:		; CODE XREF: openp close$fcb+Cp
					; ...
		mov	cl, 0Fh
		jmps	search



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Find any extent of a file

search$extnum:		; CODE XREF: cpm_delete+8p
					; cpm_delete+47p ...
		mov	cl, 0Ch

search:					; CODE XREF: search$namlen+2j
					; F_SFIRST+4Ap	...
		call	searchi

search1:				; CODE XREF: bdos:47BDp
		call	set$end$dir	; Entry	point used by rename



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Search for the next directory	element,
; assuming a previous call on search

searchn:		; CODE XREF: searchn+4Fj bdos:3719j
					; ...
		mov	user0$pass, 0	; Don't try user 0 yet
		call	search$hash
		jnz	search$fin
		mov	cl, 0
		call	read$dir	; Read next dir	element
		call	end$of$dir
		jz	search$fin
		mov	dx, searcha	; Not end of dir, scan for match
		mov	si, dx
		lodsb
		cmp	al, 0E5h
		jz	searchnext	; Keep scanning	if empty
		push	dx		; Not empty, may be end	of logical directory
		call	compcdr		; Past logical end?
		pop	dx
		jnb	search$fin	; Artificial stop

searchnext:				; CODE XREF: searchn+1Dj
		call	getdptra	; BX = buffa + dptr
		mov	cl, searchl	; CL = length of search
		xor	ch, ch		; CH counts up,	CL counts down
		cmp	byte ptr [bx], 0E5h
		jnz	srchnxt1
		call	save$dcnt$pos1

srchnxt1:				; CODE XREF: searchn+32j
		mov	save$xfcb, 0
		mov	al, [bx]
		and	al, 0EFh	; Is this an XFCB?
		cmp	al, [bx]
		jz	search$loop
		mov	si, dx
		cmp	al, [si]
		jnz	search$loop
		mov	al, find$xfcb
		or	al, al
		jz	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		mov	save$xfcb, al
		jmps	searchok
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$fin:				; CODE XREF: searchn+8j searchn+12j
					; ...
		call	save$dcnt$pos1
		call	set$end$dir



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

lret$eq$ff:		; CODE XREF: chk$exit$fxs+17j
					; rdbuff+56p ...
		mov	al, 0FFh
		mov	ch, al
		inc	ch
		jmp	sta$ret


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

search$loop:				; CODE XREF: searchn+42j searchn+48j
					; ...
		or	cl, cl
		jz	endsearch
		mov	si, dx
		lodsb
		cmp	ch, 0Eh
		jnz	not_modnum
		and	al, 3Fh		; Mask off high	2 bits
		jmps	was_modnum
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

not_modnum:				; CODE XREF: bdos:36E1j
		and	al, 7Fh
		cmp	al, '?'         ; "?" in user FCB matches all
		jz	searchok
		cmp	ch, 0Dh		; If S1, continue
		jz	searchok
		cmp	ch, 0Ch		; Extent?
		jz	searchext

was_modnum:				; CODE XREF: bdos:36E5j
		sub	al, [bx]
		and	al, 7Fh		; Mask out flags/extent	modulus
		jnz	searchnm	; Skip if not matched
		jmps	searchok
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

searchext:				; CODE XREF: bdos:36F5j
		push	cx
		mov	cl, [bx]
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		pop	cx
		jnz	j_searchn	; No match
		test	user0$pass, 0FFh
		jz	disable_user0
;
; inlined save$dcnt$pos2
;
		inc	bx
		inc	bx
		cmp	byte ptr [bx], 0
		jnz	j_searchn
		call	save$dcnt$pos0
		jmp	searchn		; Search for the next directory	element,
					; assuming a previous call on search
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Disable search of user 0 if any fcb is found under
; the current user number
;

disable_user0:				; CODE XREF: bdos:370Dj
		mov	search$user0, 0

searchok:				; CODE XREF: searchn+54j bdos:36EBj
					; ...
		inc	dx
		inc	bx
		inc	ch
		dec	cl
		jmps	search$loop
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Entire name matches, return dir position
;

endsearch:				; CODE XREF: bdos:36D9j
		cmp	save$xfcb, 0FFh
		jnz	endsearch1
		cmp	byte ptr xdcnt+1, 0FEh
		jnz	j_searchn
		call	save$dcnt$pos0

j_searchn:				; CODE XREF: bdos:3706j bdos:3714j
					; ...
		jmp	searchn		; Search for the next directory	element,
					; assuming a previous call on search
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

endsearch1:				; CODE XREF: bdos:372Ej
		xor	al, al
		mov	dirloc,	al
		mov	byte ptr aret, al
;
; Successful search - return with zero flag reset
;
		mov	ch, al
		inc	ch

endsearch_ret:				; CODE XREF: does$xfcb$exist+5j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
; Search no match routine

searchnm:				; CODE XREF: bdos:36FBj
		or	ch, [bx]
		jnz	j_searchn	; fcb(0)?
		test	search$user0, 0FFh
		jz	j_searchn	; dir fcb(0)=0?
		mov	user0$pass, 0FFh
		jmps	searchok

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init_xfcb_srch:		; CODE XREF: bdos:47A5p bdos:47DCp
		mov	al, 0FFh



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init_xfcb_srch1:		; CODE XREF: does$xfcb$exist+Cp
					; cpm_delete+5p
		mov	find$xfcb, al
		mov	al, 0FEh
		mov	byte ptr xdcnt+1, al

init_xfcbs_ret:				; CODE XREF: cpm_delete+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

does$xfcb$exist:		; CODE XREF: bdos:47D1p bdos:47F7p
		cmp	byte ptr xdcnt+1, 0FEh
		jz	endsearch_ret
		call	set_dcnt_dblk
		xor	al, al
		call	init_xfcb_srch1
		mov	bx, searcha
		or	byte ptr [bx], 10h
		mov	cl, 0Ch
		call	searchi1
		jmp	searchn		; Search for the next directory	element,
			; assuming a previous call on search


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

xdcnt_eq_dcnt:		; CODE XREF: openx+42p	openx+62p
					; ...
		mov	ax, dcnt
		mov	xdcnt, ax
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore_dir_fcb:		; CODE XREF: openx+4Ap	openx+87p
					; ...
		call	set_dcnt_dblk
		mov	cl, 0Fh
		call	searchi
		jmp	searchn		; Search for the next directory	element,
			; assuming a previous call on search


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_delete:		; CODE XREF: F_DELETE+1Bj
		call	get$atts

deletex:				; CODE XREF: cpm_delete+40j
		mov	al, 0FEh	; Make search return matching
					; fcbs and xfcbs
		call	init_xfcb_srch1
		call	search$extnum	; Find any extent of a file
		jz	init_xfcbs_ret

delete00:				; CODE XREF: cpm_delete+45j
		call	getdptra
		mov	al, [bx]
		and	al, 10h		; Is it	an xfcb?
		jnz	delete01	; yes
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jnz	delete00a
		call	check$rodir

delete00a:				; CODE XREF: cpm_delete+1Bj
		call	get$dir$mode
		rol	al, 1		; Delete requires password?
		jb	delete02	; No
		mov	bx, offset user_fcb
		call	chk$wild_cpm	; Is this a wildcard delete?
		jz	delete02
;
; Not wild and passwords inactive
; Skip to pass 2
;
		jmps	delete11
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ
;
; Check	XFCB password if passwords enabled
;

delete01:				; CODE XREF: cpm_delete+14j
		call	get$dir$mode
		rol	al, 1
		jnb	delete02
		call	chk_xfcb_passwd
		jz	delete02
		call	chk$pw$error
		jmps	deletex
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

delete02:				; CODE XREF: cpm_delete+25j
					; cpm_delete+2Dj ...
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	delete00
		call	search$extnum	; Find any extent of a file



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

delete10:		; CODE XREF: delete11+31j F_MAKE+ABp
		jnz	delete11
		jmp	copy$dir$loc



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

delete11:		; CODE XREF: cpm_delete+2Fj
					; delete10j ...
		call	getdptra
		mov	al, [bx]	; Is addressed dir fcb an xfcb?
		and	al, 10h
		jnz	delete12
		test	attributes, 80h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jnz	delete13

delete12:				; CODE XREF: delete11+7j
		mov	byte ptr [bx], 0E5h; Delete dir	FCB or XFCB

delete13:				; CODE XREF: delete11+Ej
		pushf	
		call	get$dtba$8	; Does SFCB exist?
		or	al, al
		jnz	delete13a
		mov	[bx], al	; If so, zero its mode byte

delete13a:				; CODE XREF: delete11+19j
		call	seek$copy
		popf
		jnz	delete13b
		mov	cl, 0
		call	scandm$ab

delete13b:				; CODE XREF: delete11+24j
		call	fix$hash
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jmps	delete10


;
; Given	allocation vector position CX, find the	closest	zero bit
; by searching left and	right. If found, set the bit to	1 and 
; return the bit position in BX. If not	found return BX=0
;
;

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$block:		; CODE XREF: cpm_writerec+5Fp
		mov	dx, cx

righttst:				; CODE XREF: get$block+18j
					; get$block+26j
		cmp	dx, dpb_dsm
		jnb	retblock0
		inc	dx
		push	cx
		push	dx
		mov	cx, dx
		call	getallocbit
		rcr	al, 1
		jnb	retblock
		pop	dx
		pop	cx

lefttst:				; CODE XREF: get$block+44j
		or	cx, cx
		jz	righttst
		dec	cx
		push	dx
		push	cx
		call	getallocbit
		rcr	al, 1
		jnb	retblock
		pop	cx
		pop	dx
		jmps	righttst
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

retblock:				; CODE XREF: get$block+12j
					; get$block+22j
		rcl	al, 1
		inc	al
		call	rotr
		mov	cl, curdsk
		mov	bx, offset proc_using_drvs
		push	ds
		mov	ds, rlr
		call	set$cdisk1
		pop	ds
		pop	bx
		pop	dx
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

retblock0:				; CODE XREF: get$block+6j
		or	cx, cx
		jnz	lefttst
		mov	bx, cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$dir2:		; CODE XREF: copy$dir0p F_ATTRIB+27p
		push	dx
		mov	ch, 0
		mov	dx, offset user_fcb
		add	dx, cx
		call	getdptra
		pop	cx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Copy FCB information starting	at CL for DL bytes
; into the currently addressed directory entry

copy$dir:		; CODE XREF: bdos:47ECp
		mov	dh, 80h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$dir0:		; CODE XREF: make+59p
		call	copy$dir2
		inc	cl

copy$dir1:				; CODE XREF: copy$dir0+1Bj
		dec	cl
		jnz	copy$dir1a
		jmp	seek$copy
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

copy$dir1a:				; CODE XREF: copy$dir0+7j
		mov	ah, [bx]
		and	ah, ch
		mov	si, dx
		lodsb
		and	al, 7Fh
		or	al, ah
		mov	[bx], al
		inc	bx
		inc	dx
		jmps	copy$dir1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy$user$no:		; CODE XREF: bdos:47A8p bdos:47D9p
					; ...
		mov	al, user_fcb
		mov	bx, offset user_fcb+10h
		mov	[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open:		; CODE XREF: cpm_rwrand+89p
					; F_OPEN+3Dp ...
		call	search$namlen	; Find a numbered extent

open1:					; CODE XREF: F_OPEN+6Ap
		jz	set$rcret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open$copy:		; CODE XREF: open$reel+52p
		call	setfwf
		push	bx		; BX->S2
		dec	bx
		dec	bx		; BX->EX
		mov	ah, [bx]
		push	ax		; AH=EX	AL=S2
		call	getdptra
		mov	dx, bx
		mov	bx, offset user_fcb
		mov	cl, 20h
		call	move		; Copy CL bytes	from DX	to BX
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		pop	ax		; Restore original EX and S2
		pop	bx
		mov	[bx], al
		dec	bx
		dec	bx
		mov	[bx], ah



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$rc:		; CODE XREF: getfcb+12p close+27p
					; ...
		xor	ch, ch
		mov	si, offset user_fcb+0Fh
		mov	al, [bx]
		sub	al, cl
		jz	set$rc2
		mov	al, ch
		jnb	set$rc1
		mov	al, 80h
		or	al, [si]

set$rc1:				; CODE XREF: set$rc+Dj
		mov	[si], al

set$rcret:				; CODE XREF: open+3j set$rc+18j
					; ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

set$rc2:				; CODE XREF: set$rc+9j
		cmp	[si], al
		jnz	set$rcret

set$rc3:				; CODE XREF: close$fcb+86p
					; F_TRUNCATE+CDp ...
		xor	al, al
		mov	[si], al
		cmp	dminx, al
		jz	set$rcret
		mov	byte ptr [si], 80h
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore$rc:		; CODE XREF: close+20p	open$reel+9Cp
					; ...
		mov	al, user_fcb+0Fh
		cmp	al, 81h
		jb	restore$rc1
		and	al, 7Fh
		mov	user_fcb+0Fh, al

restore$rc1:				; CODE XREF: restore$rc+5j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

mergezero:		; CODE XREF: close$fcb+40p
					; close$fcb+45p
		cmp	word ptr [bx], 0
		jnz	mzero_ret
		mov	si, dx
		lodsw
		mov	[bx], ax

mzero_ret:				; CODE XREF: mergezero+3j close$fcb+Fj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

close$fcb:		; CODE XREF: close+2Ap
		test	byte ptr dpb_cks+1, 80h
		jnz	close$fcb0
		mov	dir_check_flag,	0F0h

close$fcb0:				; CODE XREF: close$fcb+5j
		call	search$namlen	; Find a numbered extent
		jz	mzero_ret
		call	getdptra
		add	bx, 10h
		mov	dx, bx
		mov	bx, offset user_fcb+10h
		mov	cl, 10h

merge0:					; CODE XREF: close$fcb+5Aj
		cmp	single,	0	; Nonzero if using 8-bit blocks
		jz	merged
		mov	al, [bx]
		or	al, al
		mov	si, dx
		lodsb
		jnz	fcbnzero
		mov	[bx], al

fcbnzero:				; CODE XREF: close$fcb+2Cj
		or	al, al
		jnz	buffnzero
		mov	al, [bx]
		mov	di, dx
		cld	
		stosb

buffnzero:				; CODE XREF: close$fcb+32j
		cmp	al, [bx]
		jz	dmset
		jmps	mergerr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

merged:					; CODE XREF: close$fcb+23j
		call	mergezero
		xchg	bx, dx
		call	mergezero
		xchg	bx, dx
		mov	si, dx
		mov	ax, [si]
		cmp	ax, [bx]
		jnz	mergerr
		inc	dx
		inc	bx
		dec	cl

dmset:					; CODE XREF: close$fcb+3Cj
		inc	dx
		inc	bx
		dec	cl
		jnz	merge0
		mov	bx, dx
		sub	bx, 14h
		push	bx
		call	get$dir$ext	; Compute directory extent from	FCB
		pop	si
		mov	cl, [si]
		mov	ch, [bx]
		mov	[si], al
		mov	[bx], al
		add	si, 3
		add	bx, 3
		cmp	al, cl
		jnz	mrg$rc1
		cmp	al, ch
		jnz	mrg$rc2
		mov	al, [si]
		cmp	al, [bx]
		jb	mrg$rc1
		or	al, al
		jnz	mrg$rc2
		call	set$rc3

mrg$rc1:				; CODE XREF: close$fcb+76j
					; close$fcb+80j
		xchg	bx, si

mrg$rc2:				; CODE XREF: close$fcb+7Aj
					; close$fcb+84j
		mov	al, [si]
		mov	[bx], al
		call	getdptra
		add	bx, 0Bh
		mov	al, [bx]
		and	al, 7Fh
		mov	[bx], al
		call	setfwf
		mov	cl, 1
		call	scandm$b
		jmp	seek$copy
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

mergerr:				; CODE XREF: close$fcb+3Ej
					; close$fcb+50j ...
		call	setfwf
		mov	word ptr 2[bx], 0FFFFh
		jmp	lret$eq$ff



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

close:		; CODE XREF: open$reel+19p
					; cpm_rwrand+64p ...
		xor	ax, ax
		mov	byte ptr aret, al
		call	nowrite		; Return true if drive is software R/O
		jnz	makeret
		mov	al, user_fcb+0Eh
		and	al, 80h
		jnz	makeret
		call	cp_fcb10_ffff
		jz	mergerr
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		mov	ch, [bx]
		push	cx
		mov	[bx], al
		call	restore$rc
		cmp	cl, ch
		jnb	close1
		call	set$rc

close1:					; CODE XREF: close+25j
		call	close$fcb
		mov	bx, offset user_fcb+0Ch
		pop	cx
		mov	cl, [bx]
		mov	[bx], ch
		jmp	set$rc



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

make:		; CODE XREF: open$reel+4Bp
					; cpm_rwrand+9Ep ...
		cmp	xdcnt, 0FFFFh
		jz	cpm_make0
		call	set_dcnt_dblk

cpm_make0:				; CODE XREF: make+5j
		push	word ptr user_fcb
		mov	user_fcb, 0E5h
		mov	cl, 1
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		pop	word ptr user_fcb
		jnz	make01

makeret:				; CODE XREF: close+8j close+Fj
					; ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

make01:					; CODE XREF: make+1Fj
		test	make$xfcb, 0FFh
		jnz	makeret
		mov	bx, offset user_fcb+0Dh
		mov	byte ptr [bx], 0
		inc	bx
		mov	al, [bx]
		push	ax
		push	bx
		and	byte ptr [bx], 3Fh
		inc	bx
		mov	cx, 11h
		mov	al, 1

make0:					; CODE XREF: make+41j make+4Fj
		mov	byte ptr [bx], 0
		inc	bx
		loop	make0
		dec	al
		jnz	make1
		call	get$dtba
		or	al, al
		mov	cx, 0Ah
		jz	make0

make1:					; CODE XREF: make+45j
		call	setcdr
		mov	cl, 0
		mov	dx, 20h
		call	copy$dir0
		pop	bx
		pop	ax
		mov	[bx], al
		mov	result_F0F, 0
		call	fix$hash
		jmp	setfwf



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

open$reel:		; CODE XREF: bdos:3D06p cpm_writerec+37p
		mov	al, user_fcb+0Eh
		mov	openreel_S2, al
		mov	bx, offset user_fcb+0Ch
		mov	al, [bx]
		mov	cl, al
		inc	cl
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jnz	open$reel00
		jmp	open$reel3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel00:				; CODE XREF: open$reel+12j
		push	bx
		push	cx
		call	close
		pop	cx
		pop	bx
		cmp	byte ptr aret, 0FFh
		jnz	open$reel01
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel01:				; CODE XREF: open$reel+23j
		mov	al, 1Fh
		and	al, cl		; Increment extent
		mov	[bx], al
		jnz	open$reel0
		add	bx, 2
		inc	byte ptr [bx]
		mov	al, [bx]	; Increment module
		and	al, 3Fh
		jz	open$r$error

open$reel0:				; CODE XREF: open$reel+2Cj
		mov	xdcnt, 0FFFFh
		call	search$namlen	; Find a numbered extent
		jnz	open$reel1
		mov	al, rmf		; Read mode flag
		inc	al
		jz	open$r$error
		call	make
		jz	open$r$error
		jmps	open$reel1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel1:				; CODE XREF: open$reel+42j
		call	open$copy

open$reel1a:				; CODE XREF: open$reel+50j
		call	set$lsn

open$reel2:				; CODE XREF: open$reel+A2j
		call	getfcb		; Set variables	from currently addressed FCB
		xor	al, al
		mov	vrecord, al
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$r$error:				; CODE XREF: open$reel+37j
					; open$reel+49j ...
		mov	bx, offset user_fcb+0Ch
		mov	al, openreel_S2
		mov	2[bx],	al
		mov	al, [bx]
		dec	al
		and	al, 1Fh
		mov	[bx], al
		mov	open_unknown, 0FFh
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel3:				; CODE XREF: open$reel+14j
		mov	[bx], cl
		call	get$dir$ext	; Compute directory extent from	FCB
		mov	cl, al
		test	high$ext, 80h
		jnz	open$reel4
		cmp	al, [bx]
		jnb	open$reel4
		dec	byte ptr [bx]
		cmp	rmf, 0FFh	; Read mode flag
		jnz	open$reel3a
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

open$reel3a:				; CODE XREF: open$reel+95j
		inc	byte ptr [bx]

open$reel4:				; CODE XREF: open$reel+88j
					; open$reel+8Cj
		call	restore$rc
		call	set$rc
		jmps	open$reel2



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_rwrand:
		push	cx
		mov	al, user_fcb+21h
		mov	dl, al
		and	dl, 7Fh
		rcl	al, 1
		mov	al, user_fcb+22h
		mov	ch, al
		rcl	ch, 1
		and	ch, 1Fh
		and	al, 0F0h
		or	al, user_fcb+23h
		mov	cl, 4
		rol	al, cl
		mov	cl, ch
		mov	ch, al
		cmp	user_fcb+23h, 3
		mov	bl, 6
		jbe	crwr_1
		jmp	seekerr
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

crwr_1:					; CODE XREF: cpm_rwrand+Bj
		mov	user_fcb+20h, dl
		cmp	fs_function, 28	; Write	ZF?
		jz	diskwr11
		call	cp_fcb10_ffff
		jz	diskwr11
		mov	al, ch
		sub	al, user_fcb+0Eh
		and	al, 3Fh
		jnz	diskwr_err
		mov	al, user_fcb+0Ch
		cmp	al, cl
		jnz	fill0
		jmp	seekok2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fill0:					; CODE XREF: cpm_rwrand+2Fj
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jnz	diskwr_err
		push	cx
		call	get$dir$ext	; Compute directory extent from	FCB
		pop	cx
		cmp	al, cl
		jnb	fill2
		test	high$ext, 80h
		jnz	fill2
		pop	dx
		push	dx
		inc	dl
		jnz	fill2
		inc	dl
		pop	dx
		jmp	f_ret_1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

fill2:					; CODE XREF: cpm_rwrand+40j
					; cpm_rwrand+47j ...
		mov	user_fcb+0Ch, cl
		mov	cl, al
		call	restore$rc
		call	set$rc
		jmps	seekok2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

diskwr_err:				; CODE XREF: cpm_rwrand+28j
					; cpm_rwrand+37j
		push	cx
		call	close
		pop	cx
		mov	bl, 3
		mov	al, byte ptr aret
		inc	al
		jz	seekerr

diskwr11:				; CODE XREF: cpm_rwrand+19j
					; cpm_rwrand+1Ej
		mov	xdcnt, 0FFFFh
		xchg	cl, user_fcb+0Ch; CL = EX
		mov	al, user_fcb+0Eh; AL = S2
		xchg	ch, al		; CH = S2, CL =	EX
		push	cx
		and	ch, 40h
		or	al, ch
		mov	user_fcb+0Eh, al
		call	open
		mov	al, byte ptr aret
		inc	al
		jnz	seekok
		mov	bp, sp
		mov	cx, 2[bp]
		mov	bl, 4
		inc	cl
		jz	badseek
		call	make
		mov	bl, 5
		mov	al, byte ptr aret
		inc	al
		jz	badseek

seekok:					; CODE XREF: cpm_rwrand+91j
		pop	cx
		call	set$lsn

seekok2:				; CODE XREF: cpm_rwrand+31j
					; cpm_rwrand+61j
		pop	cx
		xor	al, al
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

badseek:				; CODE XREF: cpm_rwrand+9Cj
					; cpm_rwrand+A8j
		pop	ax
		mov	user_fcb+0Ch, al
		mov	user_fcb+0Eh, ah

seekerr:				; CODE XREF: cpm_rwrand+Dj
					; cpm_rwrand+6Fj
		pop	cx
		mov	byte ptr aret, bl
		or	bl, bl
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$nprs:		; CODE XREF: bdos:3D18p cpm_writerec+E4p
		mov	ch, blk$off	; Is direct transfer operation in
					; progress?
		mov	al, dir$cnt
		cmp	al, 2
		jb	check$npr1	; No.
		dec	al
		mov	dir$cnt, al
		stc	
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr1:				; CODE XREF: check$nprs+9j
		mov	al, dpb_phm
		mov	cl, al
		and	al, ch
		jz	check$npr11	; Are we in mid-physical record?

check$npr1a:				; CODE XREF: check$nprs+2Ej
					; check$nprs+35j ...
		or	cl, cl
		jz	check$npr1b
		xor	al, al		; No deblocking	required
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr1b:				; CODE XREF: check$nprs+1Dj
		or	al, 1		; Deblocking required
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$npr11:				; CODE XREF: check$nprs+19j
		mov	dh, cl
		not	dh
		mov	al, last_sec_count
		cmp	al, 2
		jb	check$npr1a
		test	high$ext, 80h
		jnz	check$npr1a
		mov	bx, offset vrecord
		mov	ah, [bx]
		add	al, ah
		cmp	al, 80h
		jb	check$npr2
		mov	al, 80h

check$npr2:				; CODE XREF: check$nprs+47j
		push	cx
		mov	byte ptr [bx], 7Fh
		push	bx
		push	ax
		mov	bl, al
		mov	al, dpb_blm
		mov	dl, al
		inc	dl
		not	al
		and	ah, al
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr21
		mov	al, rcount
		and	al, dh
		cmp	al, bl
		jb	check$npr23

check$npr21:				; CODE XREF: check$nprs+63j
		mov	al, bl

check$npr23:				; CODE XREF: check$nprs+6Cj
		sub	al, ah
		cmp	al, dl
		jb	check$npr9
		push	ax
		call	dm$position
		mov	ch, al
		mov	al, dminx
		cmp	al, ch
		mov	dl, al
		jz	check$npr5
		mov	cl, al
		push	cx
		mov	ch, 0
		call	get$dm		; Get block CX from FCB; returns in BX

check$npr4:				; CODE XREF: check$nprs+96j
					; check$nprs+B4j
		push	bx
		inc	cx
		call	get$dm		; Get block CX from FCB; returns in BX
		pop	dx
		inc	dx
		cmp	bx, dx
		jz	check$npr4
		test	rmf, 0FFh	; Read mode flag
		jnz	check$nptr45
		or	bx, bx
		jnz	check$nptr45
		cmp	dx, dpb_dsm
		jnb	check$nptr45
		push	cx
		push	dx
		mov	cx, dx
		call	getallocbit
		pop	bx
		pop	cx
		shr	al, 1
		jnb	check$npr4

check$nptr45:				; CODE XREF: check$nprs+9Dj
					; check$nprs+A1j ...
		dec	cl
		pop	dx
		mov	al, dh
		cmp	al, cl
		jb	check$npr5
		mov	al, cl

check$npr5:				; CODE XREF: check$nprs+83j
					; check$nprs+BDj
		sub	al, dl
		mov	ch, al
		inc	ch
		mov	al, dpb_blm
		inc	al
		mul	ch
		pop	cx
		xchg	al, cl
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr8
		cmp	al, cl
		jb	check$npr9

check$npr8:				; CODE XREF: check$nprs+D6j
		mov	al, cl

check$npr9:				; CODE XREF: check$nprs+74j
					; check$nprs+DAj
		pop	cx
		pop	bx
		mov	[bx], ch
		pop	cx
		mov	dh, last_sec_count
		sub	al, ch
		cmp	al, dh
		jb	check$npr10
		mov	al, dh

check$npr10:				; CODE XREF: check$nprs+EBj
		not	cl
		and	al, cl
		jz	check$npr10b
		mov	dir$cnt, al
		test	rmf, 0FFh	; Read mode flag
		jz	check$npr10a
		push	ax
		call	flushx
		pop	ax

check$npr10a:				; CODE XREF: check$nprs+FDj
		mov	cl, dpb_psh
		shr	al, cl
		mov	fs_rdwrcount, al
		or	al, 1

check$npr10b:				; CODE XREF: check$nprs+F3j
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_readrec:				; CODE XREF: F_READ+Fj	F_READRAND+16j
		call	tst$inv$fcb
		mov	al, 0FFh
		mov	rmf, al		; Read mode flag
		call	getfcb		; Set variables	from currently addressed FCB
		mov	al, vrecord
		cmp	al, rcount
		jb	recordok	; In the current extent
		cmp	al, 80h
		jnz	setlret1	; Already off EOF
		call	open$reel	; Open the next	extent
		cmp	byte ptr aret, 0
		jnz	setlret1

recordok:				; CODE XREF: bdos:3D00j
		call	index		; Compute disk block number from current FCB
		jz	setlret1
		call	atran
		call	check$nprs
		jb	j_setfcb
		jnz	read$deblock
		jmp	go_rdbuff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

read$deblock:				; CODE XREF: bdos:3D1Dj
		call	setdata
		call	seek
		call	rdbuff

j_setfcb:				; CODE XREF: bdos:3D1Bj
		jmp	setfcb		; Place	values back into current FCB
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

setlret1:				; CODE XREF: bdos:3D04j bdos:3D0Ej
					; ...
		jmp	f_ret_1

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

;;


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

cpm_writerec:		; CODE XREF: F_WRITE+Fj F_WRITERAND+16j
					; ...
		mov	rmf, 0		; Read mode flag
		call	check$write
		mov	al, user_fcb+0Eh
		rcl	al, 1
		not	al
		test	xfcb_rdonly, al
		mov	ah, 3		; File R/O
		jz	writeseq_1

writeseq_err:				; CODE XREF: cpm_writerec+1Fj
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

writeseq_1:				; CODE XREF: cpm_writerec+15j
		test	high$ext, 40h	; In R/O mode?
		jnz	writeseq_err
		mov	bx, offset user_fcb
		call	check$rofile
		call	tst$inv$fcb
		call	update$stamp
		call	getfcb		; Set variables	from currently addressed FCB
		mov	al, vrecord
		cmp	al, 80h
		jb	dskwrite0
		call	open$reel
		test	byte ptr aret, 0FFh
		jz	dskwrite0
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dskwrite0:				; CODE XREF: cpm_writerec+35j
					; cpm_writerec+3Fj
		call	index		; Compute disk block number from current FCB
		jz	dskwrite2
		mov	cl, 0		; Marked as normal write operation
					; for wrbuff
		jmps	diskwr1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dskwrite2:				; CODE XREF: cpm_writerec+45j
		call	dm$position
		mov	dminx, al
		xor	cx, cx		; May use block	zero
		or	al, al
		jz	nopblock	; Skip if no prev block
		mov	cl, al
		dec	cx
		call	get$dm		; Get block CX from FCB; returns in BX
		mov	cx, bx

nopblock:				; CODE XREF: cpm_writerec+55j
		call	get$block
		or	bx, bx		; Can't find a block?
		jnz	blockok
		mov	al, 2		; Disk full
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

blockok:				; CODE XREF: cpm_writerec+64j
		mov	bcb_record, bx
		mov	dx, bx
		call	lru_touch	; Take the last	LRU buffer, move to head of chain,
					; allocate to drive bcb_drive block DX
		mov	bx, offset user_fcb+10h
		cmp	single,	0	; Nonzero if using 8-bit blocks
		mov	al, dminx
		mov	ah, 0
		jz	allocwd
		add	bx, ax
		mov	[bx], dl
		jmps	diskwru
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

allocwd:				; CODE XREF: cpm_writerec+81j
		add	bx, ax
		add	bx, ax
		mov	[bx], dx
		inc	bx

diskwru:				; CODE XREF: cpm_writerec+87j
		mov	cl, 2		; Write	to previously unallocated block

diskwr1:				; CODE XREF: cpm_writerec+49j
		mov	deblock_flag, cl
		call	atran
		cmp	fs_function, 16h; Write	random with ZF?
		jnz	dskwr11
		cmp	deblock_flag, 2
		jnz	dskwr11
		mov	deblock_flag, 0
		push	bcb_record
		mov	al, dpb_phm
		inc	al
		xor	ah, ah
		push	ax
		xchg	al, ah
		shr	ax, 1
		mov	cx, ax
		mov	di, dph_dirbcb
		sub	di, 0Ch

setdir1a:				; CODE XREF: setdir1+1Aj
 		mov	di, 12[di]
		cmp	word ptr 12[di], 0
		jnz	setdir1a
		mov	byte ptr [di], 0FFh
		mov	di, 10[di]
		mov	word ptr fs_buffer+2, di
		mov	word ptr fs_buffer, ds
		xor	al, al
		rep stosb
		mov	cl, dpb_blm
		call	lru_ckdirty	; Returns Carry	set if buffer dirty?
		mov	ax, bcb_dirty
		mov	cl, 2

fill1:					; CODE XREF: cpm_writerec+DDj
		mov	bcb_record, ax
		push	cx
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		call	seek
		pop	cx
		call	wrbuff
		mov	ax, bcb_record	; Restore record
		pop	bx
		push	bx
		add	ax, bx		; Continue until (blkmsk & arecord) = 0
		mov	bl, dpb_blm
		and	bl, al
		mov	cl, 0
		jnz	fill1
		pop	bx
		pop	bcb_record

dskwr11:				; CODE XREF: cpm_writerec+9Ej
					; cpm_writerec+A5j
		call	check$nprs
		jb	dont$write
		jnz	_write
		mov	ah, 2
		call	deblock$dta
		jmps	dont$write1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

_write:					; CODE XREF: cpm_writerec+E9j
		call	setdata
		call	seek
		call	discard$databcb	; Release the BCB for bcb_drive, record	bcb_record
		mov	cl, blk$off
		call	lru_free

		mov	cl, deblock_flag
		cmp	blk$off, 0
		jz	write00
		mov	cl, 0

write00:				; CODE XREF: cpm_writerec+10Bj
		call	wrbuff
		jmps	dont$write1
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dont$write:				; CODE XREF: cpm_writerec+E7j

		call	discard$databcb

;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

dont$write1:				; CODE XREF: cpm_writerec+F0j
					; cpm_writerec+112j ...
		mov	al, vrecord
		mov	bx, offset rcount
		cmp	al, [bx]
		jb	diskwr2
		mov	[bx], al
		inc	byte ptr [bx]	; rcount = vrecord + 1
		mov	deblock_flag, 2	; Mark as record count incremented

diskwr2:				; CODE XREF: cpm_writerec+11Fj
		cmp	deblock_flag, 2
		jnz	noupdate
		and	user_fcb+0Eh, 7Fh; Reset FWF

noupdate:				; CODE XREF: cpm_writerec+12Fj
		call	getmodnum
		and	al, 40h
		jnz	diskwrite3
		or	byte ptr [bx], 40h; Set	file write flag
		and	user_fcb+0Eh, 7Fh

diskwrite3:				; CODE XREF: cpm_writerec+13Bj
		jmp	setfcb		; Place	values back into current FCB



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Convert a size (extent + record no)
; to a 3-byte record number.

extent_size:		; CODE XREF: F_SIZE+1Fp F_RANDREC+6p
					; ...
		xchg	bx, dx
		add	bx, dx
		mov	cl, [bx]
		xor	ch, ch
		mov	bx, dx
		mov	ah, 12[bx]
		shr	ax, 1
		and	ax, 0F80h
		add	cx, ax
		mov	al, 14[bx]
		and	al, 3Fh
		mov	ah, 10h
		mul	ah
		add	ch, al
		mov	al, 0
		adc	al, ah

login_fail:				; CODE XREF: compare_recno+6j
					; drive_login+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

compare_recno:		; CODE XREF: F_SIZE+22p F_TRUNCATE+34p
		mov	bx, offset user_fcb+21h
		cmp	al, 2[bx]
		jnz	login_fail
		cmp	cx, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

drive_login:		; CODE XREF: disk$select1+Bp
		mov	cl, al
		mov	al, 9		; SELDSK
		call	fs_call_xios
		or	bx, bx
		jz	drv_login_ret
		inc	bx
		inc	bx
		mov	cdrmaxa, bx
		inc	bx
		inc	bx
		mov	lsn$add, bx
		add	bx, 4
		mov	si, bx
		mov	di, offset dph_dpb
		mov	cx, 0Ch
		rep movsb
		mov	si, dph_dpb
		mov	di, offset dpb_spt
		mov	cx, 11h
		rep movsb
		mov	cl, dpb_psh
		shl	dpb_spt, cl
		mov	al, byte ptr dpb_dsm+1
		or	al, al
		jz	fewer256blocks
		mov	al, 1

fewer256blocks:				; CODE XREF: drive_login+7Ej
		dec	al
		mov	single,	al	; Nonzero if using 8-bit blocks
		stc	

drv_login_ret:				; CODE XREF: drive_login+57j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл
;		S u b r	o u t i	n e

disk$select:		; CODE XREF: curselect+9p reselect+6Cp
		mov	bcb_drive, al



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

disk$select1:		; CODE XREF: deblock+EFp
		mov	curdsk,	al
		mov	dx, login_vector
		call	test$vector	; Return bit curdsk of vector DX
		push	dx
		call	drive_login
		pop	bx
		jnb	j_sel$error
		dec	bl
		retn	

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

tmpselect:		; CODE XREF: DRV_SETp DRV_RESET+18p
					; ...
		mov	fs_fcbdrive, dl


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

curselect:		; CODE XREF: tst$relog+Ap drv$relogp
					; ...
		mov	al, fs_fcbdrive
		cmp	al, curdsk
		jnz	doselect
		inc	al
		jz	j_sel$error
noselect:	ret
;
doselect:	cmp	al, 10h
		jc	curselect1b
j_sel$error:	jmp	sel$error
;
curselect1b:	call	disk$select
		jz	noselect
		call	cpm_login
		mov	bx, offset login_vector
		call	set$cdisk
		mov	al, byte ptr dpb_cks+1
		rcl	al, 1
		jc	curselect03
		mov	bx, offset removable_drive
		call	set$cdisk

curselect03:				; CODE XREF: curselect+35j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sel1_fcb_drive:		; CODE XREF: F_SFIRST+20p F_MAKE+Bp
					; ...
		xor	al, al
		mov	high$ext, al
		mov	xfcb_rdonly, al
		jmps	sel_fcb_drive



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

reselect:		; CODE XREF: F_do_call+24p
		mov	cx, 807Fh
		mov	bx, offset user_fcb+7
		mov	al, [bx]
		and	al, ch
		mov	xfcb_rdonly, al
		and	[bx], cl
		inc	bx
		mov	al, [bx]
		and	al, cl
		cmp	al, [bx]
		mov	[bx], al
		mov	al, 60h		; If F8' was set, assume top 3 bits
					; of EX	are 011
		jnz	got_exflags
		mov	al, 4[bx]
		and	al, 0E0h	; Top 3	bits of	EX

got_exflags:				; CODE XREF: reselect+1Aj
		mov	high$ext, al
		call	clr$ext

sel_fcb_drive:				; CODE XREF: sel1_fcb_drive+8j
		mov	set_if_attrs, 0FFh
		mov	al, user_fcb
		mov	fcbdsk,	al
		and	al, 1Fh
		dec	al
		cmp	al, 0FFh
		jz	_noselect
		mov	fs_fcbdrive, al

_noselect:				; CODE XREF: reselect+38j
		call	curselect
		mov	al, usrcode
		mov	user_fcb, al

noselect0:				; CODE XREF: F_SFIRST+19p
		call	tst$log$fxs
		jnz	dont_discard
		mov	dir_check_flag,	0F0h

dont_discard:				; CODE XREF: reselect+49j
		call	check$media
		xor	al, al
		xchg	al, xios_bh_gdopen
		test	al, al
		jz	no_media_flag
		mov	bx, login_vector
		mov	al, 10h

chk$am1:				; CODE XREF: reselect+92j
		dec	al
		shl	bx, 1
		jnb	chk$am2
		push	ax
		push	bx
		call	disk$select
		mov	bx, dph_dtabcb
		mov	bx, [bx]

reselect2:				; CODE XREF: reselect+89j
		or	bx, bx
		jz	reselect5
		test	byte ptr 4[bx], 0FFh
		jnz	reselect4
		mov	bx, 12[bx]
		jmps	reselect2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

reselect4:				; CODE XREF: reselect+84j
		call	check$media

reselect5:				; CODE XREF: reselect+77j
		pop	bx
		pop	ax

chk$am2:				; CODE XREF: reselect+68j
		or	al, al
		jnz	chk$am1
		jmp	curselect



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

check$media:		; CODE XREF: reselect+50p reselect+8Bp
					; ...
		mov	bx, lsn$add
		xor	al, al
		xchg	al, 1[bx]
		or	al, al
		jz	no_media_flag
		call	discard$dir	; Release all directory	BCBs for a drive
		call	set$end$dir
		push	dcnt

check$media1:				; CODE XREF: check$media+43j
		mov	cl, 0
		call	r$dir
		xor	al, al
		xchg	al, relog
		test	al, al
		jz	check$media2
		cmp	fs_function, 1Ah
		jz	check$media$end
		mov	al, bcb_drive
		cmp	al, fs_fcbdrive
		jnz	check$media$end
		pop	dcnt
		call	drv$relog
		jmp	chk$exit$fxs
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

check$media2:				; CODE XREF: check$media+24j
		call	compcdr
		jb	check$media1

check$media$end:			; CODE XREF: check$media+2Bj
					; check$media+34j
		pop	dcnt

no_media_flag:				; CODE XREF: check$media+Bj
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copy8fromdma:		; CODE XREF: F_OPENp F_DELETEp
					; ...
		mov	cl, 8



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

copyfromdma:		; CODE XREF: F_MAKE+2p	DRV_SETLABEL+2p
					; ...
		mov	si, userdma
		mov	di, offset passwd_buf
		push	ds
		mov	ds, userdmaseg
		xor	ch, ch
		rep movsb
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$dir$mode:		; CODE XREF: cpm_delete+20p
					; cpm_delete+31p ...
		mov	bx, lsn$add
		mov	al, [bx]
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$xfcb:		; CODE XREF: chk$pw$error+46p
					; chk$pw$error+75p ...
		mov	bx, offset user_fcb
		mov	al, [bx]
		push	ax
		or	byte ptr [bx], 10h
		call	search$extnum	; Find any extent of a file
		pop	ax
		mov	user_fcb, al
		mov	byte ptr aret, 0
		jnz	get$xfcb1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$xfcb1:		; CODE XREF: get$xfcb+15j chk_xfcb_passwdp
					; ...
		call	getdptra
		mov	dx, bx
		add	bx, 0Ch
		mov	al, [bx]
		and	al, 0E0h
		or	al, 1
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init$xfcb:		; CODE XREF: F_MAKE+B1p DRV_SETLABEL+46p
					; ...
		call	setcdr
		mov	cx, 1014h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

init$xfcb0:		; CODE XREF: DRV_SETLABEL+65p
		push	cx
		call	getdptra
		mov	si, offset user_fcb
		lodsb
		or	al, ch
		mov	[bx], al
		inc	bx
		mov	cl, 0Bh
		mov	dx, si
		call	move		; Copy CL bytes	from DX	to BX
		mov	dx, si
		mov	bx, di
		pop	cx
		sub	ch, ch
		xor	al, al
		rep stosb
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$pw$error:		; CODE XREF: cpm_delete+3Dp
					; openx+71p ...
		mov	byte ptr xdcnt+1, 0; Disable special searches
		mov	si, offset user_fcb
		mov	di, offset passwd_fcb
		mov	cx, 10h
		rep movsb
		call	getdptra	; Find XFCB with ext=0 S2=0
		mov	si, bx
		inc	si
		mov	di, offset user_fcb+1
		mov	cx, 0Bh		; Copy name.type
		rep movsb
		xor	al, al
		stosb			; Blank	EX
		inc	di
		stosb			; Blank	S2
		lodsb			; Password mode
		mov	pw$mode, al	; Password mode
		call	search$namlen	; Find a numbered extent
		jz	chk$pwe2
		call	get$dtba$8	; Does SFCB exist for FCB?
		or	al, al
		jnz	chk$pwe1
		mov	si, offset pw$mode; Password mode
		mov	ch, [si]
		mov	al, [bx]
		mov	[si], al
		or	al, al		; Is SFCB password mode	nonzero?
		jz	chk$pwe2	; No
		xor	al, ch		; Does XFCB mode match SFCB?
		and	al, 0E0h
		jz	chk$pwe1
		call	get$xfcb	; Update XFCB to match SFCB
		jz	chk$pwe1
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		call	nowrite		; Return true if drive is software R/O
		jnz	chk$pwe1
		call	seek$copy

chk$pwe1:				; CODE XREF: chk$pw$error+31j
					; chk$pw$error+44j ...
		call	restore$pw$fcb
		mov	al, fs_function
		cmp	al, 2		; F_OPEN
		jz	chk_pwe_ret
		cmp	al, 9		; F_MAKE
		jz	chk_pwe_ret

pw$error:				; CODE XREF: openx+7Fj	F_MAKE+6Ej
					; ...
		mov	ah, 7
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

chk$pwe2:				; CODE XREF: chk$pw$error+2Aj
					; chk$pw$error+3Ej
		mov	pw$mode, 0	; Password mode
		call	nowrite		; Return true if drive is software R/O
		jnz	restore$pw$fcb
		call	get$xfcb	; Delete XFCB
		jz	restore$pw$fcb
		or	user_fcb, 10h
		call	delete11



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

restore$pw$fcb:		; CODE XREF: chk$pw$error+58p
					; chk$pw$error+73j ...
		mov	si, offset passwd_fcb
		mov	di, offset user_fcb
		mov	cx, 10h
		rep movsb

chk_pwe_ret:				; CODE XREF: chk$pw$error+60j
					; chk$pw$error+64j ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk$password:		; CODE XREF: bdos:479Dp F_ATTRIB+13p
					; ...
		call	get$dir$mode
		and	al, 80h
		jz	chk_pwe_ret
		call	get$xfcb
		jz	chk_pwe_ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Compare password

cmp$pw:		; CODE XREF: chk_xfcb_passwd+4p
					; openx+6Cp
		inc	bx
		mov	ch, [bx]
		or	ch, ch
		jnz	cmp$pw2
		mov	si, bx
		add	si, 3
		mov	cl, 9

cmp$pw1:				; CODE XREF: cmp$pw+15j cmp$pw+19j
		lodsb
		dec	cl
		jz	chk_pwe_ret
		or	al, al
		jz	cmp$pw1
		cmp	al, 20h
		jz	cmp$pw1

cmp$pw2:				; CODE XREF: cmp$pw+5j
		lea	si, 10[bx]
		lea	dx, 3[bx]
		mov	bx, offset passwd_buf
		mov	cl, 8
		std	

cmp$pw3:				; CODE XREF: cmp$pw+31j
		lodsb
		xor	al, ch
		cmp	al, [bx]
		jnz	cmp$pw5
		inc	bx
		dec	cl
		jnz	cmp$pw3
		cld	
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cmp$pw5:				; CODE XREF: cmp$pw+2Cj
		cld	
		mov	bx, offset df$password;	Default	password
		mov	cl, 8
		jmp	compare		; Compare CL bytes at DX and BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

chk_xfcb_passwd:		; CODE XREF: cpm_delete+38p
					; DRV_SETLABEL+5Bp ...
		call	get$xfcb1

chk_xfcb_passw1:			; CODE XREF: F_MAKE+5Fp
		push	bx
		call	cmp$pw		; Compare password
		pop	bx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set$pw:		; CODE XREF: F_MAKE+CEp sdl2+9p
		mov	cx, 8
		lea	di, 11[bx]

set$pw0:				; CODE XREF: F_PASSWD+15j
		sub	ah, ah

set$pw1:				; CODE XREF: set$pw+1Aj
		lodsb
		mov	[di], al
		or	al, al
		jz	set$pw2
		cmp	al, 20h
		jz	set$pw2
		inc	ah

set$pw2:				; CODE XREF: set$pw+Dj	set$pw+11j
		add	ch, al
		dec	di
		dec	cl
		jnz	set$pw1
		or	ah, ch
		jnz	set$pw3
		mov	[bx], ah

set$pw3:				; CODE XREF: set$pw+1Ej
		inc	di
		mov	cl, 8

set$pw4:				; CODE XREF: set$pw+2Aj
		xor	[di], ch
		inc	di
		dec	cl
		jnz	set$pw4
		mov	1[bx],	ch
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

get$dtba$8:		; CODE XREF: delete11+14p chk$pw$error+2Cp
					; ...
		mov	ch, 8

get$dtba:				; CODE XREF: make+47p stamp2+2p
					; ...
		mov	al, 3
		mov	ah, byte ptr dcnt
		and	ah, 3
		cmp	al, ah
		jz	get$dtba$ret
		mov	bx, buffa
		add	bx, 60h
		mov	al, [bx]
		sub	al, 21h
		jnz	get$dtba$ret
		mov	al, ah
		mov	cl, 0Ah
		mul	cl
		inc	al
		add	al, ch
		add	bx, ax
		xor	al, al

get$dtba$ret:				; CODE XREF: get$dtba$8+Dj
					; get$dtba$8+1Aj ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qdirfcb1:		; CODE XREF: qstampp openx+31p
					; ...
		mov	bx, offset user_fcb+0Ch
		mov	al, [bx]
		mov	ah, dpb_exm
		not	ah
		and	al, ah
		and	al, 1Fh
		jnz	get$dtba$ret
		test	byte ptr 2[bx], 3Fh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qstamp:		; CODE XREF: openx2p F_MAKE+EFp
					; ...
		call	qdirfcb1
		jnz	get$dtba$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

qstamp1:		; CODE XREF: update$stamp+2p
		call	get$dir$mode
		and	al, cl
		jz	qstamp1a
		jmp	nowrite		; Return true if drive is software R/O
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

qstamp1a:				; CODE XREF: qstamp1+5j
		inc	al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp1:		; CODE XREF: openx2+5j	DRV_SETLABEL+4Fp
		mov	ch, 0
		jmps	stamp3



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp2:		; CODE XREF: update$stamp+1Bp
					; F_MAKE+F4p ...
		mov	ch, 4

stamp3:					; CODE XREF: stamp1+2j
		call	get$dtba
		or	al, al
		jnz	get$dtba$ret

stamp_cmpdate:				; CODE XREF: stamp5+9j
		mov	dx, offset date_days

stamp_compare:				; CODE XREF: F_BDOS_74+3Bp
					; F_BDOS_74+51p
		mov	cl, 4
		push	bx
		push	dx
		call	compare		; Compare CL bytes at DX and BX
		pop	dx
		pop	bx
		jz	get$dtba$ret
		mov	cl, 4
		call	move		; Copy CL bytes	from DX	to BX
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

stamp5:		; CODE XREF: DRV_SETLABEL+4Cp
					; DRV_SETLABEL+55p
		call	getdptra
		add	bx, cx
		mov	ax, offset F_nop
		push	ax
		jmps	stamp_cmpdate



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

update$stamp:		; CODE XREF: cpm_writerec+2Ap
					; F_TRUNCATE+8Ap
		mov	cl, 20h		; Is update stamping requested?
		call	qstamp1
		jnz	get$dtba$ret
		test	user_fcb+0Eh, 40h; Has file been written to?
		jnz	get$dtba$ret
		mov	ah, user_fcb+0Ch; Save EX and S2
		mov	al, user_fcb+0Eh
		push	ax
		call	find_extent_0	; Find the SFCB
		jz	no_stamp2
		call	stamp2

no_stamp2:				; CODE XREF: update$stamp+19j
		mov	byte ptr aret, 0
		pop	ax
		mov	user_fcb+0Ch, ah
		mov	user_fcb+0Eh, al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e
; Return bitmap	of all drives in use by	processes

get_drvs_in_use:		; CODE XREF: not_drv_loggedp
					; DRV_RESETp
		xor	ax, ax
		push	es
		mov	es, bdos_conowner


gdiu_0:					; CODE XREF: get_drvs_in_use+1Dj
		cmp	es:proc_status,	2; 0 =>	Runnable
					; 1 => waiting on timer
					; 2 => terminated
					; 3 => waiting on flag
		jz	gdiu_1
		or	ax, es:proc_using_drvs

gdiu_1:					; CODE XREF: get_drvs_in_use+Dj
		mov	cx, es:proc_nextseg
		mov	es, cx
		or	cx, cx
		jnz	gdiu_0
		pop	es
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

not_drv_logged:		; CODE XREF: DRV_FLUSH+2Cp
					; DRV_FLUSH+63p
		call	get_drvs_in_use	; Return bitmap	of all drives in use by	processes
		not	ax
		mov	dx, ax
		jmp	test$vector	; Return bit curdsk of vector DX


;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_ALLRESET:		; DATA XREF: bdos:256Eo
		mov	ax, 0FFFFh
		mov	fs_param_low, ax
		call	DRV_RESET
		xor	al, al		; A: is	the default
		call	set_proc_drive
		dec	al		; But no drive is logged in
		mov	curdsk,	al
		push	ds
		mov	ds, rlr

		mov	word ptr proc_dma, 80h
		pop	ds

		jmp	DRV_FLUSH



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SET:		; DATA XREF: bdos:2571o
		call	tmpselect
		mov	al, fs_fcbdrive



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

set_proc_drive:		; CODE XREF: DRV_ALLRESET+Bp
		push	ds
		mov	ds, rlr

		mov	proc_drive, al
		pop	ds


spd_ret:				; CODE XREF: F_OPEN+20j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_OPEN:		; DATA XREF: bdos:2574o
		call	copy8fromdma	; Get password
		call	clrmodnum	; Clear	S2 byte	of FCB
		call	check$wild
		cmp	usrcode, 0
		jz	call$open
		mov	al, 0FEh
		mov	byte ptr xdcnt+1, al
		inc	al
		mov	search$user0, al

call$open:				; CODE XREF: F_OPEN+31j
		call	open
		call	openx
		xor	al, al
		xchg	al, search$user0
		test	al, al
		jnz	callopen_noret

callopen_ret:				; CODE XREF: F_OPEN+53j openx+3j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

callopen_noret:				; CODE XREF: F_OPEN+4Bj
		cmp	byte ptr xdcnt+1, 0FEh
		jz	callopen_ret
		call	set_dcnt_dblk
		mov	high$ext, 60h
		xor	al, al		; Try to open in user 0
		mov	user_fcb, al
		mov	cl, 0Fh
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		call	open1
		call	openx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

openx:		; CODE XREF: F_OPEN+40p F_OPEN+6Dp
		call	end$of$dir
		jz	callopen_ret
		mov	bx, offset user_fcb+20h
		cmp	byte ptr [bx], 0FFh
		jnz	openxa
		mov	al, user_fcb+0Dh
		mov	[bx], al

openxa:					; CODE XREF: openx+Bj
		pop	bx		; Open successful. Discard return address
		mov	al, high$ext
		cmp	al, 60h
		jnz	openx0
		mov	al, user_fcb+0Ah; System file?
		and	al, 80h
		jnz	openx0		; Yes -	open successful
		mov	high$ext, al
		jmp	lret$eq$ff	; Open fails
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0:					; CODE XREF: openx+18j	openx+1Fj
		call	set$lsn
		call	get$dir$mode	; Are passwords	enabled	on drive?
		test	al, 80h
		jz	openx1a
		call	qdirfcb1	; Is this the first dir	fcb?
		jnz	openx0a
		call	get$dtba$8	; Does SFCB exist?
		or	al, al
		jnz	openx0a
		test	byte ptr [bx], 0C0h; Password read/write?
		jz	openx1a
		call	xdcnt_eq_dcnt	; Does XFCB exist?
		call	get$xfcb
		jnz	openx0b
		call	restore_dir_fcb
		jz	openxret
		call	get$dtba
		or	al, al
		jnz	openx1a
		mov	[bx], al
		call	nowrite		; Return true if drive is software R/O
		jnz	openx1a
		call	seek$copy
		jmps	openx1a
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0a:				; CODE XREF: openx+34j	openx+3Bj
		call	xdcnt_eq_dcnt
		call	get$xfcb
		and	al, 0C0h
		jz	openx1

openx0b:				; CODE XREF: openx+48j
		call	cmp$pw		; Compare password
		jz	openx1
		call	chk$pw$error
		mov	al, pw$mode	; Password mode
		and	al, 0C0h
		jz	openx1
		test	al, 80h
		jz	openx0c
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx0c:				; CODE XREF: openx+7Dj
		mov	xfcb_rdonly, 80h; Can only open	read-only

openx1:					; CODE XREF: openx+6Aj	openx+6Fj
					; ...
		call	restore_dir_fcb
		jnz	openx1a

openxret:				; CODE XREF: openx+4Dj
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

openx1a:				; CODE XREF: openx+2Fj	openx+40j
					; ...
		mov	open_unknown, 0FFh
		mov	cl, 40h



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

openx2:		; CODE XREF: F_MAKE+EAp
		call	qstamp
		jnz	openx2_ret
		jmp	stamp1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_CLOSE:		; DATA XREF: bdos:2577o
		call	set$lsn
		call	chek$fcb
		call	close
		cmp	byte ptr aret, 0FFh
		jnz	f_close_flush

openx2_ret:				; CODE XREF: openx2+3j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

f_close_flush:				; CODE XREF: F_CLOSE+37j
		call	call_xios_flush

f_close_end:				; CODE XREF: fat_close+50j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_SFIRST:		; DATA XREF: bdos:257Ao
		mov	ax, fs_param_ds
		mov	word ptr sys_find1st+2,	ax
		mov	ax, fs_param_low
		mov	word ptr sys_find1st, ax
		xor	al, al

csearch:				; CODE XREF: bdos:464Aj
		pushf	
		cmp	user_fcb, '?'   ; If drive byte is '?', search
					; the default drive.
		jnz	csearch1
		call	curselect
		call	noselect0
		xor	cl, cl
		jmps	csearch3
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

csearch1:				; CODE XREF: F_SFIRST+14j
		call	sel1_fcb_drive
		mov	cl, 0Ch
		mov	bx, offset user_fcb+0Ch
		cmp	byte ptr [bx], 3Fh
		jz	csearch3
		call	clr$ext
		call	clrmodnum	; Clear	S2 byte	of FCB
		mov	cl, 0Fh

csearch3:
		popf
		pushf
		jz	csearch4
		mov	ax, dcnt
		mov	bx, ax
		and	al, 3
		cmp	al, 3
		jz	csearch4
		mov	ax, bx
		push	ax
		and	al, 0FCh
		mov	dcnt, ax
		call	rd$dir
		pop	dcnt
csearch4:
		popf
		jnz	srch_1
		call	search
		jmps	srch_found
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

srch_1:					; CODE XREF: F_SFIRST+48j
		mov	cl, searchl
		call	searchi
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search

srch_found:				; CODE XREF: F_SFIRST+4Dj
		cmp	byte ptr aret, 0FFh
		jz	srch_ret
		mov	ax, dcnt
		and	al, 3
		mov	byte ptr aret, al
		mov	dx, buffa
		mov	bx, userdma
		mov	cl, 80h
		push	es
		mov	es, userdmaseg
		call	move		; Copy CL bytes	from DX	to BX
		pop	es

srch_ret:				; CODE XREF: F_SFIRST+5Ej bdos:4620j
		retn	


;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

F_SNEXT:				; DATA XREF: bdos:257Do
		mov	ax, word ptr sys_find1st+2
		or	ax, word ptr sys_find1st
		jz	srch_ret
		mov	ax, word ptr sys_find1st+2
		mov	fs_param_ds, ax
		mov	ax, word ptr sys_find1st
		mov	fs_param_low, ax
		call	copy_fcb_33
		mov	searcha, offset	user_fcb
		or	al, 1
		jmp	csearch

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_DELETE:		; DATA XREF: bdos:2580o
		call	copy8fromdma
		jmp	cpm_delete



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_READ:		; DATA XREF: bdos:2583o
		call	check_changed
		jmp	cpm_readrec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITE:		; DATA XREF: bdos:2586o
		call	check_changed
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_MAKE:		; DATA XREF: bdos:2589o
		mov	cl, 9
		call	copyfromdma	; New password & mode
		call	get$atts
		call	clr$ext
		call	clrmodnum	; Clear	S2 byte	of FCB
		call	sel1_fcb_drive
		mov	dl, 1
		call	valid_dl_f_fcb
		mov	xdcnt, 0FFFFh
		call	open
		call	end$of$dir
		jz	makea0
		call	get$dir$ext	; Compute directory extent from	FCB
		cmp	al, [bx]
		jb	makea0
		mov	ah, 8
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makea0:					; CODE XREF: F_MAKE+3Aj F_MAKE+41j
		pushf	
		call	qdirfcb1
		jz	makex04
		call	get$dir$mode
		and	al, 80h
		jz	makex04
		call	get$xfcb
		and	al, 0C0h
		jz	makex04
		call	chk_xfcb_passw1
		jz	makex04
		call	chk$pw$error
		test	pw$mode, 0C0h	; Password mode
		jz	makex04
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makex04:				; CODE XREF: F_MAKE+4Fj F_MAKE+56j
					; ...
		popf
		jb	makex05
		call	make

makex05:				; CODE XREF: F_MAKE+75j
		call	end$of$dir
		jnz	makex06

f_make_ret:				; CODE XREF: F_MAKE+D7j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

makex06:				; CODE XREF: F_MAKE+7Dj
		call	set$lsn
		call	get$dir$mode
		test	al, 80h
		jz	make3a
		test	attributes, 40h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	make3a
		call	qdirfcb1
		jnz	make3a
		call	xdcnt_eq_dcnt
		call	get$xfcb
		jnz	make00
		mov	make$xfcb, 0FFh
		call	make
		jnz	make00
		call	search$namlen	; Find a numbered extent
		call	delete10
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

make00:					; CODE XREF: F_MAKE+9Cj F_MAKE+A6j
		call	init$xfcb
		mov	si, offset passwd_buf
		add	si, 8
		lodsb
		and	al, 0E0h
		jnz	make2
		mov	al, 80h

make2:					; CODE XREF: F_MAKE+BDj
		mov	pw$mode, al	; Password mode
		push	ax
		call	get$xfcb1
		pop	ax
		mov	[bx], al
		mov	si, offset passwd_buf
		call	set$pw
		call	sdl3
		call	restore_dir_fcb
		jz	f_make_ret
		call	get$dtba$8
		or	al, al
		jnz	make3a
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		call	seek$copy

make3a:					; CODE XREF: F_MAKE+88j F_MAKE+8Fj
					; ...
		mov	cl, 50h
		call	openx2
		mov	cl, 20h
		call	qstamp
		jnz	f_make_ret2
		call	stamp2
		or	user_fcb+0Eh, 40h

f_make_ret2:				; CODE XREF: F_MAKE+F2j
		retn	



;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

F_RENAME:				; DATA XREF: bdos:258Co
		call	copy8fromdma
		call	check$wild
		call	chk$password
		jz	cpm_rename1
		call	chk$pw$error

cpm_rename1:				; CODE XREF: bdos:47A0j
		call	init_xfcb_srch
		call	copy$user$no
		mov	searcha, bx
		mov	dl, 1
		call	check$wild0
		mov	ah, 9
		jz	ren_wildcarderr
		mov	cl, 0Ch
		call	searchi1
		call	search1
		jz	cpm_rename2
		mov	ah, 8		; File exists

ren_wildcarderr:			; CODE XREF: bdos:47B6j
		mov	cur_fcb_len, 0
		add	fs_param_low, 10h
		jmp	disk_error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename2:				; CODE XREF: bdos:47C0j
		call	does$xfcb$exist
		jz	cpm_rename3	; If XFCB exists for new name, delete it
		call	delete11

cpm_rename3:				; CODE XREF: bdos:47D4j
		call	copy$user$no
		call	init_xfcb_srch
		call	search$extnum	; Find any extent of a file
		jnz	cpm_rename4
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename4:				; CODE XREF: bdos:47E2j
		call	check$rodir

rename0:				; CODE XREF: bdos:47F5j bdos:4802j
		mov	cl, 10h		; Not end of dir, rename next element
		mov	dl, 0Ch
		call	copy$dir	; Copy FCB information starting	at CL for DL bytes
					; into the currently addressed directory entry
		call	fix$hash
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	rename0
		call	does$xfcb$exist
		jnz	cpm_rename_5
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_rename_5:				; CODE XREF: bdos:47FAj
		call	copy$user$no
		jmps	rename0

;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_ALLOCVEC:		; DATA XREF: bdos:258Fo
		call	curselect
		mov	f_ret_es, ds
		mov	bx, dph_alv
		jmps	f_ret_bx



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SETRO:		; DATA XREF: bdos:2592o
		mov	bx, offset readonly_vector
		mov	cl, fs_fcbdrive
		call	set$cdisk1
		mov	dx, dpb_drm
		inc	dx
		mov	bx, cdrmaxa
		mov	[bx], dx
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_ATTRIB:		; DATA XREF: bdos:2595o
		call	copy8fromdma
		call	check$wild
		call	sel1_fcb_drive
		call	chk$password
		jz	f_attrib_cpm1
		call	chk$pw$error

f_attrib_cpm1:				; CODE XREF: F_ATTRIB+16j
		call	get$atts
		call	search$extnum	; Find any extent of a file
		jz	rdrand_ret

f_attrib_cpm2:				; CODE XREF: F_ATTRIB+40j
		mov	cl, 0
		mov	dl, 0Ch
		call	copy$dir2
		call	move		; Copy CL bytes	from DX	to BX
		test	attributes, 40h	; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		jz	no_bytesize
		mov	al, user_fcb+20h
		mov	13[bx], al

no_bytesize:				; CODE XREF: F_ATTRIB+32j
		call	seek$copy
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	f_attrib_cpm2
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

DRV_DPB:				; DATA XREF: bdos:2598o
		call	curselect
		mov	f_ret_es, ds
		mov	bx, dph_dpb

f_ret_bx:				; CODE XREF: DRV_ALLOCVEC+Bj
		mov	aret, bx

rdrand_ret:				; CODE XREF: F_ATTRIB+21j F_READRAND+14j
					; ...
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_READRAND:		; DATA XREF: bdos:259Bo
		call	check_changed
		mov	cl, 0FFh
		call	cpm_rwrand	; CL=-1	read  0	write
		jnz	rdrand_ret
		jmp	cpm_readrec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITERAND:		; DATA XREF: bdos:259Eo
		call	check_changed
		mov	cl, 0
		call	cpm_rwrand	; CL=-1	read  0	write
		jnz	rdrand_ret
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_SIZE:		; DATA XREF: bdos:25A1o
		mov	bx, offset user_fcb+21h
		xor	ax, ax
		mov	[bx], ax
		mov	2[bx],	al
		call	search$extnum	; Find any extent of a file
		jz	cpm_size_notfnd

cpm_size_loop:				; CODE XREF: F_SIZE+34j
		call	getdptra
		mov	dx, 0Fh
		call	extent_size	; Take the largest value of the	
					; file sizes given by the various 
					; extents
		call	compare_recno
		jb	cpm_size_next
		mov	2[bx],	al
		mov	[bx], cx

cpm_size_next:				; CODE XREF: F_SIZE+25j
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		mov	byte ptr aret, 0
		jnz	cpm_size_loop

cpm_size_notfnd:			; CODE XREF: F_SIZE+17j
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_RANDREC:		; DATA XREF: bdos:25A4o
		mov	bx, offset user_fcb
		mov	dx, 20h
		call	extent_size	; Convert a size (extent + record no)
					; to a 3-byte record number.
		mov	21h[bx], cx
		mov	23h[bx], al
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_RESET:		; CODE XREF: DRV_ALLRESET+6p
					; DATA XREF: bdos:25A7o
		call	get_drvs_in_use	; Return bitmap	of all drives in use by	processes
		push	ax
		and	ax, fs_param_low
		jz	reset_none
		and	ax, removable_drive
		mov	dl, 10h

reset_loops:				; CODE XREF: DRV_RESET+2Cj
		dec	dl
		shl	ax, 1
		jnb	reset_next
		push	ax
		push	dx
		call	tmpselect
		mov	bx, lsn$add
		mov	byte ptr 1[bx], 0FFh
		mov	xios_bh_gdopen,	0FFh
		pop	dx
		pop	ax

reset_next:				; CODE XREF: DRV_RESET+14j
		or	ax, ax
		jnz	reset_loops

reset_none:				; CODE XREF: DRV_RESET+8j
		pop	ax
		not	ax
		and	ax, fs_param_low

reset37x:				; CODE XREF: media$change+15j
		not	ax
		and	login_vector, ax
		and	readonly_vector, ax
		and	removable_drive, ax
		mov	curdsk,	0FFh
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITEZF:		; DATA XREF: bdos:25B0o
		call	check_changed
		mov	cl, 0
		call	cpm_rwrand	; CL=-1	read  0	write
		jz	j_fat_wrrec2
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

j_fat_wrrec2:				; CODE XREF: F_WRITEZF+14j
		jmp	cpm_writerec



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SPACE:		; DATA XREF: bdos:25B9o
		call	tmpselect
		mov	si, dph_alv
		call	get$nalbs	; Return ALV size in bytes
		xor	cx, cx

cpm_space_loop:				; CODE XREF: DRV_SPACE+23j
		lodsb

cpm_space_ctbit:			; CODE XREF: DRV_SPACE+20j
		or	al, al
		jz	cpm_space_next

cpm_space_ckbit:			; CODE XREF: DRV_SPACE+1Dj
		shr	al, 1
		jnb	cpm_space_ckbit
		inc	cx
		jmps	cpm_space_ctbit
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_space_next:				; CODE XREF: DRV_SPACE+19j
		dec	bx
		jnz	cpm_space_loop	; CX = count of	used blocks
		mov	bx, dpb_dsm
		inc	bx
		sub	bx, cx		; BX = count of	free blocks
		mov	cl, dpb_bsh
		xor	ch, ch
		mov	al, bh
		xor	ah, ah
		shl	bx, cl		; Convert to records
		shl	ax, cl
		mov	di, userdma
		push	ds
		mov	ds, userdmaseg
		mov	[di], bx
		mov	2[di],	ah
		pop	ds
		retn	



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_FLUSH:		; CODE XREF: DRV_ALLRESET+1Fj
					; DATA XREF: bdos:25BCo
		cmp	fs_function, 15h
		jz	flush0		; Function 98 entry point
		mov	al, 0Ch		; XIOS flush
		call	fs_call_xios
		call	diocomp

flush0:					; CODE XREF: DRV_FLUSH+5j
					; DATA XREF: bdos:25BFo ...
		mov	bx, login_vector; Function 98 entry point
		mov	dl, 10h

flush1:					; CODE XREF: DRV_FLUSH+1Dj
		dec	dl
		shl	bx, 1
		jnc	flush5
		push	bx
		push	dx
		call	tmpselect
		cmp	fs_function, 1Bh; Flush	or reset allocation?
		jnz	flush_not3
		call	not_drv_logged
		jz	ptsync_drvfail
		call	copy$alv
		jmps	flush4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

ptsync_drvfail:				; CODE XREF: DRV_FLUSH+2Fj
		mov	byte ptr aret, 0FFh
		jmps	flush4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flush_not3:				; CODE XREF: DRV_FLUSH+2Aj
		cmp	fs_function, 15h
		jz	flush34a
		cmp	fs_function, 23h
		jz	flush34
		call	flushx
		cmp	linfo, 0FFh	; Discard buffers?
		jnz	flush4
		jmps	flush35
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flush34:				; CODE XREF: DRV_FLUSH+49j
		push	ds
		mov	ds, rlr

		mov	proc_using_drvs, 0
		pop	ds

		call	not_drv_logged
		jz	flush34a
		call	copy$alv
flush34a:	mov	bx, dph_dirbcb
		call	proc$discard

flush35:				; CODE XREF: DRV_FLUSH+42j
					; DRV_FLUSH+55j ...
		mov	bx, dph_dtabcb
		call	proc$discard	; Free BCBs on bcb_drive used by current process

flush4:					; CODE XREF: DRV_FLUSH+34j
					; DRV_FLUSH+3Bj ...
		pop	dx
		pop	bx
flush5:		or	bx, bx
		jnz	flush1
		ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

call_xios_flush:		; CODE XREF: F_CLOSE+3Ap fat_close+43p
		mov	al, 0Ch
		call	fs_call_xios
		call	diocomp



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

flushx:		; CODE XREF: check$nprs+100p
					; DRV_FLUSH+4Bp ...
		test	dpb_phm, 0FFh
		jnz	flushx1

flushxret:				; CODE XREF: trunc_save_dcnt+5j
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

flushx1:				; CODE XREF: flushx+5j
		mov	ah, 4
		jmp	deblock$dta



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

trunc_save_dcnt:		; CODE XREF: F_TRUNCATE+68p
					; F_TRUNCATE+90p
		cmp	byte ptr xdcnt+1, 0FDh
		jnz	flushxret
		jmp	save$dcnt$pos0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_TRUNCATE:		; DATA XREF: bdos:25C2o
		call	copy8fromdma
		call	sel1_fcb_drive
		call	check$wild
		call	chk$password
		jz	cpm_truncate0
		call	chk$pw$error

cpm_truncate0:				; CODE XREF: F_TRUNCATE+16j
		call	get$atts
		mov	cl, 0FFh
		call	cpm_rwrand	; CL=-1	read  0	write
		jz	cpm_truncate2

cpm_truncate1:				; CODE XREF: F_TRUNCATE+37j
					; F_TRUNCATE+3Cj
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_truncate2:				; CODE XREF: F_TRUNCATE+23j
		call	seek$copy
		call	getdptra
		mov	dx, 0Fh
		call	extent_size	; Convert a size (extent + record no)
					; to a 3-byte record number.
		call	compare_recno
		jbe	cpm_truncate1
		call	search$extnum	; Find any extent of a file
		jz	cpm_truncate1
		call	check$rodir
		mov	byte ptr xdcnt+1, 0FDh

cpm_truncate3:				; CODE XREF: F_TRUNCATE+88j
		call	getdptra
		add	bx, 0Ch
		mov	si, offset user_fcb+0Ch
		mov	al, 2[si]
		and	al, 3Fh
		cmp	2[bx],	al
		jnz	cpm_truncate4
		mov	al, [bx]
		mov	cl, [si]
		call	compext		; Compare extent nos in	AL and CL
					; Return nonzero if they do not	match
		jz	cpm_truncate4
		mov	al, [bx]
		cmp	al, cl

cpm_truncate4:				; CODE XREF: F_TRUNCATE+57j
					; F_TRUNCATE+60j
		jnb	cpm_truncate5
		call	trunc_save_dcnt
		jmps	trunc2
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_truncate5:				; CODE XREF: F_TRUNCATE+66j
		pushf	
		mov	cl, 0
		call	scandm$ab
		popf
		jz	trunc3
		call	getdptra
		mov	byte ptr [bx], 0E5h
		call	fix$hash
trunc1:
		call	seek$copy

trunc2:					; CODE XREF: F_TRUNCATE+6Bj
					; F_TRUNCATE+FEj
		call	searchn		; Search for the next directory	element,
					; assuming a previous call on search
		jnz	cpm_truncate3
		call	update$stamp
		jmp	copy$dir$loc
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

trunc3:					; CODE XREF: F_TRUNCATE+77j
		call	trunc_save_dcnt
		call	getfcb		; Set variables	from currently addressed FCB
		call	dm$position
		inc	al
		test	single,	0FFh	; Nonzero if using 8-bit blocks
		jnz	trunc3a
		shl	al, 1

trunc3a:				; CODE XREF: F_TRUNCATE+A0j
		mov	di, offset user_fcb+10h
		xor	ah, ah
		add	di, ax
		mov	cl, 10h
		sub	cl, al
		mov	ch, ah
		mov	al, ah
		rep stosb
		call	get$dir$ext	; Compute directory extent from	FCB
		cmp	al, [bx]
		mov	[bx], al
		pushf	
		mov	al, user_fcb+20h
		inc	al
		mov	si, offset user_fcb+0Fh
		mov	[si], al
		popf
		jz	trunc3b
		call	set$rc3

trunc3b:				; CODE XREF: F_TRUNCATE+CBj
		test	dminx, 0FFh
		jnz	trunc3c
		call	set$rc3

trunc3c:				; CODE XREF: F_TRUNCATE+D5j
		call	getdptra
		add	bx, 0Bh
		and	byte ptr [bx], 7Fh
		mov	al, user_fcb+0Ch
		mov	1[bx],	al
		add	bx, 4
		mov	si, offset user_fcb+0Fh
		mov	di, bx
		mov	cx, 11h
		rep movsb
		mov	cl, 1
		call	scandm$ab
		jmp	trunc1



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_SETLABEL:		; DATA XREF: bdos:25C5o
		mov	cl, 10h
		call	copyfromdma
		call	sel1_fcb_drive
		mov	user_fcb, 21h	; Datestamped?
		mov	cl, 1
		call	search
		jnz	sdl0
		mov	bx, offset user_fcb+0Ch
		test	byte ptr [bx], 70h
		jz	sdl0
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl0:					; CODE XREF: DRV_SETLABEL+1Cj
					; DRV_SETLABEL+24j
		mov	user_fcb, 20h
		mov	cl, 1
		mov	xdcnt, 0FFFFh
		call	search
		jnz	sdl1
		mov	make$xfcb, 0FFh
		call	make
		jnz	sdl0a
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl0a:					; CODE XREF: DRV_SETLABEL+43j
		call	init$xfcb
		mov	cx, 18h
		call	stamp5
		call	stamp1

sdl1:					; CODE XREF: DRV_SETLABEL+39j
		mov	cx, 1Ch
		call	stamp5
		call	stamp2
		call	chk_xfcb_passwd
		jz	sdl1a
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

sdl1a:					; CODE XREF: DRV_SETLABEL+5Ej
		xor	cx, cx
		call	init$xfcb0
		mov	si, dx
		lodsb
		or	al, 1
		mov	[bx], al
		mov	di, lsn$add
		stosb



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sdl2:		; CODE XREF: F_WRITEXFCB+5Fp
		dec	si
		lodsb
		and	al, 1
		jz	sdl3
		mov	si, offset passwd_buf+8
		call	set$pw



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

sdl3:		; CODE XREF: F_MAKE+D1p sdl2+4j
					; ...
		call	fix$hash
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

DRV_GETLABEL:		; DATA XREF: bdos:25C8o
		call	tmpselect
		call	get$dir$mode
		jmp	sta$ret



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_TIMEDATE:		; DATA XREF: bdos:25CBo
		call	sel1_fcb_drive
		call	check$wild
		call	find_extent_0	; Find the first extent	of a file
		jz	wxfcb0a
		mov	ch, 0
		call	get$dtba
		or	al, al
		jnz	cpm_timedate1
		push	bx
		mov	di, offset user_fcb+10h
		mov	cx, 8
		rep stosb
		pop	si
		mov	cl, 4
		rep movsw
		lodsb
		mov	user_fcb+0Ch, al
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_timedate1:				; CODE XREF: F_TIMEDATE+1Cj
		call	get$xfcb
		mov	al, 0FFh
		jnz	cpm_timedate2
		jmp	sta$ret
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

cpm_timedate2:				; CODE XREF: F_TIMEDATE+36j
		mov	bx, offset user_fcb
		mov	cl, 20h
		jmp	move		; Copy CL bytes	from DX	to BX



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_WRITEXFCB:		; DATA XREF: bdos:25CEo
		mov	cl, 10h
		call	copyfromdma
		call	sel1_fcb_drive
		call	get$dir$mode
		and	al, 80h
		jnz	wxfcb0
		jmp	lret$eq$ff
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb0:					; CODE XREF: F_WRITEXFCB+17j
		call	check$wild
		mov	xdcnt, 0FFFFh
		call	search$extnum	; Find any extent of a file
		jnz	wxfcb0b

wxfcb0a:				; CODE XREF: F_TIMEDATE+13j
					; F_WRITEXFCB+36j ...
		retn	
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb0b:				; CODE XREF: F_WRITEXFCB+28j
		call	get$xfcb
		jnz	wxfcb1
		mov	make$xfcb, al
		call	make
		jz	wxfcb0a
		call	init$xfcb

wxfcb1:					; CODE XREF: F_WRITEXFCB+2Ej
		call	chk_xfcb_passwd
		jz	wxfcb1a
		jmp	pw$error
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb1a:				; CODE XREF: F_WRITEXFCB+3Ej
		mov	si, offset user_fcb+0Ch
		test	byte ptr [bx], 0FFh
		jnz	wxfcb2
		lodsb
		dec	si
		and	al, 1
		jnz	wxfcb2
		call	sdl3
		jmps	wxfcb4
;ФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФФ

wxfcb2:					; CODE XREF: F_WRITEXFCB+49j
					; F_WRITEXFCB+4Fj
		lodsb
		and	al, 0E0h
		jnz	wxfcb3
		mov	al, 80h

wxfcb3:					; CODE XREF: F_WRITEXFCB+59j
		mov	[bx], al
		call	sdl2

wxfcb4:					; CODE XREF: F_WRITEXFCB+54j
		call	get$xfcb1
		and	al, 0E0h
		mov	pw$mode, al	; Password mode
		push	ax
		call	find_extent_0	; Find the first extent	of a file
		pop	ax
		mov	user_fcb+0Ch, al
		jz	wxfcb0a
		call	get$dtba$8
		or	al, al
		jnz	wxfcb0a
		mov	al, pw$mode	; Password mode
		mov	[bx], al
		jmp	seek$copy



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_PASSWD:		; DATA XREF: bdos:25D1o
		mov	cl, 8
		call	copy_fcb
		mov	cur_fcb_len, 0
		mov	si, offset user_fcb
		mov	bx, si
		mov	di, offset df$password+7; Default password
		mov	cx, 8
		jmp	set$pw0



;лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл

;		S u b r	o u t i	n e

F_BDOS_74:		; DATA XREF: bdos:25D4o
		call	check_changed
		call	copy8fromdma
		call	check$write
		mov	ah, user_fcb+0Ch
		mov	al, user_fcb+0Eh
		push	ax
		call	find_extent_0	; Find the first extent	of a file
		pop	ax
		mov	user_fcb+0Ch, ah
		mov	user_fcb+0Eh, al
		jz	cpm_74b
		mov	cl, 50h
		call	qstamp
		jnz	cpm_74a
		mov	ch, 0
		call	get$dtba
		or	al, al
		jnz	cpm_74a
		mov	dx, offset passwd_buf
		call	stamp_compare

cpm_74a:				; CODE XREF: F_BDOS_74+2Dj
					; F_BDOS_74+36j
		mov	cl, 20h
		call	qstamp
		jnz	cpm_74b
		mov	ch, 4
		call	get$dtba
		or	al, al
		jnz	cpm_74b
		mov	dx, offset passwd_buf+4
		call	stamp_compare
		or	user_fcb+0Eh, 40h

cpm_74b:				; CODE XREF: F_BDOS_74+26j
					; F_BDOS_74+43j ...
		retn	


rod$err_patch:
		call	discard$dir	; Report read/only disk	error
		mov	ah, 2
		jmp	goerr

		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop			; Code segment patch space
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop			; Code segment patch space
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop	
		nop
;
; PADDING: The next module must be on a paragraph boundary
;
		rb	5

		dseg
		public	readonly_vector
		public	login_vector

removable_drive	dw 0			; DATA XREF: check_changed+5r
					; media$change+Fo ...
readonly_vector	dw 0			; DATA XREF: DRV_ROVECr nowriter
					; ...
login_vector	dw 0			; DATA XREF: DRV_LOGINVECr
					; rdbuff+28r ...
		db 0
fcbdsk		db 0			; DATA XREF: funcs_F_main+6Eo
					; F_do_call+51r ...
cur_fcb_len	db 0			; DATA XREF: funcs_F_main+ADr
					; copy_fcb_36+2w ...
aret		dw 0			; DATA XREF: funcs_F_main+F3r
					; F_repeat_call+1Ar ...
set_if_attrs	db 0			; DATA XREF: funcs_F_main+113r
					; F_do_call+2Br ...
dir_check_flag	db 0			; DATA XREF: deblock+B2w rd$subdir1+50r
					; ...
open_unknown	db 0			; DATA XREF: open$reel+74w
					; openx+90w ...
search$user0	db 0			; DATA XREF: bdos:371Cw bdos:374Er
					; ...
make$xfcb	db 0			; DATA XREF: make+22r F_MAKE+9Ew
					; ...
find$xfcb	db 0			; DATA XREF: search$h_sub+46r
					; searchn+4Ar ...
xdcnt		dw 0			; DATA XREF: set_dcnt_dblkr
					; search$h_sub+58w ...
dir$cnt		db 0			; DATA XREF: check$nprs+4r
					; check$nprs+Dw ...
last_sec_count	db 0			; DATA XREF: F_repeat_call+Bw
					; check$nprs+29r ...
readf$sw	db 0			; DATA XREF: rdbuff+Bw	rdbuff+4Fr
err_major	db 0			; DATA XREF: funcs_F_main+104r
					; errorw
					; ...
		dw 0,0
fs_rdwrcount	db 1			; DATA XREF: xios_rdwr+Ew bdos:2C56w
					; ...
relog		db 0			; DATA XREF: tst$relog+2w rdbuff+44w
blk$off		db 0			; DATA XREF: atran+1Dw	deblock+11Ar
					; ...
arecord1	dw 0			; DATA XREF: atran+7w lru_ckdirty+14r
p_lru_first	dw offset lru_1		; DATA XREF: lru_toucho lru_touch+1Ew
					; ...
lru_1		dw offset lru_2		; DATA XREF: dseg:05E7o
		dw 0
		dw 0FFh
lru_2		dw offset lru_3		; DATA XREF: dseg:05E9o
		dw 0
		dw 0FFh
lru_3		dw offset lru_4		; DATA XREF: dseg:05EFo
		dw 0
		dw 0FFh
lru_4		dw offset lru_5		; DATA XREF: dseg:05F5o
		dw 0
		dw 0FFh
lru_5		dw offset lru_6		; DATA XREF: dseg:05FBo
		dw 0
		dw 0FFh
lru_6		dw 0			; DATA XREF: dseg:0601o
		dw 0
		dw 0FFh
hash		rb 4			; DATA XREF: get$hash+3w get$hash+Cw
					; ...
hashl		db 0			; DATA XREF: media$change+Cw
					; set$hash+16w	...
log$fxs		db 0Ch,	2, 3, 4, 6, 9, 0Ah, 0Dh, 11h, 1Ch, 1Dh,	1Fh, 20h
		db 0,0,0,0
					; DATA XREF: tst$log$fxs+7o
rw$fxs		db 5, 7, 8, 0Fh, 10h, 16h, 0, 0
					; Read or write	functions
sc$fxs		db 2, 3, 5, 0, 0
					; Close	or search functions

deblock_command	db 0			; DATA XREF: deblock+76w deblock+A9r
					; ...
phy$off		db 0			; DATA XREF: get$bcba+6Cr get$bcba+EEr
					; ...
curbcba		dw 0			; DATA XREF: get$bcba+53w get$bcba+5Fr
					; ...
rootbcba	dw 0			; DATA XREF: get$bcbaw	get$bcba+DBr
					; ...
emptybcba	dw 0			; DATA XREF: get$bcba+16w get$bcba+2Br
					; ...
seqbcba		dw 0			; DATA XREF: get$bcba+19w get$bcba+4Fw
					; ...
my_bcbs		db 0			; DATA XREF: get$bcba+1Cw get$bcba+4Bw
					; ...
					; BCBs owned by	this process
fs_function	db 0			; DATA XREF: bdos:25EBr funcs_F_main+14w
					; ...
fs_track	dw 0			; DATA XREF: xios_rdwr+13r
					; seek+40w ...
fs_sector	dw 0			; DATA XREF: xios_rdwr+17r
					; seek+43w ...
fs_param_low	dw 0			; DATA XREF: bdos:25FFr funcs_F_main+73w
					; ...
searcha		dw 0			; DATA XREF: searchi+3w searchn+14r
					; ...
fs_fcbdrive	db 0			; DATA XREF: funcs_F_main+30w
					; error+4r ...
usrcode		db 0			; DATA XREF: reselect+40r F_OPEN+2Cr
					; ...
fs_param_ds	dw 0			; DATA XREF: funcs_F_main+37w
					; funcs_F_main+BCr ...
f_ret_es	dw 0			; DATA XREF: funcs_F_main+3Ew
					; funcs_F_main+ECr ...
userdma		dw 0			; DATA XREF: funcs_F_main+4Eo
					; funcs_F_main+58r ...
userdmaseg	dw 0			; DATA XREF: funcs_F_main+5Fw
					; deblock+171r	...
sys_fx		db 0			; DATA XREF: funcs_F_main+E1o
searchl		db 0			; DATA XREF: search$hash+7r
					; searchi+Cw ...
sys_find1st	dw 0,0			; DATA XREF: F_SFIRST+9w bdos:461Cr
					; ...
dcnt		dw 0			; DATA XREF: end$of$diro set$end$dirw
					; ...
ff2c_extent	dw 0			; DATA XREF: srch_fat+7w srch_fat+22w
					; ...
fs_errormode	db 0			; DATA XREF: sel$error+Cr disk_error+Cr
					; ...
fs_sectorcount	db 0			; DATA XREF: funcs_F_main+97r
					; F_repeat_call+8r ...
df$password	rb 8			; DATA XREF: cmp$pw+36o F_PASSWD+Fo
					; Default password
high$ext	db 0			; DATA XREF: F_do_call+3Br
					; chek$fcbr ...
xfcb_rdonly	db 0			; DATA XREF: F_do_call+32r
					; cpm_writerec+Fr ...
curdsk		db 0FFh			; DATA XREF: xios_rdwr+8r sel$errorw
					; ...
cdrmaxa		dw 0			; DATA XREF: compcdr+4r cpm_login+3Br
					; ...
lsn$add		dw 0			; DATA XREF: chek$fcb+Cr set$lsnr
					; ...
buffa		dw 0			; DATA XREF: compute$csr getdptra+6r
					; ...
dph_dpb		dw 0			; DATA XREF: drive_login+1Eo
					; drive_login+26r ...
dph_csv		dw 0			; DATA XREF: r$dir+50r
dph_alv		dw 0			; DATA XREF: getallocbit+Dr
					; copy$alv+Br ...
dph_dirbcb	dw 0			; DATA XREF: discard$dirr deblock+4r
					; ...
dph_dtabcb	dw 0			; DATA XREF: discard$databcbr
					; deblock+13r ...
dph_hash	dw 0			; DATA XREF: set$hashr	search$hashr
					; ...
dpb_spt		dw 0			; DATA XREF: seek+32r seek+38r
					; ...
dpb_bsh		db 0			; DATA XREF: atranr dm$positionr
					; ...
dpb_blm		db 0			; DATA XREF: atran+19r	check$nprs+53r
					; ...
dpb_exm		db 0			; DATA XREF: get$dir$ext+2Br
					; compext+1r ...
dpb_dsm		dw 0			; DATA XREF: get$nalbsr scandm$a+37r
					; ...
dpb_drm		dw 0			; DATA XREF: r$dirr search$hash+1Fr
					; ...
dpb_al0_al1	dw 0			; DATA XREF: scandm$a+16r cpm_login+25r
dpb_cks		dw 0			; DATA XREF: rdbuff+20r r$dir+3Dr
					; ...
dpb_off		dw 0			; DATA XREF: seek+3Cr
dpb_psh		db 0			; DATA XREF: seek+9r check$nprs+104r
					; ...
dpb_phm		db 0			; DATA XREF: get$bcba+92r lru_ckdirty+29r
					; ...
passwd_buf	rb 11h
					; cmp$pw+21o ...
result_F0F	db 0			; DATA XREF: F_do_call+4Br
					; make+60w
save$xfcb	db 0			; DATA XREF: searchn+37w searchn+51w
					; ...
openreel_S2	db 0			; DATA XREF: open$reel+3w open$reel+66r
pw$mode		db 0			; DATA XREF: chk$pw$error+24w
					; chk$pw$error+33o ...
					; Password mode
attributes	db 0			; DATA XREF: get$atts+17w cpm_delete+16r
					; ...
					; Bit 7	set: F5'
					; Bit 6	set: F6'
					; Bit 5	set: F7'
					; Bit 4	set: F8'
		rb 4
rmf		db 0			; DATA XREF: open$reel+44r
					; open$reel+90r ...
					; Read mode flag
deblock_flag	db 0			; DATA XREF: cpm_writerec+92w
					; cpm_writerec+A0r ...
dirloc		db 0			; DATA XREF: bdos:3431r searchi+7w
					; ...
linfo		db 0			; DATA XREF: funcs_F_main+77w
					; DRV_SET+3r ...
dminx		db 0			; DATA XREF: index+3w get$dir$ext+14w
					; ...
single		db 0			; DATA XREF: get$dm+5r	get$dir$ext+18r
					; ...
					; Nonzero if using 8-bit blocks
rcount		db 0			; DATA XREF: getfcb+1Ew setfcb+19r
					; ...
extval		db 0			; DATA XREF: dm$position+Fr
					; getfcb+28w
vrecord		db 0			; DATA XREF: atran+16r	dm$position+4r
					; ...
bcb_drive	db 0			; DATA XREF: rdbuff+17r rdbuff+3Br
					; ...
bcb_record	dw 0			; DATA XREF: xios_rdwrr seekr	...
bcb_record_h	db 0			; DATA XREF: xios_rdwr+4r seek+5r
					; ...
bcb_dirty	dw 0			; DATA XREF: atran+12w	cpm_login+38w
					; ...
drec		dw 0			; DATA XREF: rd$dir+7w	r$dir+39r
					; ...
fs_buffer	dw 0,0			; DATA XREF: xios_rdwr+1Br
					; deblockw ...
dptr		db 0			; DATA XREF: getdptrar	drv$relog+8w
					; ...
user0$pass	db 0			; DATA XREF: searchnw bdos:3708r
					; ...
call_flags	dw 0			; DATA XREF: F_repeat_callw
					; F_repeat_call+Fr
fcb_randrec_num	rb 3
error_drive	db 0			; DATA XREF: funcs_F_main+11Fr
					; error+7w
strColonSpace	db ' : $'               ; DATA XREF: funcs_F_main+14Bw
					; funcs_F_main+14Fo
error_strings	dw 0			; DATA XREF: funcs_F_main+15Do
		dw offset addr_writeerr
		dw offset addr_rodisk
		dw offset addr_rofile
		dw offset addr_invaliddrv
		dw 0
		dw 0
		dw offset addr_pwderr
		dw offset addr_filexists
		dw offset addr_ambiguous
		rw 3
errFilename	rb 0Ch
		db '$'
F_entry_sp	dw 0			; DATA XREF: funcs_F_main+27o
					; F_do_callw ...
user_fcb	rb 24h
		rb 4
passwd_fcb	rb 10h

		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh
		db	0CCh, 0CCh
F_old_sp	dw 0
F_old_ss	dw 0
;
; PADDING: The next module must be on a paragraph boundary
;
		rb 3
