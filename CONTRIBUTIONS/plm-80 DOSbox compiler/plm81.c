/* plm81.f -- translated by f2c (version 20060506).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

/* Common Block Declarations */

struct titl_1_ {
    integer title[10], vers;
};

#define titl_1 (*(struct titl_1_ *) &titl_)

struct stacks_1_ {
    integer sp, mp, mpp1, mstack, mvar, vartop, pstack[75], var[75], varc[256]
	    , fixv[75], fixc[75], prmask[5];
    logical failsf, compil;
};

#define stacks_1 (*(struct stacks_1_ *) &stacks_)

struct syntax_1_ {
    integer v[446], vloc[107], vindx[13], c1[364], c1tri[243], prtb[129], 
	    prdtb[129], hdtb[129], prlen[129], contc[129], leftc[5], lefti[57]
	    , contt[1], tripi[57], prind[107], nsy, nt, vlen, vil, c1w, c1l, 
	    nc1tri, prtbl, prdtbl, hdtbl, prlenl, concl, leftcl, leftil, 
	    contl, tripl, pril, pack, token, identv, numbv, strv, divide, 
	    eofile, procv, semiv, decl, dov, endv, groupv, stmtv, slistv;
};

#define syntax_1 (*(struct syntax_1_ *) &syntax_)

struct files_1_ {
    integer ibuff[80], obuff[120], ibp, obp, inptr, instk[7], itran[256], 
	    otran[64];
};

#define files_1 (*(struct files_1_ *) &files_)

struct cntrl_1_ {
    integer contrl[64];
};

#define cntrl_1 (*(struct cntrl_1_ *) &cntrl_)

struct messag_1_ {
    integer mssg[77];
};

#define messag_1 (*(struct messag_1_ *) &messag_)

struct scanc_1_ {
    integer acclen, accum[32], type__, stype, eoflag, ident, numb, specl, str,
	     cont, value;
};

#define scanc_1 (*(struct scanc_1_ *) &scanc_)

struct macro_1_ {
    integer macros[2000], maxmac, curmac, mactop;
};

#define macro_1 (*(struct macro_1_ *) &macro_)

struct types_1_ {
    integer varb, intr, proc, label, liter;
};

#define types_1 (*(struct types_1_ *) &types_)

struct blk_1_ {
    integer block[30], dopar[30], macblk[30], curblk, maxblk, blksym, proctp[
	    30];
};

#define blk_1 (*(struct blk_1_ *) &blk_)

struct sym_1_ {
    integer symbol[4000], symtop, maxsym, symloc, symlen, symcnt, symabs, 
	    acnt;
};

#define sym_1 (*(struct sym_1_ *) &sym_)

struct pole_1_ {
    integer polish[30], maxpol, poltop, polcnt, polchr[18];
};

#define pole_1 (*(struct pole_1_ *) &pole_)

struct opcod_1_ {
    integer opcval[51], opr, adr, vlu, def, lit, lin, nop, add, adc, sub, sbc,
	     mul, div, rem, neg, and, ior, xor, not, eql, lss, gtr, neq, leq, 
	    geq, inx, tra, trc, pro, ret, sto, std, xch, del, dat, lod, bif, 
	    inc, cse, end, enb, enp, hal, rtl, rtr, sfl, sfr, hiv, lov, cva, 
	    org, drt, ena, dis, ax1, ax2, ax3;
};

#define opcod_1 (*(struct opcod_1_ *) &opcod_)

struct hash_1_ {
    integer hentry[127], hcode;
};

#define hash_1 (*(struct hash_1_ *) &hash_)

struct inter_1_ {
    integer intpro[8];
};

#define inter_1 (*(struct inter_1_ *) &inter_)

struct asc_1_ {
    integer ascii[64];
};

#define asc_1 (*(struct asc_1_ *) &asc_)

struct terrm_1_ {
    integer terr[22];
};

#define terrm_1 (*(struct terrm_1_ *) &terrm_)

/* Initialized data */

struct {
    integer e_1[11];
    } titl_ = { 27, 23, 24, 3, 1, 33, 16, 29, 30, 1, 20 };

struct {
    integer e_1[123];
    } blk_ = { 1, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 2, 30, 120, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

struct {
    integer e_1[4002];
    integer fill_2[2];
    integer e_3[3];
    } sym_ = { 5439488, 65536, 4101, 17, 221103907, 6815744, 131074, 4100, 17,
	     608028224, 5046272, 196615, 4100, 17, 491591168, 7471104, 262156,
	     8198, 17, 439207134, 587202560, 7995392, 327697, 8198, 17, 
	    389903964, 587202560, 851968, 393239, 8200, 33, 494449493, 
	    444186624, 3866624, 458781, 4099, 530, 476405760, 8126464, 524323,
	     4099, 530, 476430336, 5373952, 589864, 4099, 530, 491347968, 
	    1310720, 655405, 4099, 530, 491372544, 131072, 720946, 4099, 530, 
	    490037248, 4390912, 786487, 4099, 530, 490061824, 5373996, 852028,
	     4100, 258, 508392384, 7405568, 917569, 4100, 274, 307041408, 
	    7143424, 983110, 4099, 274, 375787520, 5308416, 1048651, 4101, 
	    274, 325167070, 3276800, 1114192, 8198, 274, 427681439, 503316480,
	     1114112, 1179733, 8198, 274, 373130334, 301989888, 1703936, 
	    1245275, 4100, 274, 372103040, 1900544, 1310817, 4100, 770, 
	    392561600, 589824, 1376358, 8198, 290, 241562390, 251658240, 
	    458752, 1441899, 4099, 274, 238866432, 1507441, 0, 1, 117, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 120, 4000, {0}, 23, 4000, 0 };

struct {
    integer fill_1[30];
    integer e_2[21];
    } pole_ = { {0}, 30, 0, 0, 26, 27, 29, 12, 15, 29, 33, 12, 23, 15, 16, 17,
	     23, 20, 31, 23, 20, 25 };

struct {
    integer e_1[108];
    } opcod_ = { 104091, 50127, 50126, 124941, 123726, 100375, 62753, 119832, 
	    103442, 50767, 83613, 145053, 104095, 67351, 96158, 75741, 103452,
	     95260, 74780, 83555, 128844, 128846, 112474, 119839, 124890, 
	    124879, 144275, 62487, 62239, 95887, 54545, 83534, 59280, 67151, 
	    67149, 67163, 78615, 120791, 120797, 123991, 123997, 79137, 95905,
	     59468, 108370, 63327, 67148, 62750, 51395, 51396, 51397, 0, 1, 2,
	     3, 4, 5, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
	    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 
	    32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
	    48, 49, 50 };

struct {
    integer fill_1[1];
    integer e_2[5];
    integer fill_3[561];
    logical e_4[2];
    } stacks_ = { {0}, 0, 1, 75, 256, 1, {0}, FALSE_, TRUE_ };

struct {
    integer e_1[127];
    integer fill_2[1];
    } hash_ = { 0, 54, 0, 0, 0, 0, 112, 0, 106, 0, 0, 0, 28, 0, 0, 0, 90, 0, 
	    0, 49, 0, 0, 0, 0, 0, 96, 0, 0, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, 34, 0, 
	    0, 0, 0, 0, 0, 0, 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 0, 0, 0, 79, 
	    64, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	     6, 0, 0, 0, 0, 74, 0, 0, 0, 69, 16, 0, 0, 0, 0, 0, 0, 0, 22, 0, 
	    39, 0, 0, 0 };

struct {
    integer e_1[2077];
    } syntax_ = { 18, 49, 16, 29, 29, 26, 29, 51, 1, 31, 26, 22, 16, 25, 1, 
	    39, 1, 2, 50, 1, 52, 1, 43, 1, 42, 1, 48, 1, 51, 1, 39, 1, 49, 1, 
	    50, 1, 44, 1, 45, 1, 47, 1, 41, 1, 40, 2, 20, 17, 2, 15, 26, 2, 
	    18, 26, 2, 31, 26, 2, 26, 29, 2, 13, 36, 3, 16, 26, 17, 3, 16, 25,
	     15, 3, 35, 26, 29, 3, 12, 25, 15, 3, 25, 26, 31, 3, 24, 26, 15, 
	    4, 19, 12, 23, 31, 4, 31, 19, 16, 25, 4, 16, 23, 30, 16, 4, 14, 
	    12, 30, 16, 4, 14, 12, 23, 23, 4, 18, 26, 31, 26, 4, 15, 12, 31, 
	    12, 4, 13, 36, 31, 16, 4, 27, 23, 32, 30, 5, 23, 12, 13, 16, 23, 
	    5, 13, 12, 30, 16, 15, 5, 24, 20, 25, 32, 30, 5, 34, 19, 20, 23, 
	    16, 6, 16, 25, 12, 13, 23, 16, 6, 29, 16, 31, 32, 29, 25, 7, 15, 
	    20, 30, 12, 13, 23, 16, 7, 15, 16, 14, 23, 12, 29, 16, 7, 12, 15, 
	    15, 29, 16, 30, 30, 7, 20, 25, 20, 31, 20, 12, 23, 8, 49, 25, 32, 
	    24, 13, 16, 29, 50, 8, 49, 30, 31, 29, 20, 25, 18, 50, 9, 20, 25, 
	    31, 16, 29, 29, 32, 27, 31, 9, 27, 29, 26, 14, 16, 15, 32, 29, 16,
	     9, 23, 20, 31, 16, 29, 12, 23, 23, 36, 12, 49, 20, 15, 16, 25, 
	    31, 20, 17, 20, 16, 29, 50, 813276224, 808598592, 813315727, 
	    822083584, 813233943, 822083584, 809879135, 449052672, 814032086, 
	    264503296, 809865246, 432275456, 809337747, 407310336, 812238417, 
	    472742976, 812709526, 188021824, 812238039, 192035904, 813741843, 
	    187786225, 808818205, 506300337, 812709259, 508401201, 813032158, 
	    257750558, 822083584, 810352653, 372111183, 822083584, 813287375, 
	    6862622, 822083584, 809023371, 5846878, 822083584, 809023371, 
	    4780750, 822083584, 811136030, 6862622, 822083584, 808310611, 
	    291599320, 516161536, 809379484, 259380441, 415498240, 809879135, 
	    436282315, 247726080, 808556504, 234955723, 247726080, 810352669, 
	    506323927, 258075712, 814032086, 251712907, 527760448, 810386654, 
	    321740822, 326495296, 810386654, 321740818, 254602304, 808761167, 
	    7665039, 226072369, 813741843, 187786176, 405631985, 808818205, 
	    506300288, 305968049, 813032158, 257750558, 5846878, 822083584, 
	    808760726, 7725790, 257750558, 822083584, 812238413, 255457039, 
	    4780750, 822083584, 812238413, 255457039, 6337999, 822083584, 
	    812168971, 389931996, 5846878, 822083584, 812168971, 389931996, 
	    4780750, 822083584, 808499023, 235012828, 321701263, 822083584, 
	    811177043, 221077520, 188081756, 822083584, 813036317, 225523358, 
	    4780750, 822083584, 808499027, 218224523, 507343832, 516161536, 
	    809865246, 419551115, 507343832, 516161536, 813032410, 3732499, 
	    407758041, 415498240, 810345432, 508363983, 469853405, 516161536, 
	    811177043, 221077530, 474837724, 600047616, 812709791, 476055390, 
	    192476623, 410718208, 811119375, 369157072, 325138323, 425922560, 
	    813315727, 3732310, 191936403, 425922560, 810410972, 192493144, 
	    3511838, 476408896, 811177043, 221077533, 255170062, 192035904, 
	    811177043, 221077519, 577356765, 491623985, 809038678, 191936403, 
	    425722838, 257750558, 822083584, 812238413, 255457039, 3732499, 
	    407758041, 415498240, 809038678, 191936403, 425723742, 192476623, 
	    410718208, 808305886, 308082579, 218167450, 473814867, 425922560, 
	    810345432, 508363983, 469882511, 223151309, 192493144, 822083584, 
	    1, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 49, 52,
	     55, 58, 61, 64, 68, 72, 76, 80, 84, 88, 93, 98, 103, 108, 113, 
	    118, 123, 128, 133, 139, 145, 151, 157, 164, 171, 179, 187, 195, 
	    203, 212, 221, 231, 241, 251, 131336, 131337, 196874, 196876, 
	    229646, 229648, 229650, 262420, 295190, 295192, 295194, 327964, 
	    327966, 327968, 360738, 360741, 360744, 360747, 360750, 360753, 
	    393524, 393527, 393530, 393533, 459072, 459075, 459078, 459081, 
	    491852, 491855, 491858, 524629, 524633, 524637, 524641, 524645, 
	    524649, 524653, 524657, 524661, 557433, 557437, 557441, 557445, 
	    557449, 590221, 590225, 590229, 623001, 623005, 655777, 688549, 
	    721322, 754095, 754100, 852409, 1, 14, 20, 26, 35, 39, 41, 45, 47,
	     50, 50, 50, 51, 0, 0, 0, 32768, 688288, 35815424, 713162890, 
	    715827202, 673744896, 991953792, 196620, 201326640, 0, 15740976, 
	    2129920, 8388608, 2563, 134283266, 671219840, 671091360, 
	    545786880, 204472320, 805306368, 245952, 541360640, 0, 40, 
	    33686536, 134217728, 0, 10493968, 16384, 0, 1281, 4194308, 0, 0, 
	    335807488, 1048576, 0, 81984, 268435712, 0, 20, 16842752, 0, 0, 
	    5246992, 1064960, 4194304, 1281, 67108864, 1, 4096, 262144, 4096, 
	    0, 0, 536904192, 131072, 40, 33619972, 67108880, 0, 5247008, 
	    2129920, 8388608, 2562, 67108865, 335544384, 335545680, 268730368,
	     0, 0, 64, 268452096, 65536, 20, 16842756, 67108880, 0, 5246992, 
	    1064960, 0, 1281, 4194308, 0, 0, 335822848, 0, 0, 8, 168, 8232, 
	    174112, 35651584, 44040194, 10485802, 545267728, 1064960, 4194304,
	     1281, 0, 0, 0, 262144, 0, 0, 131200, 268435456, 0, 0, 2129920, 0,
	     0, 33554448, 16384, 0, 1281, 136314880, 0, 2, 0, 0, 0, 128, 
	    268435712, 0, 20, 16908296, 134217760, 0, 10494208, 0, 0, 0, 
	    138412292, 1024, 0, 335822848, 0, 0, 0, 268435456, 0, 0, 18907136,
	     0, 0, 33554448, 0, 0, 0, 254192288, 44081696, 2129920, 41514, 
	    713042442, 142606856, 0, 0, 0, 16, 2228224, 0, 139264, 134742016, 
	    0, 0, 256, 201239200, 44081696, 27885576, 1049600, 68157440, 
	    268435456, 81984, 268452096, 65536, 20, 19955712, 0, 0, 33555080, 
	    715456680, 168951816, 134217728, 67108864, 0, 0, 1024, 68157440, 
	    268435456, 81984, 0, 0, 16, 18874368, 0, 0, 0, 2, 0, 0, 4194564, 
	    1024, 0, 335847978, 713042442, 142606856, 10, 233482242, 
	    673744896, 136314880, 2935466, 537559688, 536904192, 16, 1064960, 
	    0, 1281, 134217730, 671744128, 671091360, 537411584, 344064, 
	    16859136, 356581444, 84, 4116, 87056, 18907136, 0, 0, 0, 0, 0, 
	    1280, 0, 0, 0, 311296, 0, 0, 9, 67108865, 67109888, 0, 1048576, 
	    22021121, 5242901, 272633856, 0, 0, 1024, 134217730, 671744128, 
	    671091360, 537411584, 0, 0, 8, 134217728, 0, 128, 0, 0, 0, 
	    5243136, 0, 0, 0, 26214400, 0, 8912904, 0, 0, 0, 81924, 84, 
	    37752852, 87056, 17825792, 0, 0, 256, 5376, 263424, 5571585, 
	    71303168, 0, 4456452, 16793600, 0, 1088, 1048576, 0, 0, 0, 
	    16777216, 0, 0, 4744, 168, 151126016, 0, 4194564, 1024, 0, 
	    335839232, 688288, 36864000, 713162884, 0, 0, 0, 1048576, 0, 0, 0,
	     0, 0, 1, 169869312, 44081184, 0, 16384, 0, 0, 4, 84, 4198420, 
	    87056, 287342592, 0, 0, 16777728, 0, 0, 0, 169869312, 44081184, 0,
	     41472, 9732, 8388608, 8, 134217728, 0, 0, 1048576, 0, 0, 260, 0, 
	    0, 0, 169956608, 44081184, 1064960, 1024, 0, 1088, 1048576, 
	    197379, 197386, 197389, 197400, 197421, 197422, 197426, 209411, 
	    329219, 329226, 329229, 329240, 329261, 329262, 329266, 393987, 
	    393994, 393997, 394008, 394029, 394030, 394034, 406019, 590595, 
	    590602, 590605, 590616, 590637, 590638, 590642, 602627, 656131, 
	    656138, 656141, 656152, 656173, 656174, 656178, 668163, 721667, 
	    721674, 721677, 721688, 721709, 721710, 721714, 733699, 787203, 
	    787210, 787213, 787224, 787245, 787246, 787250, 799235, 864771, 
	    918275, 918282, 918285, 918296, 918317, 918318, 918322, 930307, 
	    995843, 998918, 1180419, 1180426, 1180429, 1180440, 1180461, 
	    1180462, 1180466, 1192451, 1323523, 1323525, 1326596, 1326598, 
	    1328897, 1442563, 1442570, 1442573, 1442584, 1442605, 1442606, 
	    1442610, 1454595, 1508099, 1508106, 1508109, 1508120, 1508141, 
	    1508142, 1508146, 1520131, 1573635, 1573642, 1573645, 1573656, 
	    1573677, 1573678, 1573682, 1585667, 1639171, 1639178, 1639181, 
	    1639192, 1639213, 1639214, 1639218, 1651203, 1901315, 1901322, 
	    1901325, 1901336, 1901357, 1901358, 1901362, 1913347, 1978883, 
	    2228995, 2229002, 2229005, 2229016, 2229037, 2229038, 2229042, 
	    2241027, 2425603, 2425610, 2425613, 2425624, 2425645, 2425646, 
	    2425650, 2437635, 2622211, 2622218, 2622221, 2622232, 2622253, 
	    2622254, 2622258, 2634243, 2949665, 2949667, 2949675, 3091713, 
	    3343107, 3343114, 3343117, 3343128, 3343149, 3343150, 3343154, 
	    3355139, 3408643, 3408650, 3408653, 3408664, 3408685, 3408686, 
	    3408690, 3420675, 3670787, 3670794, 3670797, 3670808, 3670829, 
	    3670830, 3670834, 3682819, 3932931, 3932938, 3932941, 3932952, 
	    3932973, 3932974, 3932978, 3944963, 4195075, 4195082, 4195085, 
	    4195096, 4195117, 4195118, 4195122, 4207107, 4338179, 4338181, 
	    4341252, 4341254, 4343553, 4348700, 4403715, 4403717, 4406788, 
	    4406790, 4409089, 4538114, 4538116, 4600323, 4603396, 4603398, 
	    4796931, 4796933, 4800004, 4800006, 4802305, 4861186, 5127938, 
	    5127940, 5324546, 5324548, 5386755, 5386757, 5389828, 5389830, 
	    5392129, 5517827, 5517829, 5520900, 5520902, 5523201, 5584129, 
	    5649665, 5714434, 5714436, 5899011, 5899018, 5899021, 5899032, 
	    5899053, 5899054, 5899058, 5911043, 6369795, 6369797, 6372868, 
	    6372870, 6375169, 6816771, 6816818, 0, 5592629, 5582637, 21813, 
	    21846, 3933, 3916, 3919, 85, 15, 71, 55, 103, 96, 83, 92, 104, 26,
	     39, 41, 0, 17727, 20031, 22322, 24144, 20799, 840, 23112, 32, 
	    106, 44, 13, 50, 0, 0, 22322, 17727, 24144, 20031, 20799, 23112, 
	    62, 50, 45, 7, 8, 0, 0, 0, 7, 0, 16, 0, 0, 0, 3656, 91, 0, 0, 0, 
	    50, 0, 0, 0, 57, 0, 12849, 0, 97, 21, 57, 88, 0, 0, 4861186, 106, 
	    26889, 26890, 26914, 26917, 10, 0, 21586, 97, 73, 13835, 13836, 
	    13849, 0, 30, 13, 0, 13, 0, 16963, 82, 73, 66, 0, 50, 70, 3360820,
	     15932, 51, 56, 29, 40, 97, 0, 98, 0, 0, 25874, 25878, 0, 97, 0, 
	    24, 0, 0, 4078664, 22807, 0, 4064518, 0, 26628, 42, 26944, 0, 0, 
	    38, 39, 36, 37, 25, 26, 27, 35, 24, 6, 7, 8, 9, 10, 11, 12, 13, 
	    14, 15, 16, 61, 78, 41, 72, 114, 117, 121, 62, 70, 79, 118, 122, 
	    42, 73, 43, 63, 74, 80, 119, 123, 84, 47, 48, 100, 101, 96, 83, 
	    97, 99, 98, 54, 126, 127, 44, 21, 22, 55, 67, 69, 77, 128, 49, 68,
	     53, 125, 59, 124, 40, 45, 52, 76, 75, 120, 65, 64, 103, 104, 105,
	     106, 107, 102, 34, 46, 23, 109, 110, 111, 108, 51, 116, 115, 113,
	     112, 19, 3, 28, 18, 2, 60, 82, 31, 81, 30, 32, 33, 50, 20, 5, 66,
	     71, 1, 88, 89, 87, 17, 4, 93, 92, 58, 29, 91, 90, 86, 85, 57, 56,
	     95, 94, 0, 84, 84, 84, 84, 73, 73, 73, 84, 73, 91, 91, 91, 91, 
	    91, 91, 91, 91, 91, 91, 91, 68, 77, 86, 106, 61, 61, 62, 69, 74, 
	    78, 81, 90, 87, 94, 87, 69, 94, 78, 81, 90, 70, 97, 97, 64, 64, 
	    64, 60, 64, 64, 64, 57, 51, 52, 58, 66, 67, 57, 53, 53, 88, 56, 
	    96, 53, 92, 63, 102, 63, 85, 58, 92, 80, 80, 62, 98, 98, 105, 105,
	     105, 105, 105, 105, 103, 58, 55, 54, 54, 54, 54, 83, 61, 61, 61, 
	    61, 75, 82, 73, 75, 82, 102, 71, 99, 71, 99, 76, 79, 96, 75, 65, 
	    98, 106, 59, 101, 101, 101, 91, 65, 100, 100, 102, 93, 89, 89, 72,
	     72, 104, 104, 95, 95, 0, 4, 4, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 
	    2, 2, 2, 2, 2, 2, 1, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 3, 
	    3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 2, 1, 2, 1, 1, 1, 3, 2, 1, 
	    1, 1, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 2, 2, 1, 1, 4, 2, 3, 3, 3, 3, 
	    2, 1, 3, 2, 2, 3, 3, 3, 1, 2, 2, 1, 2, 1, 3, 2, 2, 2, 1, 2, 2, 4, 
	    3, 2, 2, 2, 2, 2, 1, 2, 1, 1, 3, 3, 1, 2, 1, 2, 1, 1, 4, 3, 1, 4, 
	    1, 3, 2, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 105, 4, 42, 94, 85, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 4, 4, 4, 4, 
	    4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 21, 28, 35, 42, 44, 
	    48, 49, 51, 51, 51, 51, 51, 51, 51, 51, 51, 53, 53, 54, 54, 55, 
	    55, 55, 55, 55, 55, 56, 57, 57, 57, 58, 58, 59, 59, 60, 61, 61, 
	    62, 62, 63, 63, 63, 64, 64, 66, 68, 68, 69, 69, 74, 74, 74, 76, 
	    82, 82, 82, 82, 85, 85, 85, 89, 92, 94, 94, 99, 99, 99, 100, 100, 
	    100, 101, 107, 107, 107, 109, 109, 110, 110, 110, 111, 111, 112, 
	    112, 112, 112, 112, 112, 112, 115, 115, 117, 117, 117, 117, 119, 
	    119, 119, 120, 121, 123, 125, 127, 127, 127, 129, 129, 106, 50, 
	    445, 12, 102, 363, 242, 128, 128, 128, 128, 128, 4, 56, 0, 56, 
	    106, 5, 0, 50, 45, 46, 0, 20, 48, 1, 42, 15, 21, 55, 65, 82 };

struct {
    integer e_1[8];
    } inter_ = { 0, 0, 0, 0, 0, 0, 0, 0 };

struct {
    integer fill_1[200];
    integer e_2[3];
    integer fill_3[263];
    char e_4[208];
    integer e_5[12];
    } files_ = { {0}, 81, 0, 0, {0}, "    0   1   2   3   4   5   6   7   8 "
	    "  9   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O "
	    "  P   Q   R   S   T   U   V   W   X   Y   Z   $   =   .   /   ( "
	    "  )   +   -   '   *   ,   <   >   :   ;   ", 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0 };

struct {
    integer e_1[64];
    } asc_ = { 32, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69,
	     70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 
	    86, 87, 88, 89, 90, 36, 61, 46, 47, 40, 41, 43, 45, 39, 42, 44, 
	    60, 62, 58, 59, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

struct {
    integer e_1[64];
    } cntrl_ = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
	    ;

struct {
    integer e_1[22];
    } terrm_ = { 14, 26, 24, 27, 20, 23, 12, 31, 20, 26, 25, 1, 31, 16, 29, 
	    24, 20, 25, 12, 31, 16, 15 };

struct {
    integer e_1[77];
    } messag_ = { 27, 12, 30, 30, 45, 25, 26, 27, 29, 26, 18, 29, 12, 24, 1, 
	    16, 29, 29, 26, 29, 42, 43, 25, 16, 12, 29, 12, 31, 27, 12, 29, 
	    30, 16, 1, 30, 31, 12, 14, 22, 51, 1, 30, 36, 24, 13, 26, 23, 1, 
	    1, 12, 15, 15, 29, 1, 34, 15, 30, 1, 14, 19, 29, 30, 1, 1, 1, 23, 
	    16, 25, 18, 31, 19, 1, 27, 29, 1, 31, 36 };

struct {
    integer fill_1[34];
    integer e_2[7];
    integer fill_3[1];
    } scanc_ = { {0}, 0, 1, 2, 3, 4, 5, 1 };

struct {
    integer e_1[2003];
    } macro_ = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    2000, 2001, 1 };

struct {
    integer e_1[5];
    } types_ = { 1, 2, 3, 4, 5 };


/* Table of constant values */

static integer c__2 = 2;
static integer c__0 = 0;
static integer c__4 = 4;
static integer c__8080 = 8080;
static integer c__10 = 10;
static integer c__1 = 1;
static integer c__40 = 40;
static integer c__6 = 6;
static integer c__7 = 7;
static integer c__41 = 41;
static integer c_n5 = -5;
static integer c__8 = 8;
static integer c__20 = 20;
static integer c__30 = 30;
static integer c__12 = 12;
static integer c__5 = 5;
static integer c__16 = 16;
static integer c__42 = 42;
static integer c__77 = 77;
static integer c_n3 = -3;
static integer c_n4 = -4;
static integer c__46 = 46;
static integer c__3 = 3;
static integer c__15 = 15;
static integer c__11 = 11;
static integer c__14 = 14;
static integer c__13 = 13;
static integer c__39 = 39;
static integer c__17 = 17;
static integer c__45 = 45;
static integer c__44 = 44;
static integer c__18 = 18;
static integer c__19 = 19;
static integer c__21 = 21;
static integer c__22 = 22;
static integer c__23 = 23;
static integer c__24 = 24;
static integer c__25 = 25;
static integer c__26 = 26;
static integer c__27 = 27;
static integer c__28 = 28;
static integer c__29 = 29;
static integer c__47 = 47;
static integer c__38 = 38;
static integer c__43 = 43;
static integer c__37 = 37;
static integer c__31 = 31;
static integer c__32 = 32;
static integer c__33 = 33;
static integer c__80 = 80;
static integer c__34 = 34;
static integer c_n10 = -10;
static integer c__35 = 35;
static integer c__36 = 36;
static integer c__48 = 48;
static integer c__51 = 51;

/* *********************************************************************** */

/*         8 0 8 0   P L / M   C O M P I L E R ,   P A S S - 1 */
/*                                 PLM81 */
/*                              VERSION 2.0 */
/*                             JANUARY, 1975 */

/*                          COPYRIGHT (C) 1975 */
/*                          INTEL CORPORATION */
/*                          3065 BOWERS AVENUE */
/*                          SANTA CLARA, CALIFORNIA 95051 */

/*  MODIFIED BY JEFF OGDEN (UM), DECEMBER 1977 */

/* *********************************************************************** */



/*            P A S S - 1    E R R O R   M E S S A G E S */

/*  ERROR                           MESSAGE */
/*  NUMBER */
/*  ------  ------------------------------------------------------------- */
/*     1    THE SYMBOLS PRINTED BELOW HAVE BEEN USED IN THE CURRENT BLOCK */
/*          BUT DO NOT APPEAR IN A DECLARE STATEMENT, OR LABEL APPEARS IN */
/*          A GO TO STATEMENT BUT DOES NOT APPEAR IN THE BLOCK. */

/*     2    PASS-1 COMPILER SYMBOL TABLE OVERFLOW.  TOO MANY SYMBOLS IN */
/*          THE SOURCE PROGRAM.  EITHER REDUCE THE NUMBER OF VARIABLES IN */
/*          THE PROGRAM, OR RE-COMPILE PASS-1 WITH A LARGER SYMBOL TABLE. */

/*     3    INVALID PL/M STATEMENT.  THE PAIR OF SYMBOLS PRINTED BELOW */
/*          CANNOT APPEAR TOGETHER IN A VALID PL/M STATEMENT (THIS ERROR */
/*          MAY HAVE BEEN CAUSED BE A PREVIOUS ERROR IN THE PROGRAM). */

/*     4    INVALID PL/M STATEMENT.  THE STATEMENT IS IMPROPERLY FORMED-- */
/*          THE PARSE TO THIS POINT FOLLOWS (THIS MAY HAVE OCCURRED BE- */
/*          CAUSE OF A PREVIOUS PROGRAM ERROR). */

/*     5    PASS-1 PARSE STACK OVERFLOW.  THE PROGRAM STATEMENTS ARE */
/*          RECURSIVELY NESTED TOO DEEPLY.  EITHER SIMPLIFY THE PROGRAM */
/*          STRUCTURE, OR RE-COMPILE PASS-1 WITH A LARGER PARSE STACK. */

/*     6    NUMBER CONVERSION ERROR.  THE NUMBER EITHER EXCEEDS 65535 OR */
/*          CONTAINS DIGITS WHICH CONFLICT WITH THE RADIX INDICATOR. */

/*     7    PASS-1 TABLE OVERFLOW.  PROBABLE CAUSE IS A CONSTANT STRING */
/*          WHICH IS TOO LONG.  IF SO, THE STRING SHOULD BE WRITTEN AS A */
/*          SEQUENCE OF SHORTER STRINGS, SEPARATED BY COMMAS.  OTHERWISE, */
/*          RE-COMPILE PASS-1 WITH A LARGER VARC TABLE. */

/*     8    MACRO TABLE OVERFLOW.  TOO MANY LITERALLY DECLARATIONS. */
/*          EITHER REDUCE THE NUMBER OF LITERALLY DECLARATIONS, OR RE- */
/*          COMPILE PASS-1 WITH A LARGER 'MACROS' TABLE. */

/*     9    INVALID CONSTANT IN INITIAL, DATA, OR IN-LINE CONSTANT. */
/*          PRECISION OF CONSTANT EXCEEDS TWO BYTES (MAY BE INTERNAL */
/*          PASS-1 COMPILER ERROR). */

/*    10    INVALID PROGRAM.  PROGRAM SYNTAX INCORRECT FOR TERMINATION */
/*          OF PROGRAM.  MAY BE DUE TO PREVIOUS ERRORS WHICH OCCURRED */
/*          WITHIN THE PROGRAM. */

/*    11    INVALID PLACEMENT OF A PROCEDURE DECLARATION WITHIN THE PL/M */
/*          PROGRAM.  PROCEDURES MAY ONLY BE DECLARED IN THE OUTER BLOCK */
/*          (MAIN PART OF THE PROGRAM) OR WITHIN DO-END GROUPS (NOT */
/*          ITERATIVE DO'S, DO-WHILE'S, OR DO-CASE'S). */

/*    12    IMPROPER USE OF IDENTIFIER FOLLOWING AN END STATEMENT. */
/*          IDENTIFIERS CAN ONLY BE USED IN THIS WAY TO CLOSE A PROCEDURE */
/*          DEFINITION. */

/*    13    IDENTIFIER FOLLOWING AN END STATEMENT DOES NOT MATCH THE NAME */
/*          OF THE PROCEDURE WHICH IT CLOSES. */

/*    14    DUPLICATE FORMAL PARAMETER NAME IN A PROCEDURE HEADING. */

/*    15    IDENTIFIER FOLLOWING AN END STATEMENT CANNOT BE FOUND IN THE */
/*          PROGRAM. */

/*    16    DUPLICATE LABEL DEFINITION AT THE SAME BLOCK LEVEL. */

/*    17    NUMERIC LABEL EXCEEDS CPU ADDRESSING SPACE. */

/*    18    INVALID CALL STATEMENT.  THE NAME FOLLOWING THE CALL IS NOT */
/*          A PROCEDURE. */

/*    19    INVALID DESTINATION IN A GO TO.  THE VALUE MUST BE A LABEL */
/*          OR SIMPLE VARIABLE. */

/*    20    MACRO TABLE OVERFLOW (SEE ERROR 8 ABOVE). */

/*    21    DUPLICATE VARIABLE OR LABEL DEFINITION. */

/*    22    VARIABLE WHICH APPEARS IN A DATA DECLARATION HAS BEEN PRE- */
/*          VIOUSLY DECLARED IN THIS BLOCK */

/*    23    PASS-1 SYMBOL TABLE OVERFLOW (SEE ERROR 2 ABOVE). */

/*    24    INVALID USE OF AN IDENTIFIER AS A VARIABLE NAME. */

/*    25    PASS-1 SYMBOL TABLE OVERFLOW (SEE ERROR 2 ABOVE). */

/*    26    IMPROPERLY FORMED BASED VARIABLE DECLARATION.  THE FORM IS */
/*          I BASED J, WHERE I IS AN IDENTIFIER NOT PREVIOUSLY DECLARED */
/*          IN THIS BLOCK, AND J IS AN ADDRESS VARIABLE. */

/*    27    SYMBOL TABLE OVERFLOW IN PASS-1 (SEE ERROR 2 ABOVE). */

/*    28    INVALID ADDRESS REFERENCE.  THE DOT OPERATOR MAY ONLY */
/*          PRECEDE SIMPLE AND SUBSCRIPTED VARIABLES IN THIS CONTEXT. */

/*    29    UNDECLARED VARIABLE.  THE VARIABLE MUST APPEAR IN A DECLARE */
/*          STATEMENT BEFORE ITS USE. */

/*    30    SUBSCRIPTED VARIABLE OR PROCEDURE CALL REFERENCES AN UN- */
/*          DECLARED IDENTIFIER.  THE VARIABLE OR PROCEDURE MUST BE */
/*          DECLARED BEFORE IT IS USED. */

/*    31    THE IDENTIFIER IS IMPROPERLY USED AS A PROCEDURE OR SUB- */
/*          SCRIPTED VARIABLE. */

/*    32    TOO MANY SUBSCRIPTS IN A SUBSCRIPTED VARIABLE REFERENCE. */
/*          PL/M ALLOWS ONLY ONE SUBSCRIPT. */

/*    33    ITERATIVE DO INDEX IS INVALID. IN THE FORM 'DO I = E1 TO E2' */
/*          THE VARIABLE I MUST BE SIMPLE (UNSUBSCRIPTED). */

/*    34    ATTEMPT TO COMPLEMENT A $ CONTROL TOGGLE WHERE THE TOGGLE */
/*          CURRENTLY HAS A VALUE OTHER THAN 0 OR 1.  USE THE '= N' */
/*          OPTION FOLLOWING THE TOGGLE TO AVOID THIS ERROR. */

/*    35    INPUT FILE NUMBER STACK OVERFLOW.  RE-COMPILE PASS-1 WITH */
/*          A LARGER INSTK TABLE. */

/*    36    TOO MANY BLOCK LEVELS IN THE PL/M PROGRAM.  EITHER SIMPLIFY */
/*          YOUR PROGRAM (30 BLOCK LEVELS ARE CURRENTLY ALLOWED) OR */
/*          RE-COMPILE PASS-1 WITH A LARGER BLOCK TABLE. */

/*     37   THE NUMBER OF ACTUAL PARAMETERS IN THE CALLING SEQUENCE */
/*          IS GREATER THAN THE NUMBER OF FORMAL PARAMETERS DECLARED */
/*          FOR THIS PROCEDURE. */

/*     38   THE NUMBER OF ACTUAL PARAMETERS IN THE CALLING SEQUENCE */
/*          IS LESS THAN THE NUMBER OF FORMAL PARAMETERS DECLARED */
/*          FOR THIS PROCEDURE. */

/*     39   INVALID INTERRUPT NUMBER (MUST BE BETWEEN 0 AND 7) */

/*     40   DUPLICATE INTERRUPT PROCEDURE NUMBER.  A PROCEDURE */
/*          HAS BEEN PREVIOUSLY SPECIFIED WITH AN IDENTICAL */
/*          INTERRUPT ATTRIBUTE. */


/*     41   PROCEDURE APPEARS ON LEFT-HAND-SIDE OF AN ASSIGNMENT. */

/*     42   ATTEMPTED 'CALL' OF A TYPED PROCEDURE. */

/*     43   ATTEMPTED USE OF AN UNTYPED PROCEDURE AS A FUNCTION */
/*          OR A VARIABLE. */


/*     44   THIS PROCEDURE IS UNTYPED AND SHOULD NOT RETURN A VALUE. */

/*     45   THIS PROCEDURE IS TYPED AND SHOULD RETURN A VALUE. */

/*     46   'RETURN' IS INVALID OUTSIDE A PROCEDURE DEFINITION. */

/*     47   ILLEGAL USE OF A LABEL AS AN IDENTIFIER. */

/*  ------  ------------------------------------------------------------- */
/*              I M P L E M E N T A T I O N    N O T E S */
/*              - - - - - - - - - - - - - -    - - - - - */
/*    THE PL/M COMPILER IS INTENDED TO BE WRITTEN IN ANSI STANDARD */
/*    FORTRAN - IV, AND THUS IT SHOULD BE POSSIBLE TO COMPILE AND */
/*    EXECUTE THIS PROGRAM ON ANY MACHINE WHICH SUPPORTS THIS FORTRAN */
/*    STANDARD.  BOTH PASS-1 AND PASS-2, HOWEVER, ASSUME THE HOST */
/*    MACHINE WORD SIZE IS AT LEAST 31 BITS, EXCLUDING THE SIGN BIT */
/*    (I.E., 32 BITS IF THE SIGN IS INCLUDED). */

/*    THE IMPLEMENTOR MAY FIND IT NECESSARY TO CHANGE THE SOURCE PROGRAM */
/*    IN ORDER TO ACCOUNT FOR SYSTEM DEPENDENCIES.  THESE CHANGES ARE */
/*    AS FOLLOWS */

/*    1)   THE FORTRAN LOGICAL UNIT NUMBERS FOR VARIOUS DEVICES */
/*         MAY HAVE TO BE CHANGED IN THE 'GNC' AND 'WRITEL' SUBROU- */
/*         TINES (SEE THE FILE DEFINITIONS BELOW). */

/*     2)   THE HOST MACHINE MAY NOT HAVE THE PL/M 52 CHARACTER SET */
/*           0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ$=./()+-'*,<>:; */
/*         (THE LAST 15 SPECIAL CHARACTERS ARE */
/*         DOLLAR,  EQUAL,  PERIOD,  SLASH, LEFT PAREN, */
/*         RIGHT PAREN, PLUS,   MINUS,  QUOTE, ASTERISK, */
/*         COMMA, LESS-THAN, GREATER-THAN, COLON, SEMI-COLON) */
/*         IN THIS CASE, IT IS NECESSARY TO CHANGE THE 'OTRAN' VECTOR IN */
/*         BLOCK DATA TO A CHARACTER SET WHICH THE HOST MACHINE SUPPORTS */

/*     3)   THE COMPUTED GO TO IN 'SYNTH' MAY BE TOO LONG FOR SOME */
/*         COMPILERS.  IF YOU GET A COMPILATION ERROR, BREAK THE */
/*         'GO TO' INTO TWO SECTIONS. */

/*     4)  THE HOST FORTRAN SYSTEM MAY HAVE A LIMITATION ON THE NUMBER */
/*         OF CONTIGUOUS COMMENT RECORDS (E.G. S/360 LEVEL G). IF SO, */
/*         INTERSPERSE THE DECLARATION STATEMENTS INTEGER I1000, INTEGER */
/*         I1001, ETC., AS NECESSARY TO BREAK UP THE LENGTH OF COMMENTS. */
/*         THE SYMBOLS I1XXX ARE RESERVED FOR THIS PURPOSE. */

/*    THERE ARE A NUMBER OF COMPILER PARAMETERS WHICH MAY HAVE TO */
/*    BE CHANGED FOR YOUR INSTALLATION.  THESE PARAMETERS ARE DEFINED */
/*    BELOW (SEE 'SCANNER COMMANDS'), AND THE CORRESPONDING DEFAULT */
/*    VALUES ARE SET FOLLOWING THEIR DEFINITION.  FOR EXAMPLE, THE */
/*                  $RIGHTMARGIN = I */
/*    PARAMETER DETERMINES THE RIGHT MARGIN OF THE INPUT SOURCE LINE. */
/*    THE PARAMETER IS SET EXTERNALLY BY A SINGLE LINE STARTING WITH */
/*    '$R' IN COLUMNS ONE AND TWO (THE REMAINING CHARACTERS UP TO */
/*    THE '=' ARE IGNORED).  THE INTERNAL COMPILER REPRESENTATION */
/*    OF THE CHARACTER 'R' IS 29 (SEE CHARACTER CODES BELOW), AND THUS */
/*    THE VALUE OF THE $RIGHTMARGIN PARAMETER CORRESPONDS TO ELEMENT 29 */
/*    OF THE 'CONTRL' VECTOR. */

/*     1)  THE PARAMETERS $T, $P, $W, $I, $O, AND $R */
/*        CONTROL THE OPERATING MODE OF PL/M.  FOR BATCH PROCESSING, */
/*        ASSUMING 120 CHARACTER (OR LARGER) PRINT LINE AND 80 CHARAC- */
/*        TER CARD IMAGE, THE PARAMETERS SHOULD DEFAULT AS FOLLOWS */
/*                $TERMINAL   =  0 */
/*                $PRINT      =  1 */
/*                $WIDTH      = 120 */
/*                $INPUT      =  2 */
/*                $OUTPUT     =  2 */
/*                $RIGHTMARGIN= 80 */
/*        NOTE THAT IT MAY BE DESIRABLE TO LEAVE $R=72 TO ALLOW ROOM */
/*        FOR AN 8-DIGIT SEQUENCE NUMBER IN COLUMNS 73-80 OF THE PL/M */
/*        SOURCE CARD. */

/*    2)  FOR INTERACTIVE PROCESSING, ASSUMING A CONSOLE WITH WIDTH */
/*        OF 72 CHARACTERS (E.G., A TTY), THESE PARAMETERS SHOULD */
/*        DEFAULT AS FOLLOWS */
/*                $TERMINAL   =  1 */
/*                $PRINT      =  1 */
/*                $WIDTH      = 72 */
/*                $INPUT      =  1 */
/*                $OUTPUT     =  1 */
/*                $RIGHTMARGIN= 72 */

/*    3)  THE CHARACTERISTICS OF THE INTERMEDIATE LANGUAGE FILES */
/*        PRODUCED BY PASS-1 ARE GOVERNED BY THE $J, $K, $U, $V, AND */
/*        $Y PARAMETERS.  THESE PARAMETERS CORRESPOND TO THE DESTINATION */
/*        AND WIDTH OF THE INTERMEDIATE CODE FILE ($J AND $K), AND */
/*        DESTINATION AND WIDTH OF THE INTERMEDIATE SYMBOL TABLE ($U */
/*        AND $V).  SOME FORTRAN SYSTEMS DELETE THE LEADING CHARACTER */
/*        OF THE FILES PRODUCED BY OTHER FORTRAN PROGRAMS.  THE $Y */
/*        PARAMETER CAN BE USED TO PAD EXTRA BLANKS AT THE BEGINNING OF */
/*        THE INTERMEDIATE FILES IF THIS BECOMES A PROBLEM ON THE HOST */
/*        SYSTEM. */

/*        UNDER NORMAL CIRCUMSTANCES, THESE PARAMETERS WILL NOT */
/*        HAVE TO BE CHANGED.  IN ANY CASE, EXPERIMENT WITH VARIOUS */
/*        VALUES OF THE $ PARAMETERS BY SETTING THEM EXTERNALLY BE- */
/*        FORE ACTUALLY CHANGING THE DEFAULTS. */

/*    THE IMPLEMENTOR MAY ALSO WISH TO INCREASE OR DECREASE THE SIZE */
/*    OF PASS-1 OR PASS-2 TABLES.  THE TABLES IN PASS-1 WHICH MAY BE */
/*    CHANGED IN SIZE ARE 'MACROS' AND 'SYMBOL' WHICH CORRESPOND TO */
/*    THE AREAS WHICH HOLD 'LITERALLY' DEFINITIONS AND PROGRAM SYMBOLS */
/*    AND ATTRIBUTES, RESPECTIVELY.  IT IS IMPOSSIBLE TO PROVIDE AN */
/*    EXACT FORMULA WHICH RELATES THE NUMBER OF SYMBOLS HELD BY EITHER */
/*    OF THESE TABLES TO THE TABLE LENGTH, SINCE TABLE SPACE IS DY- */
/*    NAMICALLY ALLOCATED ACCORDING TO SYMBOL NAME LENGTH AND NUMBER */
/*    OF ATTRIBUTES REQUIRED FOR THE PARTICULAR SYMBOL. */

/*    1)  IN THE CASE OF THE MACROS TABLE, THE LENGTH IS RELATED TO THE */
/*        TOTAL NUMBER OF CHARACTERS IN THE MACRO NAMES PLUS THE TOTAL */
/*        NUMBER OF CHARACTERS IN THE MACRO DEFINITIONS - AT THE DEEP- */
/*        EST BLOCK LEVEL DURING COMPILATION.  TO CHANGE THE MACRO */
/*        TABLE SIZE, ALTER ALL OCCURRENCES OF */

/*                         MACROS(500) */

/*        IN EACH SUBROUTINE TO MACROS(N), WHERE N REPRESENTS THE NEW */
/*        INTEGER CONSTANT SIZE.  IN ADDITION, THE 'DATA' STATEMENT */
/*        BLOCK DATA (LAST PROGRAM SEGMENT) MUST BE CHANGED FOR THE */
/*        MACRO PARAMETERS BASED UPON THE CONSTANT VALUE N TO */

/*           DATA MACROS /N*0/, CURMAC /N+1/, MAXMAC /N/, */
/*          1    MACTOP /1/ */

/*    2)  IF THE IMPLEMENTOR WISHES TO INCREASE OR DECREASE THE SIZE */
/*        OF THE SYMBOL TABLE, THEN ALL OCCURRENCES OF */

/*                          SYMBOL(4000) */

/*        MUST BE CHANGED TO SYMBOL(M), WHERE M IS THE DESIRED INTEGER */
/*        CONSTANT SIZE.  THE 'DATA' STATEMENTS FOR SYMBOL TABLE PARA- */
/*        METERS MUST ALSO BE ALTERED AS DESCRIBED IN THE CORRESPONDING */
/*        COMMENT IN BLOCK DATA.  IN PARTICULAR, THE LAST ITEM  OF */
/*        THE DATA STATEMENT FOR 'SYMBOL' FILLS THE UNINITIALIZED POR- */
/*        TION OF THE TABLE WITH ZEROES, AND HENCE MUST BE THE EVALUATION */
/*        OF THE ELEMENT */
/*                           (M-120)*0 */

/*        (IT IS CURRENTLY (4000-120)*0 = 3880*0).  THE DATA STATEMENT */
/*        FOR MAXSYM AND SYMABS MUST BE CHANGED TO INITIALIZE THESE */
/*        VARIABLES TO THE VALUE M. */

/*    GOOD LUCK... */


/*     F  I  L  E     D  E  F  I  N  I  T  I  O  N  S */
/*            INPUT                        OUTPUT */

/*     FILE   FORTRAN  MTS      DEFAULT    FORTRAN  MTS      DEFAULT */
/*     NUM    I/O UNIT I/O UNIT FDNAME     I/O UNIT I/O UNIT FDNAME */

/*      1        1     GUSER    *MSOURCE*    11     SERCOM   *MSINK* */
/*      2        2     SCARDS   *SOURCE*     12     SPRINT   *SINK* */
/*      3        3     3                     13     13 */
/*      4        4     4                     14     14 */
/*      5        5     5                     15     15 */
/*      6        6     6                     16     16       -PLM16## */
/*      7        7     7                     17     17       -PLM17## */

/*   ALL INPUT RECORDS ARE 80 CHARACTERS OR LESS.  ALL */
/*   OUTPUT RECORDS ARE 120 CHARACTERS OR LESS. */
/*   THE FORTRAN UNIT NUMBERS CAN BE CHANGED IN THE */
/*   SUBROUTINES GNC AND WRITEL (THESE ARE THE ONLY OC- */
/*   CURRENCES OF REFERENCES TO THESE UNITS). */



/*    0 1 2 3 4 5 6 7 8 9 */
/*    0 0 0 0 0 0 0 0 1 1 */
/*    2 3 4 5 6 7 8 9 0 1 */


/*    $ = . / ( ) + - ' * , < > : ; */
/*    3 3 4 4 4 4 4 4 4 4 4 4 5 5 5 */
/*    8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 */


/*    A B C D E F G H I J K L M N O P Q R S T U V W X Y Z */
/*    1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 */
/*    2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 */


/*  SEQNO              SUB/FUNC NAME */
/*  15410000      SUBROUTINE EXITB */
/*  16300000      INTEGER FUNCTION LOOKUP(IV) */
/*  17270000      INTEGER FUNCTION ENTER(INFOV) */
/*  18050000      SUBROUTINE DUMPSY */
/*  20030000      SUBROUTINE RECOV */
/*  20420000      LOGICAL FUNCTION STACK(Q) */
/*  20930000      LOGICAL FUNCTION PROK(PRD) */
/*  21550000      SUBROUTINE REDUCE */
/*  22100000      SUBROUTINE CLOOP */
/*  22740000      SUBROUTINE PRSYM(CC,SYM) */
/*  23120000      INTEGER FUNCTION GETC1(I,J) */
/*  23330000      SUBROUTINE SCAN */
/*  25280000      INTEGER FUNCTION WRDATA(SY) */
/*  26460000      SUBROUTINE DUMPCH */
/*  26960000      SUBROUTINE SYNTH(PROD,SYM) */
/*  36310000      INTEGER FUNCTION GNC(Q) */
/*  37980000      SUBROUTINE WRITEL(NSPACE) */
/*  38520000      FUNCTION ICON(I) */
/*  38710000      SUBROUTINE DECIBP */
/*  38850000      SUBROUTINE CONV(PREC) */
/*  39090000      SUBROUTINE FORM(CC,CHARS,START,FINISH,LENGTH) */
/*  39370000      SUBROUTINE CONOUT(CC,K,N,BASE) */
/*  39690000      SUBROUTINE PAD(CC,CHR,I) */
/*  39800000      SUBROUTINE STACKC(I) */
/*  39950000      SUBROUTINE ENTERB */
/*  40180000      SUBROUTINE DUMPIN */
/*  40880000      SUBROUTINE ERROR(I,LEVEL) */
/*  41320000      INTEGER FUNCTION SHR(I,J) */
/*  41360000      INTEGER FUNCTION SHL(I,J) */
/*  41400000      INTEGER FUNCTION RIGHT(I,J) */
/*  41440000      SUBROUTINE SDUMP */
/*  41670000      SUBROUTINE REDPR(PROD,SYM) */
/*  41900000      SUBROUTINE EMIT(VAL,TYP) */

/* *********************************************************************** */

/* Main program */ int MAIN__(void)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer i__, j, k;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), scan_(
	    void);
    extern integer icon_(integer *);
    extern /* Subroutine */ int emit_(integer *, integer *), form_(integer *, 
	    integer *, integer *, integer *, integer *), cloop_(void), 
	    dumpch_(void), dumpin_(void), conout_(integer *, integer *, 
	    integer *, integer *), writel_(integer *), dumpsy_(void);


/*     SYNTAX ANALYZER TABLES */
/*      GLOBAL TABLES */
/*     GLOBAL VARIABLES */
/*     THE FOLLOWING SCANNER COMMANDS ARE DEFINED */
/*     ANALYZE = I      (12)  PRINT SYNTAX ANALYSIS TRACE */
/*     BYPASS           (13)  BYPASS STACK DUMP ON ERROR */
/*     COUNT = I        (14)  BEGIN LINE COUNT AT I */
/*     DELETE = I       (15) */
/*     EOF              (16) */
/*     GENERATE         (18) */
/*     INPUT = I        (20) */
/*     JFILE (CODE)= I  (21) */
/*     KWIDTH (CD)= I   (22) */
/*     LEFTMARGIN = I   (23) */
/*     MEMORY = I       (24) */
/*     OUTPUT = I       (26) */
/*     PRINT (T OR F)   (27) */
/*     RIGHTMARG = I    (29) */
/*     SYMBOLS          (30) */
/*     TERMINAL         (31) (0=BATCH, 1=TERM, 2=INTERLIST) */
/*     USYMBOL = I      (32) */
/*     VWIDTH (SYM) = I (33) */
/*     WIDTH = I        (34) */
/*     YPAD = N         (36)  BLANK PAD ON OUTPUT */
/*     CONTRL(1) IS THE ERROR COUNT */
    for (i__ = 1; i__ <= 64; ++i__) {
/* L2: */
	cntrl_1.contrl[i__ - 1] = -1;
    }
    cntrl_1.contrl[0] = 0;
    cntrl_1.contrl[11] = 0;
    cntrl_1.contrl[12] = 1;
    cntrl_1.contrl[13] = 0;
    cntrl_1.contrl[14] = 120;
    cntrl_1.contrl[15] = 0;
    cntrl_1.contrl[17] = 0;
    cntrl_1.contrl[19] = 2;
    cntrl_1.contrl[20] = 6;
    cntrl_1.contrl[21] = 72;
    cntrl_1.contrl[22] = 1;
    cntrl_1.contrl[23] = 1;
    cntrl_1.contrl[25] = 2;
    cntrl_1.contrl[26] = 1;
    cntrl_1.contrl[28] = 80;
    cntrl_1.contrl[29] = 0;
    cntrl_1.contrl[30] = 1;
    cntrl_1.contrl[31] = 7;
    cntrl_1.contrl[32] = 72;
    cntrl_1.contrl[33] = 120;
    cntrl_1.contrl[35] = 1;

    for (i__ = 1; i__ <= 5; ++i__) {
/* L4: */
	i__1 = (i__ << 3) - 8;
	stacks_1.prmask[i__ - 1] = pow_ii(&c__2, &i__1) - 1;
    }
    for (i__ = 1; i__ <= 256; ++i__) {
	files_1.itran[i__ - 1] = 1;
/* L8: */
    }

    for (i__ = 53; i__ <= 64; ++i__) {
	files_1.otran[i__ - 1] = files_1.otran[0];
/* L5: */
    }

    for (i__ = 1; i__ <= 52; ++i__) {
	j = files_1.otran[i__ - 1];
	j = icon_(&j);
/* L10: */
	files_1.itran[j - 1] = i__;
    }
    conout_(&c__0, &c__4, &c__8080, &c__10);
    pad_(&c__1, &c__1, &c__1);
    form_(&c__1, titl_1.title, &c__1, &c__10, &c__10);
    i__1 = titl_1.vers / 10;
    conout_(&c__1, &c__1, &i__1, &c__10);
    pad_(&c__1, &c__40, &c__1);
    i__1 = titl_1.vers % 10;
    conout_(&c__1, &c__1, &i__1, &c__10);
    writel_(&c__1);
    for (i__ = 1; i__ <= 3; ++i__) {
/* L20: */
	stacks_1.pstack[i__ - 1] = 0;
    }
    stacks_1.pstack[3] = syntax_1.eofile;
    stacks_1.sp = 4;
    scan_();
    cloop_();
    emit_(&opcod_1.nop, &opcod_1.opr);
L100:
    if (pole_1.poltop == 0) {
	goto L200;
    }
    emit_(&opcod_1.nop, &opcod_1.opr);
    goto L100;
L200:
/*     PRINT ERROR COUNT */
    i__ = cntrl_1.contrl[0];
    j = cntrl_1.contrl[25];
    k = j;
L300:
    writel_(&c__0);
    cntrl_1.contrl[25] = j;
    if (i__ == 0) {
	form_(&c__0, messag_1.mssg, &c__6, &c__7, &c__41);
    }
    if (i__ != 0) {
	conout_(&c__2, &c_n5, &i__, &c__10);
    }
    pad_(&c__1, &c__1, &c__1);
    form_(&c__1, messag_1.mssg, &c__8, &c__20, &c__41);
    if (i__ != 1) {
	pad_(&c__1, &c__30, &c__1);
    }
    pad_(&c__0, &c__1, &c__1);
    writel_(&c__0);
/*     CHECK FOR TERMINAL CONTROL OF A BATCH RUN */
    if (j == 1 || cntrl_1.contrl[30] == 0) {
	goto L400;
    }
/*     ARRIVE HERE IF TERMINAL TOGGLE GT 0, AND OUTPUT NOT CONSOLE */
    j = 1;
    goto L300;
L400:
    cntrl_1.contrl[25] = k;
    dumpsy_();
/*     MAY WANT A SYMBOL TABLE FOR THE SIMULATOR */
    if (cntrl_1.contrl[23] == 0) {
	sym_1.symbol[1] = 0;
    }
    dumpch_();
    dumpin_();
    s_stop("", (ftnlen)0);
    return 0;
} /* MAIN__ */

/* Subroutine */ int exitb_(void)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, n, jp, kp, lp, np;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer shr_(integer *, integer *);
    static logical erred;
    extern integer right_(integer *, integer *);
    static integer ltemp;
    extern /* Subroutine */ int error_(integer *, integer *), writel_(integer 
	    *);

/*     GOES THROUGH HERE UPON BLOCK EXIT */
/*      GLOBAL TABLES */
    erred = FALSE_;
    if (blk_1.curblk <= 0) {
	goto L9999;
    }
    i__ = blk_1.block[blk_1.curblk - 1];
    n = blk_1.macblk[blk_1.curblk - 1];
    macro_1.curmac = right_(&n, &c__12);
    macro_1.mactop = shr_(&n, &c__12);
    --blk_1.curblk;
    j = sym_1.symbol[sym_1.symtop - 1];
L100:
    if (j < i__) {
	goto L300;
    }
    if (sym_1.symbol[j] < 0) {
	goto L200;
    }
    k = (i__1 = sym_1.symbol[j + 1], abs(i__1));
    kp = right_(&k, &c__4);
    lp = shr_(&kp, &c__8);
    if (kp >= types_1.liter) {
	goto L200;
    }
    if (kp != types_1.varb && kp != types_1.label) {
	goto L150;
    }
    i__1 = shr_(&k, &c__4);
    k = right_(&i__1, &c__4);
    if (k != 0) {
	goto L150;
    }
    if (kp == types_1.label && blk_1.curblk > 1) {
	goto L200;
    }
    if (erred) {
	goto L130;
    }
    error_(&c__1, &c__1);
    erred = TRUE_;
L130:
    pad_(&c__0, &c__1, &c__5);
    n = sym_1.symbol[j];
    n = shr_(&n, &c__12);
    if (n == 0) {
	goto L150;
    }
    i__1 = n;
    for (kp = 1; kp <= i__1; ++kp) {
	ltemp = j + 2 + kp;
	l = sym_1.symbol[ltemp - 1];
	i__2 = syntax_1.pack;
	for (lp = 1; lp <= i__2; ++lp) {
	    jp = 30 - lp * 6;
	    i__3 = shr_(&l, &jp);
	    jp = right_(&i__3, &c__6) + 1;
	    pad_(&c__1, &jp, &c__1);
/* L120: */
	}
    }
    writel_(&c__0);
L150:
    sym_1.symbol[j] = -sym_1.symbol[j];
/*         MAY WANT TO FIX THE HASH CODE CHAIN */
    if (lp <= 0) {
	goto L200;
    }
/*         FIND MATCH ON THE ENTRY */
    k = j - 1;
    kp = sym_1.symbol[k - 1];
    hash_1.hcode = shr_(&kp, &c__16);
    kp = right_(&kp, &c__16);
    n = hash_1.hentry[hash_1.hcode - 1];
    if (n != k) {
	goto L160;
    }

/*         THIS ENTRY IS DIRECTLY CONNECTED */
    hash_1.hentry[hash_1.hcode - 1] = kp;
    goto L200;

/*         LOOK THROUGH SOME LITERALS IN THE SYMBOL TABLE ABOVE */
L160:
    np = right_(&sym_1.symbol[n - 1], &c__16);
    if (np == k) {
	goto L170;
    }
    n = np;
    goto L160;

L170:
    sym_1.symbol[n - 1] = shr_(&hash_1.hcode, &c__16) + kp;

L200:
    j = right_(&sym_1.symbol[j - 1], &c__16);
    goto L100;
L300:
    blk_1.blksym = blk_1.block[blk_1.curblk - 1];
L9999:
    return 0;
} /* exitb_ */

integer lookup_(integer *iv)
{
    /* System generated locals */
    integer ret_val, i__1;

    /* Local variables */
#define i__ ((integer *)&sym_1 + 4002)
    static integer j, k;
#define l ((integer *)&sym_1 + 4003)
    static integer m, jp, kp, lp;
    extern integer shl_(integer *, integer *), shr_(integer *, integer *);
    static integer nval;
    static logical sflag;
    extern integer right_(integer *, integer *);
    static integer ltemp;

/*     SYNTAX ANALYZER TABLES */
/*      GLOBAL TABLES */
    nval = stacks_1.fixv[*iv - 1];
    sflag = stacks_1.pstack[*iv - 1] != syntax_1.numbv;
    *i__ = stacks_1.var[*iv - 1];
    *l = shr_(i__, &c__12);
    *i__ = right_(i__, &c__12);
    j = *i__;
    kp = syntax_1.pack * 6;
    k = kp;
    jp = 0;
    m = 0;
L100:
    if (jp >= *l) {
	goto L300;
    }
    k += -6;
    if (k >= 0) {
	goto L200;
    }
    stacks_1.varc[j - 1] = m;
    ++j;
    m = 0;
    k = kp - 6;
L200:
    ltemp = jp + *i__;
    i__1 = stacks_1.varc[ltemp - 1] - 1;
    m = shl_(&i__1, &k) + m;
    ++jp;
    goto L100;
L300:
    stacks_1.varc[j - 1] = m;
/*     VARC IS NOW IN PACKED FORM READY FOR LOOKUP */
/*     COMPUTE HASH CODE (REDUCE NUMBERS MOD 127, USE FIRST 5 CHARS OF */
/*     IDENTIFIERS AND STRINGS ) */
    hash_1.hcode = nval;
    if (sflag) {
	hash_1.hcode = stacks_1.varc[*i__ - 1];
    }
    hash_1.hcode = hash_1.hcode % 127 + 1;
/*     HCODE IS IN THE RANGE 1 TO 127 */
    lp = (*l - 1) / syntax_1.pack + 1;
    k = hash_1.hentry[hash_1.hcode - 1];
L400:
    if (k <= 0) {
	goto L9990;
    }
    if (sflag) {
	goto L450;
    }
/*     COMPARE NUMBERS IN INTERNAL FORM RATHER THAN CHARACTERS */
    j = sym_1.symbol[k + 2];
    if (right_(&j, &c__4) <= types_1.liter) {
	goto L600;
    }
    j = shr_(&j, &c__8);
    if (j == nval) {
	goto L510;
    }
    goto L600;
L450:
    j = sym_1.symbol[k + 1];
    jp = right_(&j, &c__12);
    if (jp != *l) {
	goto L600;
    }
    j = k + 3;
    jp = *i__;
    i__1 = lp;
    for (m = 1; m <= i__1; ++m) {
	ltemp = j + m;
	if (stacks_1.varc[jp - 1] != sym_1.symbol[ltemp - 1]) {
	    goto L600;
	}
/* L500: */
	++jp;
    }
/*     SYMBOL FOUND */

/*     MAKE SURE THE TYPES MATCH. */
    jp = stacks_1.pstack[*iv - 1];
    m = sym_1.symbol[k + 2];
    m = right_(&m, &c__4);
    if (jp == syntax_1.strv && m == types_1.liter) {
	goto L510;
    }
    if (jp != syntax_1.identv || m >= types_1.liter) {
	goto L600;
    }
/*     JP IS IDENTIFIER, M IS VARIABLE, LABEL, OR PROCEDURE. */
L510:
    ret_val = k + 2;
    return ret_val;
L600:
    k = sym_1.symbol[k - 1];
    k = right_(&k, &c__16);
    goto L400;
L9990:
    ret_val = 0;
    return ret_val;
} /* lookup_ */

#undef l
#undef i__


integer enter_(integer *infov)
{
    /* System generated locals */
    integer ret_val, i__1;

    /* Local variables */
    static integer i__, j, l, q, ip, iq;
    extern integer shl_(integer *, integer *);
    static integer info, ihash, ltemp;
    extern /* Subroutine */ int error_(integer *, integer *);
    static integer ltemp1;

/*     SYNTAX ANALYZER TABLES */

/*      GLOBAL TABLES */
/*      ENTER ASSUMES A PREVIOUS CALL TO LOOKUP (EITHER THAT, OR SET UP */
/*      THE VALUES OF SYMLOC AND SYMLEN IN THE VARC ARRAY). */
/*         ALSO SET-UP HASH CODE VALUE (SEE LOOKUP), IF NECESSARY */
    info = *infov;
    i__ = sym_1.symtop;
    if (info >= 0) {
	goto L10;
    }
/*     ENTRY WITH NO EXTERNAL NAME */
    ihash = 0;
    hash_1.hcode = 0;
    info = -info;
    sym_1.symlen = 0;
    q = 0;
    goto L20;

L10:
    ihash = 1;
    q = (sym_1.symlen - 1) / syntax_1.pack + 1;

L20:
    sym_1.symtop = sym_1.symtop + q + ihash + 3;
    iq = i__;
    i__ += ihash;

    if (sym_1.symtop <= sym_1.maxsym) {
	goto L100;
    }
    i__ = ihash;
    sym_1.symtop = q + ihash + 3;
    error_(&c__2, &c__5);
L100:
    sym_1.symbol[sym_1.symtop - 1] = i__;
    ++sym_1.symcnt;
    sym_1.symbol[i__ - 1] = shl_(&sym_1.symcnt, &c__16) + sym_1.symbol[iq - 1]
	    ;
    ++i__;
    sym_1.symbol[i__ - 1] = shl_(&q, &c__12) + sym_1.symlen;
    ip = i__ + 1;
    sym_1.symbol[ip - 1] = info;
    l = sym_1.symloc - 1;
    if (q == 0) {
	goto L210;
    }
    i__1 = q;
    for (j = 1; j <= i__1; ++j) {
	ltemp = ip + j;
	ltemp1 = l + j;
/* L200: */
	sym_1.symbol[ltemp - 1] = stacks_1.varc[ltemp1 - 1];
    }
L210:
    ret_val = i__;

/*     COMPUTE HASH TABLE ENTRY */
    if (ihash == 0) {
	goto L300;
    }
/*     FIX COLLISION CHAIN */
    sym_1.symbol[iq - 1] = shl_(&hash_1.hcode, &c__16) + hash_1.hentry[
	    hash_1.hcode - 1];
    hash_1.hentry[hash_1.hcode - 1] = iq;
L300:
    return ret_val;
} /* enter_ */

/* Subroutine */ int dumpsy_(void)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, m, n, ic, mc, ip, jp, kp, lp, it;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer shr_(integer *, integer *);
    static integer ifin;
    extern /* Subroutine */ int form_(integer *, integer *, integer *, 
	    integer *, integer *);
    extern integer right_(integer *, integer *);
    static integer ltemp;
    extern /* Subroutine */ int writel_(integer *), conout_(integer *, 
	    integer *, integer *, integer *);

/*      GLOBAL TABLES */
    ic = cntrl_1.contrl[29];
    if (ic == 0) {
	goto L2000;
    }
    writel_(&c__0);
    if (ic > 1) {
	form_(&c__0, messag_1.mssg, &c__42, &c__77, &c__77);
    }
    i__ = sym_1.symbol[sym_1.symtop - 1];
    it = sym_1.symtop;
L210:
    if (i__ <= 0) {
	goto L1000;
    }
    k = sym_1.symbol[i__ - 1];
    kp = shr_(&k, &c__16);
/*     QUICK CHECK FOR ZERO LENGTH NAME */
    if (ic >= 2) {
	goto L215;
    }
    n = (i__1 = sym_1.symbol[i__], abs(i__1));
    if (shr_(&n, &c__12) == 0) {
	goto L218;
    }
L215:
    pad_(&c__0, &c__30, &c__1);
    conout_(&c__1, &c__5, &kp, &c__10);
L218:
    k = sym_1.symbol[i__];
    if (ic < 2) {
	goto L220;
    }
    j = 1;
    if (k < 0) {
	j = 47;
    }
    pad_(&c__1, &j, &c__1);
    pad_(&c__1, &c__1, &c__1);
L220:
    k = abs(k);
    kp = shr_(&k, &c__12);
    n = kp;
    k = right_(&k, &c__12);
    mc = k;
    if (ic < 2) {
	goto L230;
    }
    i__1 = i__ + 1;
    conout_(&c__1, &c__4, &i__1, &c__10);
    pad_(&c__1, &c__1, &c__1);
    conout_(&c__1, &c_n3, &kp, &c__10);
    pad_(&c__1, &c__1, &c__1);
    conout_(&c__1, &c_n4, &k, &c__10);
    pad_(&c__1, &c__1, &c__1);
L230:
    k = sym_1.symbol[i__ + 1];
    j = 29;
    if (ic < 2) {
	goto L240;
    }
    if (k < 0) {
	j = 13;
    }
    pad_(&c__1, &j, &c__1);
    pad_(&c__1, &c__1, &c__1);
L240:
    k = abs(k);
    m = right_(&k, &c__4);
    if (ic < 2) {
	goto L250;
    }
    kp = shr_(&k, &c__8);
    conout_(&c__1, &c__6, &kp, &c__10);
    i__1 = shr_(&k, &c__4);
    kp = right_(&i__1, &c__4);
    conout_(&c__1, &c_n3, &kp, &c__10);
    kp = right_(&k, &c__4);
    conout_(&c__1, &c_n3, &kp, &c__10);
L250:
    pad_(&c__1, &c__1, &c__1);
    ip = i__ + 2;
    if (n == 0) {
	goto L310;
    }
    if (m == types_1.liter) {
	pad_(&c__1, &c__46, &c__1);
    }
    i__1 = n;
    for (kp = 1; kp <= i__1; ++kp) {
	ltemp = kp + ip;
	l = sym_1.symbol[ltemp - 1];
	i__2 = syntax_1.pack;
	for (lp = 1; lp <= i__2; ++lp) {
	    if ((kp - 1) * syntax_1.pack + lp > mc) {
		goto L305;
	    }
	    jp = 30 - lp * 6;
	    i__3 = shr_(&l, &jp);
	    jp = right_(&i__3, &c__6) + 1;
	    pad_(&c__1, &jp, &c__1);
/* L300: */
	}
    }
L305:
    if (m == types_1.liter) {
	pad_(&c__1, &c__46, &c__1);
    }
L310:
    ip += n;
    if (ic < 2) {
	goto L330;
    }
L320:
    ++ip;
    if (ip >= it) {
	goto L330;
    }
    pad_(&c__1, &c__1, &c__1);
    k = sym_1.symbol[ip - 1];
    j = 1;
    if (k < 0) {
	j = 45;
    }
    pad_(&c__1, &j, &c__1);
    k = abs(k);
    conout_(&c__1, &c__8, &k, &c__16);
    goto L320;
L330:
    it = i__;
    i__ = right_(&sym_1.symbol[i__ - 1], &c__16);
    goto L210;
L1000:
    writel_(&c__0);
L2000:
    writel_(&c__0);
    k = cntrl_1.contrl[25];
    cntrl_1.contrl[25] = cntrl_1.contrl[31];
    kp = cntrl_1.contrl[33];
    cntrl_1.contrl[33] = cntrl_1.contrl[32];
/*     WRITE THE INTERRUPT PROCEDURE NAMES */
    pad_(&c__1, &c__41, &c__1);
    for (i__ = 1; i__ <= 8; ++i__) {
	j = inter_1.intpro[i__ - 1];
	if (j <= 0) {
	    goto L2050;
	}
/*         WRITE INTNUMBER SYMBOLNUM (4 BASE-32 DIGITS) */
	i__2 = i__ + 1;
	pad_(&c__1, &i__2, &c__1);
	for (l = 1; l <= 3; ++l) {
	    i__2 = right_(&j, &c__5) + 2;
	    pad_(&c__1, &i__2, &c__1);
/* L2020: */
	    j = shr_(&j, &c__5);
	}
	pad_(&c__1, &c__41, &c__1);
L2050:
	;
    }
    pad_(&c__1, &c__41, &c__1);
    writel_(&c__0);


/*     REVERSE THE SYMBOL TABLE POINTERS */
/*     SET THE LENGTH FIELD OF COMPILER-GENERATED LABELS TO 1 */

    l = 0;
    i__ = sym_1.symtop;
    j = sym_1.symbol[i__ - 1];
    sym_1.symbol[i__ - 1] = 0;
L2100:
    if (j == 0) {
	goto L2200;
    }
    ++l;
/*     CHECK FOR A LABEL VARIABLE */
    k = sym_1.symbol[j + 1];
    if (k % 16 != types_1.label) {
	goto L2110;
    }
/*     CHECK FOR CHARACTER LENGTH = 0 */
    k = (i__2 = sym_1.symbol[j], abs(i__2));
    if (k % 4096 != 0) {
	goto L2110;
    }
/*     SET LENGTH TO 1 AND PREC TO 5 (FOR COMP GENERATED LABELS) */
    sym_1.symbol[j + 1] = types_1.label + 336;
/*         336 = 1 * 256 + 5 * 16 */
L2110:
    m = sym_1.symbol[j - 1];
    sym_1.symbol[j - 1] = i__;
    i__ = j;
    j = right_(&m, &c__16);
    goto L2100;

L2200:
    jp = 0;
    ifin = 1;
    ip = 1;
    j = 1;

L2500:
    if (j != jp) {
	goto L2610;
    }
    j += ip;
L2610:
    if (j < ifin) {
	goto L2700;
    }
/*     OTHERWISE GET ANOTHER ENTRY FROM TABLE */
    pad_(&c__1, &c__41, &c__1);
    j = i__ + 1;
    i__ = sym_1.symbol[i__ - 1];
    if (i__ == 0) {
	goto L2800;
    }
    ip = (i__2 = sym_1.symbol[j - 1], abs(i__2));
    i__2 = shr_(&ip, &c__12);
    ip = right_(&i__2, &c__12);
    ++j;
    jp = j + 1;
/*         CHECK FOR BASED VARIABLE -- COMPUTE LAST ENTRY */
    ifin = jp + ip;
    if (sym_1.symbol[j - 1] < 0) {
	++ifin;
    }
    goto L2500;
L2700:
    l = 1;
    lp = sym_1.symbol[j - 1];
    if (lp < 0) {
	l = 45;
    }
    lp = abs(lp);
    pad_(&c__1, &l, &c__1);
L2710:
    i__2 = right_(&lp, &c__5) + 2;
    pad_(&c__1, &i__2, &c__1);
    lp = shr_(&lp, &c__5);
    if (lp > 0) {
	goto L2710;
    }
    ++j;
    goto L2500;

L2800:
    pad_(&c__1, &c__41, &c__1);
    writel_(&c__0);
    cntrl_1.contrl[25] = k;
    cntrl_1.contrl[33] = kp;
    return 0;
} /* dumpsy_ */

/* Subroutine */ int recov_(void)
{
    static integer i__;
    extern /* Subroutine */ int scan_(void);
    extern integer getc1_(integer *, integer *), right_(integer *, integer *);

/*      GLOBAL TABLES */
/*     FIND SOMETHING SOLID IN THE TEXT */
L100:
    if (syntax_1.token == syntax_1.decl || syntax_1.token == syntax_1.procv ||
	     syntax_1.token == syntax_1.endv || syntax_1.token == 
	    syntax_1.dov || syntax_1.token == syntax_1.semiv || 
	    syntax_1.token == syntax_1.eofile) {
	goto L300;
    }
L200:
    scan_();
    goto L100;
/*     AND IN THE STACK */
L300:
    i__ = stacks_1.pstack[stacks_1.sp - 1];
    if (stacks_1.failsf && getc1_(&i__, &syntax_1.token) != 0) {
	goto L500;
    }
    if (i__ == syntax_1.eofile && syntax_1.token == syntax_1.eofile) {
	goto L400;
    }
    if ((i__ == syntax_1.groupv || i__ == syntax_1.slistv || i__ == 
	    syntax_1.stmtv || i__ == syntax_1.dov || i__ == syntax_1.procv) &&
	     syntax_1.token != syntax_1.eofile) {
	goto L200;
    }
/*         BUT DON'T GO TOO FAR */
    if (stacks_1.sp <= 4) {
	goto L200;
    }
    stacks_1.vartop = right_(&stacks_1.var[stacks_1.sp - 1], &c__12);
    --stacks_1.sp;
    goto L300;
L400:
    stacks_1.compil = FALSE_;
L500:
    stacks_1.failsf = FALSE_;
    return 0;
} /* recov_ */

logical stack_(integer *q)
{
    /* System generated locals */
    integer i__1;
    logical ret_val;

    /* Local variables */
    static integer i__, j, k, il, jp, iu;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer shl_(integer *, integer *), shr_(integer *, integer *), 
	    getc1_(integer *, integer *);
    extern /* Subroutine */ int recov_(void), error_(integer *, integer *), 
	    sdump_(void), prsym_(integer *, integer *);

/*      GLOBAL TABLES */
L100:
    i__ = getc1_(&stacks_1.pstack[stacks_1.sp - 1], &syntax_1.token) + 1;
    switch (i__) {
	case 1:  goto L1000;
	case 2:  goto L2000;
	case 3:  goto L3000;
	case 4:  goto L4000;
    }
/*     ILLEGAL SYMBOL PAIR */
L1000:
    error_(&c__3, &c__1);
    prsym_(&c__0, &stacks_1.pstack[stacks_1.sp - 1]);
    pad_(&c__1, &c__1, &c__1);
    prsym_(&c__1, &syntax_1.token);
    sdump_();
    recov_();
/*     RECOVER MAY HAVE SET COMPILING FALSE */
    if (! stacks_1.compil) {
	goto L2000;
    }
    goto L100;
/*     RETURN TRUE */
L2000:
    ret_val = TRUE_;
    goto L9999;
/*     RETURN FALSE */
L3000:
    ret_val = FALSE_;
    goto L9999;
/*     CHECK TRIPLES */
L4000:
    j = shl_(&stacks_1.pstack[stacks_1.sp - 2], &c__16) + shl_(&
	    stacks_1.pstack[stacks_1.sp - 1], &c__8) + syntax_1.token;
    iu = syntax_1.nc1tri + 2;
    il = 1;
L4100:
    i__1 = iu + il;
    k = shr_(&i__1, &c__1);
    jp = syntax_1.c1tri[k - 1];
    if (j < jp) {
	iu = k;
    }
    if (j >= jp) {
	il = k;
    }
    if (iu - il > 1) {
	goto L4100;
    }
/*     CHECK FOR MATCH */
    ret_val = j == syntax_1.c1tri[il - 1];
L9999:
    return ret_val;
} /* stack_ */

logical prok_(integer *prd)
{
    /* System generated locals */
    integer i__1;
    logical ret_val;

    /* Local variables */
    static integer i__, j, k, l, lp;
    extern integer shl_(integer *, integer *), getc1_(integer *, integer *);
    static integer ltemp;

/*      GLOBAL TABLES */
/*      CONTEXT CHECK OF EQUAL OR IMBEDDED RIGHT PARTS */
    i__ = syntax_1.contc[*prd - 1] + 1;
    switch (i__) {
	case 1:  goto L1000;
	case 2:  goto L2000;
	case 3:  goto L3000;
	case 4:  goto L4000;
    }
/*     NO CHECK REQUIRED */
L1000:
    ret_val = TRUE_;
    goto L9999;
/*     RIGHT CONTEXT CHECK */
L2000:
    ret_val = getc1_(&syntax_1.hdtb[*prd - 1], &syntax_1.token) != 0;
    goto L9999;
/*     LEFT CONTEXT CHECK */
L3000:
    k = syntax_1.hdtb[*prd - 1] - syntax_1.nt;
    l = syntax_1.prlen[*prd - 1];
    ltemp = stacks_1.sp - l;
    i__ = stacks_1.pstack[ltemp - 1];
    l = syntax_1.lefti[k - 1] + 1;
    lp = syntax_1.lefti[k];
    if (l > lp) {
	goto L3200;
    }
    i__1 = lp;
    for (j = l; j <= i__1; ++j) {
	if (syntax_1.leftc[j - 1] != i__) {
	    goto L3100;
	}
	ret_val = TRUE_;
	goto L9999;
L3100:
	;
    }
L3200:

    ret_val = FALSE_;
    goto L9999;
/*     CHECK TRIPLES */
L4000:
    k = syntax_1.hdtb[*prd - 1] - syntax_1.nt;
    l = syntax_1.prlen[*prd - 1];
    ltemp = stacks_1.sp - l;
    i__ = shl_(&stacks_1.pstack[ltemp - 1], &c__8) + syntax_1.token;
    l = syntax_1.tripi[k - 1] + 1;
    lp = syntax_1.tripi[k];
    if (l < lp) {
	goto L4200;
    }
    i__1 = lp;
    for (j = l; j <= i__1; ++j) {
	if (syntax_1.contt[j - 1] != i__) {
	    goto L4100;
	}
	ret_val = TRUE_;
	goto L9999;
L4100:
	;
    }
L4200:
    ret_val = FALSE_;
L9999:
    return ret_val;
} /* prok_ */

/* Subroutine */ int reduce_(void)
{
    /* System generated locals */
    integer i__1;
    static integer equiv_0[1], equiv_1[1];

    /* Local variables */
    static integer i__;
#define j (equiv_0)
    static integer k, l;
#define m (equiv_1)
#define jl ((logical *)equiv_0)
#define ml ((logical *)equiv_1)
    static integer prd;
    extern integer shl_(integer *, integer *);
    extern logical prok_(integer *);
    extern integer right_(integer *, integer *);
    extern /* Subroutine */ int recov_(void);
    static integer ltemp;
    extern /* Subroutine */ int error_(integer *, integer *), sdump_(void), 
	    synth_(integer *, integer *);

/*      GLOBAL TABLES */
/*     PACK STACK TOP */
    k = stacks_1.sp - 4;
    l = stacks_1.sp - 1;
    *j = 0;
    i__1 = l;
    for (i__ = k; i__ <= i__1; ++i__) {
/* L100: */
	*j = shl_(j, &c__8) + stacks_1.pstack[i__ - 1];
    }
    ltemp = stacks_1.pstack[stacks_1.sp - 1];
    k = syntax_1.prind[ltemp - 1] + 1;
    l = syntax_1.prind[ltemp];

    i__1 = l;
    for (prd = k; prd <= i__1; ++prd) {
	*m = syntax_1.prlen[prd - 1];
	*m = *m - 1 << 3;
	*m = right_(j, m);
	if (*m != syntax_1.prtb[prd - 1]) {
	    goto L200;
	}
	if (! prok_(&prd)) {
	    goto L200;
	}
	stacks_1.mp = stacks_1.sp - syntax_1.prlen[prd - 1] + 1;
	stacks_1.mpp1 = stacks_1.mp + 1;
	*j = syntax_1.hdtb[prd - 1];
	synth_(&syntax_1.prdtb[prd - 1], j);
	stacks_1.sp = stacks_1.mp;
	stacks_1.pstack[stacks_1.sp - 1] = *j;
	stacks_1.vartop = right_(&stacks_1.var[stacks_1.sp - 1], &c__12);
	goto L9999;

L200:
	;
    }
/* L300: */
/*     NO APPLICABLE PRODUCTION */
    error_(&c__4, &c__1);
    stacks_1.failsf = FALSE_;
    sdump_();
    recov_();
L9999:
    return 0;
} /* reduce_ */

#undef ml
#undef jl
#undef m
#undef j


/* Subroutine */ int cloop_(void)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j;
    extern integer shl_(integer *, integer *);
    extern /* Subroutine */ int scan_(void), conv_(integer *);
    extern logical stack_(integer *);
    extern /* Subroutine */ int error_(integer *, integer *), reduce_(void);

/*      GLOBAL TABLES */
    stacks_1.compil = TRUE_;
L100:
    if (! stacks_1.compil) {
	goto L9999;
    }
    if (! stack_(&c__0)) {
	goto L400;
    }
/*     STACK MAY HAVE SET COMPILING FALSE */
    if (! stacks_1.compil) {
	goto L9999;
    }
    ++stacks_1.sp;
    if (stacks_1.sp < stacks_1.mstack) {
	goto L300;
    }
    error_(&c__5, &c__5);
    goto L9999;
L300:
    stacks_1.pstack[stacks_1.sp - 1] = syntax_1.token;
/*     INSERT ACCUM INTO VARC HERE */
    if (syntax_1.token != syntax_1.numbv) {
	goto L302;
    }
    conv_(&c__16);
    if (scanc_1.value >= 0) {
	goto L301;
    }
    error_(&c__6, &c__1);
    scanc_1.value = 0;
L301:
    stacks_1.fixv[stacks_1.sp - 1] = scanc_1.value;
L302:
    stacks_1.var[stacks_1.sp - 1] = stacks_1.vartop;
L305:
    if (scanc_1.acclen == 0) {
	goto L315;
    }
    i__1 = scanc_1.acclen;
    for (j = 1; j <= i__1; ++j) {
	stacks_1.varc[stacks_1.vartop - 1] = scanc_1.accum[j - 1];
	++stacks_1.vartop;
	if (stacks_1.vartop <= stacks_1.mvar) {
	    goto L310;
	}
	error_(&c__7, &c__5);
	stacks_1.vartop = 1;
L310:
	;
    }
L315:
    if (syntax_1.token != syntax_1.strv) {
	goto L360;
    }
    if (scanc_1.stype != scanc_1.cont) {
	goto L360;
    }
    scan_();
    goto L305;
L360:
    i__ = stacks_1.vartop - stacks_1.var[stacks_1.sp - 1];
    if (i__ < 0) {
	i__ = 1;
    }
    stacks_1.var[stacks_1.sp - 1] = shl_(&i__, &c__12) + stacks_1.var[
	    stacks_1.sp - 1];
    scan_();
    goto L100;
L400:
    reduce_();
    goto L100;
L9999:
    return 0;
} /* cloop_ */

/* Subroutine */ int prsym_(integer *cc, integer *sym)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, ip, jp, kp, lp;
    extern integer shr_(integer *, integer *);
    extern /* Subroutine */ int form_(integer *, integer *, integer *, 
	    integer *, integer *);
    static integer pbuff[30];
    extern integer right_(integer *, integer *);

/*      GLOBAL TABLES */
    k = syntax_1.vloc[*sym];
    if (*sym > syntax_1.nt) {
	goto L100;
    }
    l = syntax_1.v[k - 1];
    i__1 = k + 1;
    i__2 = k + l;
    i__3 = syntax_1.nsy + 1;
    form_(cc, syntax_1.v, &i__1, &i__2, &i__3);
    goto L9999;
L100:
    l = right_(&k, &c__15) - 1;
    k = shr_(&k, &c__15);
    kp = 0;
    i__1 = k;
    i__2 = syntax_1.pack;
    for (i__ = 1; i__2 < 0 ? i__ >= i__1 : i__ <= i__1; i__ += i__2) {
	++l;
	lp = syntax_1.v[l - 1];
	jp = syntax_1.pack * 6;
	i__3 = syntax_1.pack;
	for (j = 1; j <= i__3; ++j) {
	    jp += -6;
	    ++kp;
	    ip = shr_(&lp, &jp);
	    pbuff[kp - 1] = right_(&ip, &c__6) + 1;
/* L300: */
	}
    }

    form_(cc, pbuff, &c__1, &k, &c__30);
L9999:
    return 0;
} /* prsym_ */

integer getc1_(integer *i__, integer *j)
{
    /* System generated locals */
    integer ret_val, i__1;

    /* Local variables */
    static integer k, l, m;
    extern integer shl_(integer *, integer *), shr_(integer *, integer *), 
	    right_(integer *, integer *);

/*      GLOBAL TABLES */
    k = (syntax_1.nt + 1) * *i__ + *j;
    l = k / 15 + 1;
    l = syntax_1.c1[l - 1];
    i__1 = 14 - k % 15;
    m = shl_(&i__1, &c__1);
    i__1 = shr_(&l, &m);
    ret_val = right_(&i__1, &c__2);
    return ret_val;
} /* getc1_ */

/* Subroutine */ int scan_(void)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, m, n, lp;
    extern integer gnc_(integer *), shl_(integer *, integer *);
    extern /* Subroutine */ int error_(integer *, integer *), decibp_(void);

/*      GLOBAL TABLES */
/*     SCAN FINDS THE NEXT ENTITY IN THE INPUT STREAM */
/*     THE RESULTING ITEM IS PLACED INTO ACCUM (OF LENGTH */
/*     ACCLEN).  TYPE AND STYPE IDENTIFY THE ITEM AS SHOWN */
/*     BELOW -- */
/*     TYPE     STYPE         ITEM           VARIABLE */
/*       1        NA        END OF FILE       EOFLAG */
/*       2       CONT       IDENTIFIER        IDENT */
/*       3       RADIX      NUMBER            NUMB */
/*       4        NA        SPEC CHAR         SPECL */
/*       5        CONT      STRING            STR */

    stacks_1.failsf = TRUE_;
L10:
    i__ = gnc_(&c__0);
    scanc_1.acclen = 0;
    if (scanc_1.stype != scanc_1.cont) {
	goto L51;
    }
    switch (scanc_1.type__) {
	case 1:  goto L100;
	case 2:  goto L200;
	case 3:  goto L51;
	case 4:  goto L51;
	case 5:  goto L499;
    }
/*     DEBLANK INPUT */
L50:
    i__ = gnc_(&c__0);
L51:
    if (i__ == 0) {
	goto L100;
    }
    switch (i__) {
	case 1:  goto L50;
	case 2:  goto L300;
	case 3:  goto L300;
	case 4:  goto L300;
	case 5:  goto L300;
	case 6:  goto L300;
	case 7:  goto L300;
	case 8:  goto L300;
	case 9:  goto L300;
	case 10:  goto L300;
	case 11:  goto L300;
	case 12:  goto L200;
	case 13:  goto L200;
	case 14:  goto L200;
	case 15:  goto L200;
	case 16:  goto L200;
	case 17:  goto L200;
	case 18:  goto L200;
	case 19:  goto L200;
	case 20:  goto L200;
	case 21:  goto L200;
	case 22:  goto L200;
	case 23:  goto L200;
	case 24:  goto L200;
	case 25:  goto L200;
	case 26:  goto L200;
	case 27:  goto L200;
	case 28:  goto L200;
	case 29:  goto L200;
	case 30:  goto L200;
	case 31:  goto L200;
	case 32:  goto L200;
	case 33:  goto L200;
	case 34:  goto L200;
	case 35:  goto L200;
	case 36:  goto L200;
	case 37:  goto L200;
	case 38:  goto L400;
	case 39:  goto L400;
	case 40:  goto L400;
	case 41:  goto L400;
	case 42:  goto L400;
	case 43:  goto L400;
	case 44:  goto L400;
	case 45:  goto L400;
	case 46:  goto L400;
	case 47:  goto L400;
	case 48:  goto L400;
	case 49:  goto L400;
	case 50:  goto L400;
	case 51:  goto L400;
	case 52:  goto L400;
	case 53:  goto L400;
	case 54:  goto L400;
	case 55:  goto L400;
	case 56:  goto L400;
	case 57:  goto L400;
	case 58:  goto L400;
	case 59:  goto L400;
	case 60:  goto L400;
	case 61:  goto L400;
	case 62:  goto L400;
	case 63:  goto L400;
	case 64:  goto L400;
    }
/*     END OF FILE */
L100:
    scanc_1.type__ = scanc_1.eoflag;
    goto L999;
/*     IDENTIFIER */
L200:
    scanc_1.type__ = scanc_1.ident;
L210:
    ++scanc_1.acclen;
    scanc_1.accum[scanc_1.acclen - 1] = i__;
    if (scanc_1.acclen >= 32) {
	goto L220;
    }
L215:
    i__ = gnc_(&c__0);
/*     CHECK FOR $ WITHIN AN IDENTIFIER */
    if (i__ == 38) {
	goto L215;
    }
    if (i__ >= 2 && i__ <= 37) {
	goto L210;
    }
    decibp_();
    scanc_1.stype = 0;
    goto L999;
L220:
    scanc_1.stype = scanc_1.cont;
    goto L999;


/*     NUMBER */
L300:
    scanc_1.type__ = scanc_1.numb;
    scanc_1.stype = 0;
L310:
    ++scanc_1.acclen;
    scanc_1.accum[scanc_1.acclen - 1] = i__;
    if (scanc_1.acclen == 32) {
	goto L350;
    }
L312:
    i__ = gnc_(&c__0);
/*     CHECK FOR $ IN NUMBER */
    if (i__ == 38) {
	goto L312;
    }
    if (i__ >= 2 && i__ <= 17) {
	goto L310;
    }
/*     CHECK RADIX */
    if (i__ == 19) {
	scanc_1.stype = 16;
    }
    if (i__ == 28) {
	scanc_1.stype = 8;
    }
    if (i__ == 26) {
	scanc_1.stype = 8;
    }
    if (scanc_1.stype != 0) {
	goto L325;
    }
    if (scanc_1.accum[scanc_1.acclen - 1] == 13) {
	goto L315;
    }
    if (scanc_1.accum[scanc_1.acclen - 1] == 15) {
	goto L318;
    }
    scanc_1.stype = 10;
    goto L320;
L315:
    scanc_1.stype = 2;
    --scanc_1.acclen;
    goto L320;
L318:
    scanc_1.stype = 10;
    --scanc_1.acclen;
L320:
    decibp_();
L325:
    i__1 = scanc_1.acclen;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = scanc_1.accum[i__ - 1] - 2;
	if (j >= scanc_1.stype) {
	    goto L340;
	}
/* L330: */
    }
    goto L999;
L340:
    scanc_1.stype = 1;
    goto L999;
L350:
    scanc_1.stype = 1;
L351:
    i__ = gnc_(&c__0);
    if (i__ >= 2 && i__ <= 17) {
	goto L351;
    }
    decibp_();
    goto L999;
/*     SPECIAL CHARACTER (TEST FOR QUOTE) */
L400:
    if (i__ == 46) {
	goto L500;
    }
    scanc_1.type__ = scanc_1.specl;
    scanc_1.acclen = 1;
    scanc_1.accum[0] = i__;
    if (i__ != 41) {
	goto L999;
    }
    i__ = gnc_(&c__0);
/*     LOOK FOR COMMENT */
    if (i__ == 47) {
	goto L410;
    }
    decibp_();
    goto L999;
/*     COMMENT FOUND */
L410:
    i__ = gnc_(&c__0);
    if (i__ == 0) {
	goto L100;
    }
    if (i__ != 47) {
	goto L410;
    }
    i__ = gnc_(&c__0);
    if (i__ == 41) {
	goto L420;
    }
    decibp_();
    goto L410;
L420:
    scanc_1.acclen = 0;
    goto L50;
/*     CONTINUE WITH STRING */
L499:
    decibp_();
/*     STRING QUOTE */
L500:
    scanc_1.type__ = scanc_1.str;
    scanc_1.accum[0] = 1;
L510:
    i__ = gnc_(&c__0);
    if (i__ == 46) {
	goto L530;
    }
L520:
    ++scanc_1.acclen;
    scanc_1.accum[scanc_1.acclen - 1] = i__;
    if (scanc_1.acclen < 32) {
	goto L510;
    }
    scanc_1.stype = scanc_1.cont;
    goto L999;
/*     STRING QUOTE FOUND (ENDING, MAYBE) */
L530:
    i__ = gnc_(&c__0);
    if (i__ == 46) {
	goto L520;
    }
    decibp_();
    scanc_1.stype = 0;
/*     THE CODE BELOW IS HERE TO SATISFY THE SYNTAX ANALYZER */
L999:
    if (scanc_1.type__ == scanc_1.eoflag) {
	goto L2000;
    }
    syntax_1.token = syntax_1.strv;
    if (scanc_1.type__ == scanc_1.str) {
	return 0;
    }
    syntax_1.token = 0;
    if (scanc_1.acclen > syntax_1.vil) {
	goto L3000;
    }
/*     SEARCH FOR TOKEN IN VOCABULARY */
    j = syntax_1.vindx[scanc_1.acclen - 1] + 1;
    k = syntax_1.vindx[scanc_1.acclen];
    i__1 = k;
    for (i__ = j; i__ <= i__1; ++i__) {
	l = syntax_1.vloc[i__ - 1];
	lp = l + syntax_1.v[l - 1];
	++l;
	n = 1;
	i__2 = lp;
	for (m = l; m <= i__2; ++m) {
	    if (scanc_1.accum[n - 1] != syntax_1.v[m - 1]) {
		goto L1300;
	    }
/* L1200: */
	    ++n;
	}
	syntax_1.token = i__ - 1;
	goto L1400;
L1300:
	;
    }
    goto L3000;
L1400:
    return 0;
L2000:
    syntax_1.token = syntax_1.eofile;
    return 0;
L3000:
    if (scanc_1.type__ != scanc_1.ident) {
	goto L4000;
    }
    syntax_1.token = syntax_1.identv;
    l = macro_1.mactop;
L3100:
    l = macro_1.macros[l - 1];
    if (l == 0) {
	goto L3400;
    }
    k = macro_1.macros[l];
    if (k != scanc_1.acclen) {
	goto L3100;
    }
    i__ = l + 2;
    i__1 = k;
    for (j = 1; j <= i__1; ++j) {
	if (scanc_1.accum[j - 1] != macro_1.macros[i__ - 1]) {
	    goto L3100;
	}
/* L3200: */
	++i__;
    }
/*     MACRO FOUND, SET-UP MACRO TABLE AND RESCAN */
    --macro_1.curmac;
    if (macro_1.curmac > macro_1.mactop) {
	goto L3300;
    }
    error_(&c__8, &c__5);
    macro_1.curmac = macro_1.maxmac;
L3300:
    j = i__ + macro_1.macros[i__ - 1];
    macro_1.macros[macro_1.curmac - 1] = shl_(&i__, &c__12) + j;
    goto L10;
L3400:
L4000:
    if (scanc_1.type__ == scanc_1.numb) {
	syntax_1.token = syntax_1.numbv;
    }
    return 0;
} /* scan_ */

integer wrdata_(integer *sy)
{
    /* System generated locals */
    integer ret_val, i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, m, n, ip, kp, lp, np;
    extern integer shr_(integer *, integer *);
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), emit_(
	    integer *, integer *);
    static logical dflag;
    extern integer right_(integer *, integer *);
    static integer nbytes;

/*     IF SY IS NEGATIVE, THE CALL COMES FROM SYNTH -- DATA IS INSERTED */
/*     INLINE BY CALLING LIT WITH EACH BYTE VALUE. */

/*     IF SY IS POSITIVE, THE CALL COMES FROM DUMPIN -- */
/*     WRDATA WRITES DATA INTO THE OUTPUT FILE FROM SYMBOL AT LOCATION */
/*     'SY'  EACH BYTE VALUE IS WRITTEN AS A PAIR OF BASE 32 DIGITS. */
/*     THE HIGH ORDER BIT OF THE FIRST DIGIT IS 1, AND ALL REMAINING HIGH */
/*     ORDER DIGITS ARE ZERO. THE VALUE RETURNED BY WRDATA IS THE TOTAL */
/*     NUMBER OF BYTES WRITTEN. */
/*      GLOBAL TABLES */
    nbytes = 0;
    j = abs(*sy);

/*     CHECK PRECISION OF VALUE */
    k = sym_1.symbol[j];
/*     SET DFLAG TO TRUE IF WE ARE DUMPING A VARIABLE OR LABEL NAME */
    l = right_(&k, &c__4);
    dflag = l == types_1.label || l == types_1.varb || l == types_1.proc;
    i__1 = shr_(&k, &c__4);
    l = right_(&i__1, &c__4);
    if (l > 2 || dflag) {
	goto L400;
    }

/*     SINGLE OR DOUBLE BYTE CONSTANT */
    kp = shr_(&k, &c__8);
    k = 16;
    nbytes = l;

L200:
    if (l <= 0) {
	goto L9999;
    }
/*     PROCESS NEXT BYTE */
    --l;
    i__2 = l << 3;
    i__1 = shr_(&kp, &i__2);
    n = right_(&i__1, &c__8);
    if (*sy < 0) {
	goto L350;
    }
/*         N IS THEN WRITTEN IN TWO PARTS */
    for (i__ = 1; i__ <= 2; ++i__) {
	i__2 = 2 - i__ << 2;
	i__1 = shr_(&n, &i__2);
	k = right_(&i__1, &c__4) + k + 2;
	pad_(&c__1, &k, &c__1);
/* L300: */
	k = 0;
    }

    goto L200;

/*     OTHERWISE EMIT DATA INLINE */
L350:
    emit_(&n, &opcod_1.lit);
    goto L200;

/*    WRITE OUT STRING DATA */
L400:
    i__2 = (i__1 = sym_1.symbol[j - 1], abs(i__1));
    l = right_(&i__2, &c__12);
    ++j;
    k = 16;
    n = -1;
    np = (syntax_1.pack - 1) * 6;
    lp = 1;

L500:
    if (lp > l) {
	goto L9999;
    }
    if (n >= 0) {
	goto L600;
    }
    n = np;
    ++j;
    m = sym_1.symbol[j - 1];

L600:
    ++nbytes;
    i__1 = shr_(&m, &n);
    kp = right_(&i__1, &c__6) + 1;
    if (dflag) {
	goto L900;
    }
    kp = asc_1.ascii[kp - 1];

/*    WRITE OUT BOTH HEX VALUES */
    if (*sy < 0) {
	goto L800;
    }

    for (ip = 1; ip <= 2; ++ip) {
	i__2 = 2 - ip << 2;
	i__1 = shr_(&kp, &i__2);
	k = right_(&i__1, &c__4) + k + 2;
	pad_(&c__1, &k, &c__1);
/* L700: */
	k = 0;
    }
L710:
    n += -6;
    ++lp;
    goto L500;

/*     EMIT STRING DATA INLINE */
L800:
    emit_(&kp, &opcod_1.lit);
    goto L710;

/*     WRITE OUT THE VARIABLE OR LABEL NAME */
L900:
    pad_(&c__1, &kp, &c__1);
    goto L710;
L9999:
    ret_val = nbytes;
    return ret_val;
} /* wrdata_ */

/* Subroutine */ int dumpch_(void)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j, k, l, m, kq, kt;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer shr_(integer *, integer *), wrdata_(integer *);
    extern /* Subroutine */ int writel_(integer *);

/*     DUMP THE SYMBOLIC NAMES FOR THE SIMULATOR */
    writel_(&c__0);
    kt = cntrl_1.contrl[25];
    cntrl_1.contrl[25] = cntrl_1.contrl[31];
    kq = cntrl_1.contrl[33];
    cntrl_1.contrl[33] = cntrl_1.contrl[32];

    k = 0;
    i__ = 2;
    if (sym_1.symbol[1] == 0) {
	i__ = 0;
    }
    pad_(&c__1, &c__41, &c__1);
L200:
    if (i__ == 0) {
	goto L1000;
    }
    ++k;
    j = sym_1.symbol[i__ + 1];
    if (j < 0) {
	goto L400;
    }
    j %= 16;
    if (j != types_1.label && j != types_1.varb && j != types_1.proc) {
	goto L400;
    }
/*         CHECK FOR NO CHARACTERS */
    j = (i__1 = sym_1.symbol[i__], abs(i__1));
/*         CHECK FOR NO WORDS ALLOCATED */
    if (shr_(&j, &c__12) == 0) {
	goto L400;
    }
/*         WRITE SYMBOL NUMBER */
    m = k;
    for (l = 1; l <= 3; ++l) {
	i__1 = m % 32 + 2;
	pad_(&c__1, &i__1, &c__1);
	m /= 32;
/* L300: */
    }
/*         NOW WRITE THE STRING */
    i__1 = i__ + 1;
    m = wrdata_(&i__1);
    pad_(&c__1, &c__41, &c__1);
L400:
    i__ = sym_1.symbol[i__ - 1];
    goto L200;

L1000:
    pad_(&c__1, &c__41, &c__1);
    writel_(&c__0);
    cntrl_1.contrl[25] = kt;
    cntrl_1.contrl[33] = kq;
    return 0;
} /* dumpch_ */

/* Subroutine */ int synth_(integer *prod, integer *symm)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer i__, j, k, l, m, n, ip, kp;
    extern integer shl_(integer *, integer *), shr_(integer *, integer *);
    extern /* Subroutine */ int emit_(integer *, integer *);
    extern integer right_(integer *, integer *), enter_(integer *);
    extern /* Subroutine */ int redpr_(integer *, integer *), exitb_(void), 
	    error_(integer *, integer *);
    static integer ltemp;
    extern /* Subroutine */ int enterb_(void);
    extern integer wrdata_(integer *), lookup_(integer *);


/*    MP == LEFT ,  SP == RIGHT */

/*      GLOBAL TABLES */
    if (cntrl_1.contrl[11] != 0) {
	redpr_(prod, symm);
    }
/*    1     1     2     3     4     5     6     7     8     9    10 */
/*    2    11    12    13    14    15    16    17    18    19    20 */
/*    3    21    22    23    24    25    26    27    28    29    30 */
/*    4    31    32    33    34    35    36    37    38    39    40 */
/*    5    41    42    43    44    45    46    47    48    49    50 */
/*    6    51    52    53    54    55    56    57    58    59    60 */
/*    7    61    62    63    64    65    66    67    68    69    70 */
/*    8    71    72    73    74    75    76    77    78    79    80 */
/*    9    81    82    83    84    85    86    87    88    89    90 */
/*    A    91    92    93    94    95    96    97    98    99   100 */
/*    B   101   102   103   104   105   106   107   108   109   110 */
/*    C   111   112   113   114   115   116   117   118   119   120 */
/*    D   121   122   123   124   125   126   127   128   129   130 */
    switch (*prod) {
	case 1:  goto L100;
	case 2:  goto L99999;
	case 3:  goto L99999;
	case 4:  goto L99999;
	case 5:  goto L99999;
	case 6:  goto L600;
	case 7:  goto L99999;
	case 8:  goto L800;
	case 9:  goto L99999;
	case 10:  goto L99999;
	case 11:  goto L99999;
	case 12:  goto L800;
	case 13:  goto L1300;
	case 14:  goto L1340;
	case 15:  goto L1360;
	case 16:  goto L99999;
	case 17:  goto L99999;
	case 18:  goto L1500;
	case 19:  goto L1600;
	case 20:  goto L99999;
	case 21:  goto L1800;
	case 22:  goto L1900;
	case 23:  goto L2000;
	case 24:  goto L2100;
	case 25:  goto L2200;
	case 26:  goto L2300;
	case 27:  goto L2400;
	case 28:  goto L2500;
	case 29:  goto L2600;
	case 30:  goto L2700;
	case 31:  goto L2800;
	case 32:  goto L2900;
	case 33:  goto L99999;
	case 34:  goto L3100;
	case 35:  goto L3200;
	case 36:  goto L3300;
	case 37:  goto L3400;
	case 38:  goto L3500;
	case 39:  goto L3540;
	case 40:  goto L3600;
	case 41:  goto L3700;
	case 42:  goto L3800;
	case 43:  goto L3700;
	case 44:  goto L4000;
	case 45:  goto L4100;
	case 46:  goto L4200;
	case 47:  goto L4300;
	case 48:  goto L4350;
	case 49:  goto L4400;
	case 50:  goto L4500;
	case 51:  goto L4600;
	case 52:  goto L4700;
	case 53:  goto L5000;
	case 54:  goto L99999;
	case 55:  goto L99999;
	case 56:  goto L99999;
	case 57:  goto L99999;
	case 58:  goto L99999;
	case 59:  goto L5300;
	case 60:  goto L5600;
	case 61:  goto L5610;
	case 62:  goto L5620;
	case 63:  goto L5610;
	case 64:  goto L5400;
	case 65:  goto L5500;
	case 66:  goto L99999;
	case 67:  goto L5700;
	case 68:  goto L5800;
	case 69:  goto L5900;
	case 70:  goto L99999;
	case 71:  goto L6100;
	case 72:  goto L6400;
	case 73:  goto L6300;
	case 74:  goto L6400;
	case 75:  goto L6500;
	case 76:  goto L6600;
	case 77:  goto L6500;
	case 78:  goto L6800;
	case 79:  goto L6900;
	case 80:  goto L6800;
	case 81:  goto L7100;
	case 82:  goto L7100;
	case 83:  goto L99999;
	case 84:  goto L99999;
	case 85:  goto L99999;
	case 86:  goto L7500;
	case 87:  goto L99999;
	case 88:  goto L7600;
	case 89:  goto L7700;
	case 90:  goto L99999;
	case 91:  goto L7900;
	case 92:  goto L99999;
	case 93:  goto L8100;
	case 94:  goto L99999;
	case 95:  goto L8300;
	case 96:  goto L8400;
	case 97:  goto L8400;
	case 98:  goto L8400;
	case 99:  goto L8400;
	case 100:  goto L8400;
	case 101:  goto L8400;
	case 102:  goto L99999;
	case 103:  goto L9300;
	case 104:  goto L9300;
	case 105:  goto L9300;
	case 106:  goto L9300;
	case 107:  goto L9400;
	case 108:  goto L99999;
	case 109:  goto L10000;
	case 110:  goto L10000;
	case 111:  goto L10000;
	case 112:  goto L10300;
	case 113:  goto L10310;
	case 114:  goto L10320;
	case 115:  goto L10400;
	case 116:  goto L10500;
	case 117:  goto L99999;
	case 118:  goto L10550;
	case 119:  goto L10560;
	case 120:  goto L10600;
	case 121:  goto L10700;
	case 122:  goto L10800;
	case 123:  goto L10900;
	case 124:  goto L11000;
	case 125:  goto L11100;
	case 126:  goto L11200;
	case 127:  goto L11300;
	case 128:  goto L11400;
    }
/*     P R O D U C T I O N S */
/*     <PROGRAM> ::= <STATEMENT LIST> */
/*     <STATEMENT LIST> ::= <STATEMENT> */
L100:
    if (stacks_1.mp != 5) {
	error_(&c__10, &c__1);
    }
    stacks_1.compil = FALSE_;
    exitb_();
    goto L99999;
/*     <STATEMENT LIST> ::= <STATEMENT LIST> <STATEMENT> */
/*     <STATEMENT> ::= <BASIC STATEMENT> */
/*     <STATEMENT> ::= <IF STATEMENT> */
/*     <BASIC STATEMENT> ::= <ASSIGNMENT> ; */
L600:
    if (sym_1.acnt <= 0) {
	goto L630;
    }
    ltemp = sym_1.maxsym - sym_1.acnt;
    i__ = sym_1.symbol[ltemp - 1];
    --sym_1.acnt;
    if (i__ > 0) {
	goto L610;
    }
    emit_(&opcod_1.xch, &opcod_1.opr);
    goto L620;
L610:
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.adr);
L620:
    if (sym_1.acnt > 0) {
	emit_(&opcod_1.sto, &opcod_1.opr);
    }
    goto L600;
L630:
    i__ = opcod_1.std;
    goto L88888;
/*     <BASIC STATEMENT> ::= <GROUP> ; */
/*     <BASIC STATEMENT> ::= <PROCEDURE DEFINITION> ; */
L800:
    i__ = blk_1.dopar[blk_1.curblk - 1];
    i__ = right_(&i__, &c__2);
    if (i__ == 0) {
	goto L99999;
    }
    error_(&c__11, &c__1);
    goto L99999;
/*     <BASIC STATEMENT> ::= <RETURN STATEMENT> ; */
/*     <BASIC STATEMENT> ::= <CALL STATEMENT> ; */
/*     <BASIC STATEMENT> ::= <GO TO STATEMENT> ; */
/*     <BASIC STATEMENT> ::= <DECLARATION STATEMENT> ; */
/*     <BASIC STATEMENT> ::= HALT */
L1300:
    i__ = opcod_1.hal;
    goto L88888;
/*     <BASIC STATEMENT> ::= ENABLE; */
L1340:
    i__ = opcod_1.ena;
    goto L88888;
/*     <BASIC STATEMENT> ::= DISABLE; */
L1360:
    i__ = opcod_1.dis;
    goto L88888;
/*     <BASIC STATEMENT> ::= ; */
/*     <BASIC STATEMENT> ::= <LABEL DEFINITION> <BASIC STATEMENT> */
L1500:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    goto L1610;
/*     <IF STATEMENT> ::= <IF CLAUSE> <STATEMENT> */
L1600:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
L1610:
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.def);
    sym_1.symbol[i__] = types_1.label + 64;
    goto L99999;
/*     <IF STATEMENT> ::= <IF CLAUSE> <TRUE PART> <STATEMENT> */
/*     <IF STATEMENT> ::= <LABEL DEFINITION> <IF STATEMENT> */
/*     <IF CLAUSE> ::= IF <EXPRESSION> THEN */
L1800:
    i__1 = -types_1.label;
    i__ = enter_(&i__1);
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    emit_(&opcod_1.trc, &opcod_1.opr);
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
/*     <TRUE PART> ::= <BASIC STATEMENT> ELSE */
L1900:
    i__1 = -types_1.label;
    i__ = enter_(&i__1);
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    j = stacks_1.fixv[stacks_1.mp - 2];
    stacks_1.fixv[stacks_1.mp - 2] = i__;
    i__ = j;
    goto L1610;
/*     <GROUP> ::= <GROUP HEAD> <ENDING> */
L2000:
    if (stacks_1.fixv[stacks_1.sp - 1] > 0) {
	error_(&c__12, &c__1);
    }
    if (stacks_1.fixc[stacks_1.sp - 1] < 0) {
	stacks_1.fixc[stacks_1.mp - 1] = 0;
    }
    i__ = blk_1.dopar[blk_1.curblk];
    j = right_(&i__, &c__2) + 1;
    i__ = shr_(&i__, &c__2);
    switch (j) {
	case 1:  goto L2060;
	case 2:  goto L2050;
	case 3:  goto L2040;
	case 4:  goto L2005;
    }
/*     GENERATE DESTINATION OF CASE BRANCH */
L2005:
    j = right_(&i__, &c__14);
    k = shr_(&sym_1.symbol[j - 2], &c__16);
    emit_(&k, &opcod_1.def);
    m = shr_(&sym_1.symbol[j], &c__8);
    sym_1.symbol[j] = right_(&sym_1.symbol[j], &c__8);
/*     M IS SYMBOL NUMBER OF LABEL AT END OF JUMP TABLE */
    emit_(&opcod_1.cse, &opcod_1.opr);
/*     DEFINE THE JUMP TABLE */
    i__ = shr_(&i__, &c__14);
/*     REVERSE THE LABEL LIST */
    l = 0;
L2010:
    if (i__ == 0) {
	goto L2020;
    }
    k = sym_1.symbol[i__];
    sym_1.symbol[i__] = shl_(&l, &c__8) + right_(&k, &c__8);
    l = i__;
    i__ = shr_(&k, &c__8);
    goto L2010;
/*     EMIT LIST STARTING AT L */
L2020:
    i__ = sym_1.symbol[l];
    sym_1.symbol[l] = types_1.label + 64;
    j = shr_(&i__, &c__8);
    if (j == 0) {
	goto L2030;
    }
    k = shr_(&sym_1.symbol[l - 2], &c__16);
/* L2025: */
    emit_(&k, &opcod_1.vlu);
    emit_(&opcod_1.ax2, &opcod_1.opr);
    l = j;
    goto L2020;
L2030:
/*     DEFINE END OF JUMP TABLE */
    emit_(&m, &opcod_1.def);
    goto L99999;
/*     DEFINE END OF WHILE STATEMENT */
L2040:
    j = shr_(&i__, &c__14);
    i__ = right_(&i__, &c__14);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    emit_(&i__, &opcod_1.def);
    goto L99999;
/*     END OF ITERATIVE STATEMENT */
L2050:
    k = stacks_1.fixv[stacks_1.mp - 1];
    if (k == 0) {
	goto L2040;
    }
/*     OTHERWISE INCREMENT VARIABLE */
    emit_(&k, &opcod_1.vlu);
    emit_(&opcod_1.inc, &opcod_1.opr);
    emit_(&k, &opcod_1.adr);
    emit_(&opcod_1.std, &opcod_1.opr);
/*     DEFINE ENDING BRANCH AND LABEL */
    goto L2040;
L2060:
    i__ = opcod_1.end;
    goto L88888;
/*     <GROUP HEAD> ::= DO ; */
L2100:
    enterb_();
    i__ = opcod_1.enb;
    goto L88888;
/*     <GROUP HEAD> ::= DO <STEP DEFINITION> ; */
L2200:
    enterb_();
    blk_1.dopar[blk_1.curblk - 1] = shl_(&stacks_1.fixv[stacks_1.mp], &c__2) 
	    + 1;
    goto L99999;
/*     <GROUP HEAD> ::= DO <WHILE CLAUSE> ; */
L2300:
    enterb_();
    blk_1.dopar[blk_1.curblk - 1] = shl_(&stacks_1.fixv[stacks_1.mp], &c__2) 
	    + 2;
    goto L99999;
/*     <GROUP HEAD> ::= DO <CASE SELECTOR> ; */
L2400:
    enterb_();
    i__1 = -(types_1.label + 64);
    k = enter_(&i__1);
    k = shr_(&sym_1.symbol[k - 2], &c__16);
/*     K IS LABEL AFTER CASE JUMP TABLE */
    i__1 = -(shl_(&k, &c__8) + 64 + types_1.label);
    i__ = enter_(&i__1);
    j = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.ax1, &opcod_1.opr);
    blk_1.dopar[blk_1.curblk - 1] = shl_(&i__, &c__2) + 3;
L2410:
    i__ = blk_1.dopar[blk_1.curblk - 1];
    k = shr_(&i__, &c__16);
    i__1 = -(shl_(&k, &c__8) + 64 + types_1.label);
    j = enter_(&i__1);
    blk_1.dopar[blk_1.curblk - 1] = shl_(&j, &c__16) + right_(&i__, &c__16);
    j = shr_(&sym_1.symbol[j - 2], &c__16);
    emit_(&j, &opcod_1.def);
    goto L99999;
/*     <GROUP HEAD> ::= <GROUP HEAD> <STATEMENT> */
L2500:
    i__ = blk_1.dopar[blk_1.curblk - 1];
    if (right_(&i__, &c__2) != 3) {
	goto L99999;
    }
/*     OTHERWISE CASE STMT */
    i__1 = shr_(&i__, &c__2);
    j = right_(&i__1, &c__14);
    j = sym_1.symbol[j];
    j = shr_(&j, &c__8);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    goto L2410;
/*     <STEP DEFINITION> ::= <VARIABLE> <REPLACE> <EXPRESSION> <ITERATION */

L2600:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    j = stacks_1.fixv[stacks_1.mp + 2];
    if (j >= 0) {
	i__ = 0;
    }
/*     PLACE <VARIABLE> SYMBOL NUMBER INTO DO SLOT */
    stacks_1.fixv[stacks_1.mp - 2] = i__;
    stacks_1.fixv[stacks_1.mp - 1] = abs(j);
    goto L99999;
/*     <ITERATION CONTROL> ::= <TO> <EXPRESSION> */
L2700:
    emit_(&opcod_1.leq, &opcod_1.opr);
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.trc, &opcod_1.opr);
    stacks_1.fixv[stacks_1.mp - 1] = -(shl_(&stacks_1.fixv[stacks_1.mp - 1], &
	    c__14) + i__);
/*     SEND  -(BACK BRANCH NUMBER/END LOOP NUMBER) */
    goto L99999;
/*     <ITERATION CONTROL> ::= <TO> <EXPRESSION> <BY> <EXPRESSION> */
L2800:
    i__ = stacks_1.fixv[stacks_1.mp - 4];
/*     I = SYMBOL NUMBER OF INDEXING VARIABLE */
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.add, &opcod_1.opr);
    emit_(&i__, &opcod_1.adr);
    emit_(&opcod_1.std, &opcod_1.opr);
/*     BRANCH TO COMPARE */
    i__ = stacks_1.fixv[stacks_1.mp + 1];
    j = shr_(&i__, &c__14);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
/*     DEFINE BEGINNING OF STATEMENTS */
    j = right_(&i__, &c__14);
    emit_(&j, &opcod_1.def);
/*     <TO> ALREADY HAS (BACK BRANCH NUMBER/END LOOP NUMBER) */
    goto L99999;
/*     <WHILE CLAUSE> ::= <WHILE> <EXPRESSION> */
L2900:
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    j = stacks_1.fixv[stacks_1.mp - 1];
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&j, &c__14) + i__;
/*     (BACK BRANCH NUMBER/END LOOP NUMBER) */
    emit_(&i__, &opcod_1.vlu);
    i__ = opcod_1.trc;
    goto L88888;
/*     <CASE SELECTOR> ::= CASE <EXPRESSION> */
/*     <PROCEDURE DEFINITION> ::= <PROCEDURE HEAD> <STATEMENT LIST> <ENDI */
L3100:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    k = shr_(&i__, &c__15);
    i__ = right_(&i__, &c__15);
    j = stacks_1.fixv[stacks_1.sp - 1];
    if (j < 0) {
	j = -j + 1;
    }
    if (j != 0 && i__ != j) {
	error_(&c__13, &c__1);
    }
    i__ = shr_(&sym_1.symbol[k - 2], &c__16);
    emit_(&opcod_1.end, &opcod_1.opr);
/*     EMIT A RET JUST IN CASE HE FORGOT IT */
    emit_(&opcod_1.drt, &opcod_1.opr);
    emit_(&i__, &opcod_1.def);
    goto L99999;
/*     <PROCEDURE HEAD> ::= <PROCEDURE NAME> ; */
L3200:
    l = 0;
    k = 0;
    goto L3450;
/*     <PROCEDURE HEAD> ::= <PROCEDURE NAME> <TYPE> ; */
L3300:
    l = 0;
    k = stacks_1.fixv[stacks_1.sp - 2];
    goto L3510;
/*     <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> ; */
L3400:
    l = stacks_1.fixv[stacks_1.mp];
    k = 0;
L3450:
    blk_1.proctp[blk_1.curblk - 1] = 1;
    goto L3520;
/*     <PROCEDURE HEAD> ::= <PROCEDURE NAME> <PARAMETER LIST> <TYPE> ; */
L3500:
    l = stacks_1.fixv[stacks_1.mp];
    k = stacks_1.fixv[stacks_1.sp - 2];
L3510:
    blk_1.proctp[blk_1.curblk - 1] = 2;
L3520:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    sym_1.symbol[i__] = shl_(&l, &c__8) + shl_(&k, &c__4) + types_1.proc;
    i__1 = -(types_1.label + 64);
    j = enter_(&i__1);
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&j, &c__15) + i__;
    j = shr_(&sym_1.symbol[j - 2], &c__16);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&i__, &opcod_1.def);
    goto L99999;
/*     <PROCEDURE HEAD> ::= <PROCEDURE NAME> INTERRUPT <NUMBER>; */
L3540:
/*     GET SYMBOL NUMBER */
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    i__ = sym_1.symbol[i__ - 2];
    i__ = shr_(&i__, &c__16);
/*     GET INTERRUPT NUMBER */
    j = stacks_1.fixv[stacks_1.sp - 2];
    if (j <= 7) {
	goto L3550;
    }
    error_(&c__39, &c__1);
    goto L3200;
L3550:
    ++j;
    k = inter_1.intpro[j - 1];
/*     IS INTERRUPT DUPLICATED */
    if (k <= 0) {
	goto L3560;
    }
    error_(&c__40, &c__1);
    goto L3200;
L3560:
    inter_1.intpro[j - 1] = i__;
    goto L3200;
/*     <PROCEDURE NAME> ::= <LABEL DEFINITION> PROCEDURE */
L3600:
    enterb_();
    i__ = opcod_1.enp;
    goto L88888;
/*     <PARAMETER LIST> ::= <PARAMETER HEAD> <IDENTIFIER> ) */
L3700:
    i__1 = stacks_1.sp - 1;
    i__ = lookup_(&i__1);
    if (i__ >= blk_1.blksym) {
	error_(&c__14, &c__1);
    }
    i__ = enter_(&types_1.varb);
    ++stacks_1.fixv[stacks_1.mp - 1];
    goto L99999;
/*     <PARAMETER HEAD> ::= ( */
L3800:
    stacks_1.fixv[stacks_1.mp - 1] = 0;
    goto L99999;
/*     <PARAMETER HEAD> ::= <PARAMETER HEAD> <IDENTIFIER> , */
/*     <ENDING> ::= END */
L4000:
    exitb_();
    stacks_1.fixv[stacks_1.mp - 1] = 0;
    goto L99999;
/*     <ENDING> ::= END <IDENTIFIER> */
L4100:
    exitb_();
    i__ = lookup_(&stacks_1.sp);
    if (i__ == 0) {
	error_(&c__15, &c__1);
    }
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
/*     <ENDING> ::= <LABEL DEFINITION> <ENDING> */
L4200:
    stacks_1.fixv[stacks_1.mp - 1] = stacks_1.fixv[stacks_1.sp - 1];
    goto L99999;
/*     <LABEL DEFINITION> ::= <IDENTIFIER> : */
L4300:
    i__ = lookup_(&stacks_1.mp);
    if (blk_1.curblk == 2) {
	ip = 48;
    }
    if (blk_1.curblk != 2) {
	ip = 64;
    }
    if (i__ >= blk_1.blksym) {
	goto L4310;
    }

/*         PREC = 3 IF USER-DEFINED OUTER BLOCK LABEL */
/*         PREC = 4 IF USER-DEFINED LABEL NOT IN OUTER BLOCK */
/*         PREC = 5 IF COMPILER-GENERATED LABEL */
    i__1 = ip + types_1.label;
    i__ = enter_(&i__1);
    goto L4320;
L4310:
    j = sym_1.symbol[i__];
    i__1 = shr_(&j, &c__4);
    j = right_(&i__1, &c__4);
    k = i__ + 1;
    if (j == 0) {
	goto L4315;
    }
    error_(&c__16, &c__1);
    sym_1.symbol[k - 1] -= j << 4;
L4315:
    sym_1.symbol[k - 1] += ip;
L4320:
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    if (syntax_1.token == syntax_1.procv) {
	goto L99999;
    }
    i__ = sym_1.symbol[i__ - 2];
    i__1 = shr_(&i__, &c__16);
    emit_(&i__1, &opcod_1.def);
    goto L99999;
/*     <LABEL DEFINITION> ::= <NUMBER> : */
L4350:
    i__ = opcod_1.org;
    j = stacks_1.mp;
L4360:
    k = stacks_1.fixv[j - 1];
    if (k <= 65535) {
	goto L4370;
    }
    error_(&c__17, &c__1);
    goto L99999;
L4370:
    l = lookup_(&j);
    if (l != 0) {
	goto L4380;
    }
/*     ENTER NUMBER */
    j = 1;
    if (k > 255) {
	j = 2;
    }
    i__1 = shl_(&k, &c__8) + shl_(&j, &c__4) + types_1.liter + 1;
    l = enter_(&i__1);
L4380:
    l = sym_1.symbol[l - 2];
    i__1 = shr_(&l, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    goto L88888;
/*     <RETURN STATEMENT> ::= RETURN */
L4400:
    emit_(&c__0, &opcod_1.lit);
    i__ = opcod_1.ret;
    if (blk_1.proctp[blk_1.curblk - 1] == 2) {
	error_(&c__45, &c__1);
    }
    if (blk_1.proctp[blk_1.curblk - 1] == 0) {
	error_(&c__46, &c__1);
    }
    goto L88888;
/*     <RETURN STATEMENT> ::= RETURN <EXPRESSION> */
L4500:
    i__ = opcod_1.ret;
    if (blk_1.proctp[blk_1.curblk - 1] == 1) {
	error_(&c__44, &c__1);
    }
    if (blk_1.proctp[blk_1.curblk - 1] == 0) {
	error_(&c__46, &c__1);
    }
    goto L88888;
/*     <CALL STATEMENT> ::= CALL <VARIABLE> */
L4600:
    i__ = stacks_1.fixv[stacks_1.sp - 1];
    if (i__ == 0) {
	goto L99999;
    }
    if (i__ > 0) {
	goto L4620;
    }
L4610:
    error_(&c__18, &c__1);
    goto L99999;
L4620:
    j = sym_1.symbol[i__];
    j = right_(&j, &c__4);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&i__, &opcod_1.adr);
    i__ = 0;
    if (j == types_1.proc) {
	i__ = opcod_1.pro;
    }
    if (j == types_1.intr) {
	i__ = opcod_1.bif;
    }
    if (i__ == 0) {
	goto L4610;
    }
    goto L88888;
/*     <GO TO STATEMENT> ::= <GO TO> <IDENTIFIER> */
L4700:
    i__ = lookup_(&stacks_1.sp);
    if (i__ == 0) {
	i__ = enter_(&types_1.label);
    }
    j = sym_1.symbol[i__];
    j = right_(&j, &c__4);
    if (j == types_1.label || j == types_1.varb) {
	goto L4710;
    }
    error_(&c__19, &c__1);
    goto L99999;
/*     INCREMENT THE REFERENCE COUNTER (USE LENGTH FIELD) */
L4710:
    if (j == types_1.label) {
	sym_1.symbol[i__] += 256;
    }
    i__ = sym_1.symbol[i__ - 2];
    i__1 = shr_(&i__, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    i__ = opcod_1.tra;
    goto L88888;
/*     <GO TO STATEMENT> ::= <GOTO> <NUMBER> */
L5000:
    j = stacks_1.sp;
    i__ = opcod_1.tra;
    goto L4360;
/*     <GO TO> ::= GO TO */
/*     <GO TO> ::= GOTO */
/*     <DECLARATION STATEMENT> ::= DECLARE <DECLARATION ELEMENT> */
/*     <DECLARATION STATEMENT> ::= <DECLARATION STATEMENT> , <DECLARATION */

/*     <DECLARATION ELEMENT> ::= <TYPE DECLARATION> */
/*     <DECLARATION ELEMENT> ::= <IDENTIFIER> LITERALLY <STRING> */
L5300:
    l = stacks_1.mp;
    k = macro_1.mactop;
    for (m = 1; m <= 2; ++m) {
	i__ = stacks_1.var[l - 1];
	ip = shr_(&i__, &c__12);
	i__ = right_(&i__, &c__12) - 1;
	++k;
	if (k >= macro_1.curmac) {
	    goto L5390;
	}
	macro_1.macros[k - 1] = ip;
	i__1 = ip;
	for (j = 1; j <= i__1; ++j) {
	    ++k;
	    if (k >= macro_1.curmac) {
		goto L5390;
	    }
	    ltemp = i__ + j;
	    macro_1.macros[k - 1] = stacks_1.varc[ltemp - 1];
/* L5320: */
	}
	l = stacks_1.sp;
/* L5330: */
    }

    ++k;
    if (k >= macro_1.curmac) {
	goto L5390;
    }
    macro_1.macros[k - 1] = macro_1.mactop;
    macro_1.mactop = k;
    goto L99999;
L5390:
    error_(&c__20, &c__5);
    goto L99999;
/*     <TYPE DECLARATION> ::= <IDENTIFIER SPECIFICATION> <TYPE> */
L5400:
    n = 1;
L5410:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    j = shr_(&i__, &c__15);
    i__ = right_(&i__, &c__15);
    k = stacks_1.fixv[stacks_1.sp - 1];
    i__1 = i__;
    for (l = j; l <= i__1; ++l) {
	m = sym_1.symbol[l - 1] + 1;
	ip = sym_1.symbol[m - 1];
	if (k != 0) {
	    goto L5430;
	}
	if (ip != 1) {
	    error_(&c__21, &c__1);
	}
	ip = types_1.label;
L5430:
	i__2 = abs(ip);
	sym_1.symbol[m - 1] = shl_(&n, &c__8) + shl_(&k, &c__4) + right_(&
		i__2, &c__4);
	if (ip < 0) {
	    sym_1.symbol[m - 1] = -sym_1.symbol[m - 1];
	}
/* L5420: */
    }

    sym_1.maxsym = i__;
    stacks_1.fixv[stacks_1.mp - 1] = sym_1.symbol[i__ - 1];
    goto L99999;
/*     <TYPE DECLARATION> ::= <BOUND HEAD> <NUMBER> ) <TYPE> */
L5500:
    n = stacks_1.fixv[stacks_1.mp];
    goto L5410;
/*     <TYPE DECLARATION> ::= <TYPE DECLARATION> <INITIAL LIST> */
/*     <DECLARATION ELEMENT> ::= <IDENTIFIER> <DATA LIST> */
L5600:
    i__ = stacks_1.fixv[stacks_1.mp - 1] + 1;
    j = stacks_1.fixv[stacks_1.mp];
    l = right_(&j, &c__16);
    sym_1.symbol[i__ - 1] = shl_(&l, &c__8) + sym_1.symbol[i__ - 1];
    j = shr_(&j, &c__16);
    emit_(&opcod_1.dat, &opcod_1.opr);
    emit_(&j, &opcod_1.def);
    i__ = opcod_1.dat;
    goto L99999;
/*     <DATA LIST> ::= <DATA HEAD> <CONSTANT> ) */
L5610:
    i__ = stacks_1.fixv[stacks_1.mp];
    i__1 = -i__;
    stacks_1.fixv[stacks_1.mp - 1] += wrdata_(&i__1);
    goto L99999;
/*     <DATA HEAD> ::= DATA ( */
L5620:
    i__1 = -(types_1.label + 64);
    j = enter_(&i__1);
    j = shr_(&sym_1.symbol[j - 2], &c__16);
    emit_(&j, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&j, &c__16);
    i__1 = stacks_1.mp - 1;
    i__ = lookup_(&i__1);
    if (i__ <= blk_1.blksym) {
	goto L5630;
    }
    error_(&c__22, &c__1);
/*     SET PRECISION OF INLINE DATA TO 3 */
L5630:
    i__1 = types_1.varb + 48;
    i__ = enter_(&i__1);
    stacks_1.fixv[stacks_1.mp - 2] = i__;
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&opcod_1.dat, &opcod_1.opr);
    emit_(&i__, &opcod_1.def);
/*     COUNT THE NUMBER OF BYTES EMITTED */
    goto L99999;
/*     <DATA HEAD> ::= <DATA HEAD> <CONSTANT> , */
/*     <TYPE> ::= BYTE */
L5700:
    stacks_1.fixv[stacks_1.mp - 1] = 1;
    goto L99999;
/*     <TYPE> ::= ADDRESS */
L5800:
    stacks_1.fixv[stacks_1.mp - 1] = 2;
    goto L99999;
/*     <TYPE> ::= LABEL */
L5900:
    stacks_1.fixv[stacks_1.mp - 1] = 0;
    goto L99999;
/*     <BOUND HEAD> ::= <IDENTIFIER SPECIFICATION> ( */
/*     <IDENTIFIER SPECIFICATION> ::= <VARIABLE NAME> */
L6100:
    sym_1.symbol[sym_1.maxsym - 1] = stacks_1.fixv[stacks_1.mp - 1];
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&sym_1.maxsym, &c__15) + 
	    sym_1.maxsym;
    goto L99999;
/*     <IDENTIFIER SPECIFICATION> ::= <IDENTIFIER LIST> <VARIABLE NAME> ) */
/*     <IDENTIFIER LIST> ::= ( */
L6300:
    stacks_1.fixv[stacks_1.mp - 1] = sym_1.maxsym;
    goto L99999;
/*     <IDENTIFIER LIST> ::= <IDENTIFIER LIST> <VARIABLE NAME> , */
L6400:
    if (sym_1.symtop < sym_1.maxsym) {
	goto L6420;
    }
L6410:
    error_(&c__23, &c__5);
    sym_1.maxsym = sym_1.symabs;
L6420:
    sym_1.symbol[sym_1.maxsym - 1] = stacks_1.fixv[stacks_1.mp];
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&sym_1.maxsym, &c__15) + right_(&
	    stacks_1.fixv[stacks_1.mp - 1], &c__15);
    --sym_1.maxsym;
    goto L99999;
/*     <VARIABLE NAME> ::= <IDENTIFIER> */
L6500:
    i__ = lookup_(&stacks_1.mp);
    if (i__ > blk_1.blksym) {
	goto L6520;
    }
    i__ = enter_(&types_1.varb);
    goto L6540;
L6520:
    j = right_(&sym_1.symbol[i__], &c__8);
    if (j == types_1.varb) {
	goto L6540;
    }
    error_(&c__24, &c__1);
L6540:
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
/*     <VARIABLE NAME> ::= <BASED VARIABLE> <IDENTIFIER> */
L6600:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    j = sym_1.symtop;
    ++sym_1.symtop;
    if (sym_1.symtop <= sym_1.maxsym) {
	goto L6620;
    }
    --sym_1.symtop;
    error_(&c__25, &c__5);
    goto L99999;
L6620:
    sym_1.symbol[sym_1.symtop - 1] = sym_1.symbol[j - 1];
    k = lookup_(&stacks_1.sp);
    if (k != 0) {
	goto L6630;
    }
    k = enter_(&types_1.varb);
    goto L6640;
L6630:
    l = sym_1.symbol[k];
    l = right_(&l, &c__4);
    if (l == types_1.varb) {
	goto L6640;
    }
    error_(&c__26, &c__1);
    goto L99999;
L6640:
    k = sym_1.symbol[k - 2];
    sym_1.symbol[j - 1] = shr_(&k, &c__16);
    ++i__;
    sym_1.symbol[i__ - 1] = -sym_1.symbol[i__ - 1];
    goto L99999;
/*     <BASED VARIABLE> ::= <IDENTIFIER> BASED */
/*     <INITIAL LIST> ::= <INITIAL HEAD> <CONSTANT> ) */
L6800:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    if (sym_1.maxsym <= sym_1.symtop) {
	goto L6410;
    }
    ++sym_1.symbol[i__ - 1];
    i__ = stacks_1.fixv[stacks_1.mp];
    i__1 = shr_(&sym_1.symbol[i__ - 2], &c__16);
    i__ = shl_(&i__1, &c__16) + i__;
    sym_1.symbol[sym_1.maxsym - 1] = i__;
    --sym_1.maxsym;
    goto L99999;
/*     <INITIAL HEAD> ::= INITIAL ( */
L6900:
    i__ = stacks_1.fixv[stacks_1.mp - 2];
    stacks_1.fixv[stacks_1.mp - 1] = sym_1.maxsym;
    j = sym_1.maxsym;
    --sym_1.maxsym;
    if (sym_1.maxsym <= sym_1.symtop) {
	goto L6410;
    }
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    sym_1.symbol[j - 1] = shl_(&i__, &c__15);
    goto L99999;
/*     <INITIAL HEAD> ::= <INITIAL HEAD> <CONSTANT> , */
/*     <ASSIGNMENT> ::= <VARIABLE> <REPLACE> <EXPRESSION> */
L7100:
    ++sym_1.acnt;
    i__ = sym_1.maxsym - sym_1.acnt;
    if (i__ > sym_1.symtop) {
	goto L7110;
    }
    error_(&c__27, &c__5);
    sym_1.acnt = 0;
    goto L99999;
L7110:
    sym_1.symbol[i__ - 1] = stacks_1.fixv[stacks_1.mp - 1];
/*      CHECK FOR PROCEDURE ON LHS OF ASSIGNMENT. */
/*     ****NOTE THAT THIS IS DEPENDENT ON SYMBOL NUMBER OF OUTPUT=17**** */
    if (stacks_1.fixv[stacks_1.mp - 1] != 0 || stacks_1.fixc[stacks_1.mp - 1] 
	    == 17) {
	goto L99999;
    }
    error_(&c__41, &c__1);
    goto L99999;
/*     <ASSIGNMENT> ::= <LEFT PART> <ASSIGNMENT> */
/*     <REPLACE> ::= = */
/*     <LEFT PART> ::= <VARIABLE> , */
/*     <EXPRESSION> ::= <LOGICAL EXPRESSION> */
/*     <EXPRESSION> ::= <VARIABLE> : = <EXPRESSION> */
L7500:
    i__ = opcod_1.sto;
    j = stacks_1.fixv[stacks_1.mp - 1];
    if (stacks_1.fixv[stacks_1.mp - 1] == 0) {
	error_(&c__41, &c__1);
    }
    if (j < 0) {
	goto L7510;
    }
    j = sym_1.symbol[j - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.adr);
    goto L88888;
L7510:
    emit_(&opcod_1.xch, &opcod_1.opr);
    goto L88888;

/*     <EXPRESSION> ::= <LOGICAL FACTOR> */
/*     <EXPRESSION> ::= <EXPRESSION> OR <LOGICAL FACTOR> */
L7600:
    i__ = opcod_1.ior;
    goto L88888;
/*     <EXPRESSION> ::= <EXPRESSION> XOR <LOGICAL FACTOR> */
L7700:
    i__ = opcod_1.xor;
    goto L88888;
/*     <LOGICAL FACTOR> ::= <LOGICAL SECONDARY> */
/*     <LOGICAL FACTOR> ::= <LOGICAL FACTOR> AND <LOGICAL SECONDARY> */
L7900:
    i__ = opcod_1.and;
    goto L88888;
/*     <LOGICAL SECONDARY> ::= <LOGICAL PRIMARY> */
/*     <LOGICAL SECONDARY> ::= NOT <LOGICAL PRIMARY> */
L8100:
    i__ = opcod_1.not;
    goto L88888;
/*     <LOGICAL PRIMARY> ::= <STRING EXPRESSION> */
/*     <LOGICAL PRIMARY> ::= <STRING EXPRESSION> <RELATION> <STRING EXPRE */
L8300:
    i__ = stacks_1.fixv[stacks_1.mp];
    goto L88888;

/*     * NOTE THAT THE CODE THAT FOLLOWS DEPENDS UPON FIXED PRODUCTION # */
L8400:
    stacks_1.fixv[stacks_1.mp - 1] = *prod - 96 + opcod_1.eql;
/*     THE 96 COMES FROM THE PRODUCTION NUMBER FOR = */
    goto L99999;
/*     <RELATION> ::= = */
/*     <RELATION> ::= < */
/*     <RELATION> ::= > */
/*     <RELATION> ::= < > */
/*     <RELATION> ::= < = */
/*     <RELATION> ::= > = */
/*     <STRING EXPRESSION> ::= <ARITHMETIC EXPRESSION> */

/*     <ARITHMETIC EXPRESSION> ::= <TERM> */
/*     * NOTE THAT THE FOLLOWING CODE DPENDS UPON FIXED PROD NUMBERS */
L9300:
    i__ = *prod - 103 + opcod_1.add;
/*     *** THE VALUES OF ADC AND SUB WERE ACCIDENTILY REVERSED *** */
    if (i__ == opcod_1.adc || i__ == opcod_1.sub) {
	i__ = 5 - i__;
    }
    goto L88888;
/*     <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> + <TERM> */
/*     <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> - <TERM> */
/*     <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> PLUS <TERM> */
/*     <ARITHMETIC EXPRESSION> ::= <ARITHMETIC EXPRESSION> MINUS <TERM> */
/*     <ARITHMETIC EXPRESSION> ::= - <TERM> */
L9400:
    emit_(&c__0, &opcod_1.lit);
    emit_(&opcod_1.xch, &opcod_1.opr);
    i__ = opcod_1.sub;
    goto L88888;

/*     <TERM> ::= <PRIMARY> */
/*     * NOTE THAT THE FOLLOWING CODE DEPENDS UPON FIXED PROD NUMBERS */
L10000:
    i__ = *prod - 109 + opcod_1.mul;
    goto L88888;
/*     <TERM> ::= <TERM> * <PRIMARY> */
/*     <TERM> ::= <TERM> / <PRIMARY> */
/*     <TERM> ::= <TERM> MOD <PRIMARY> */
/*     <PRIMARY> ::= <CONSTANT> */
L10300:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    i__ = sym_1.symbol[i__ - 2];
    i__1 = shr_(&i__, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    goto L99999;
/*     <PRIMARY> ::= . <CONSTANT> */
L10310:
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    emit_(&opcod_1.dat, &opcod_1.opr);
    emit_(&c__0, &opcod_1.def);
/*     DROP THROUGH TO NEXT PRODUCTION */
/*     <PRIMARY> ::= <CONSTANT HEAD> <CONSTANT> ) */
/*     ENTER HERE FROM ABOVE ALSO */
L10320:
    i__ = stacks_1.fixv[stacks_1.mp];
    i__1 = -i__;
    i__ = wrdata_(&i__1);
    emit_(&opcod_1.dat, &opcod_1.opr);
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    emit_(&i__, &opcod_1.def);
    goto L99999;
/*     <PRIMARY> ::= <VARIABLE> */
L10400:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    if (i__ > 0) {
	goto L10450;
    }
    if (i__ == 0) {
	goto L99999;
    }
/*     SUBSCRIPTED VARIABLE */
    i__ = opcod_1.lod;
    goto L88888;
/*     SIMPLE VARIABLE */
L10450:
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.vlu);
    j = sym_1.symbol[i__];
    j = right_(&j, &c__4);
    if (j == types_1.proc) {
	emit_(&opcod_1.pro, &opcod_1.opr);
    }
    if (j == types_1.intr) {
	emit_(&opcod_1.bif, &opcod_1.opr);
    }
    goto L99999;
/*     <PRIMARY> ::= . <VARIABLE> */
L10500:
    i__ = stacks_1.fixv[stacks_1.sp - 1];
    if (i__ > 0) {
	goto L10520;
    }
/*     SUBSCRIPTED - CHANGE PRECISION TO 2 */
    if (i__ == 0) {
	goto L10530;
    }
L10510:
    i__ = opcod_1.cva;
    goto L88888;

L10520:
    j = (i__1 = sym_1.symbol[i__], abs(i__1));
    if (right_(&j, &c__4) == types_1.varb) {
	goto L10540;
    }
L10530:
    error_(&c__28, &c__1);
    goto L99999;
L10540:
    j = sym_1.symbol[i__ - 2];
    i__1 = shr_(&j, &c__16);
    emit_(&i__1, &opcod_1.adr);
    goto L10510;
/*     <PRIMARY> ::= ( <EXPRESSION> ) */
/*     <CONSTANT HEAD> ::= . ( */
L10550:
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
    emit_(&opcod_1.dat, &opcod_1.opr);
    emit_(&c__0, &opcod_1.def);
    goto L99999;
/*     <CONSTANT HEAD> ::= <CONSTANT HEAD> <CONSTANT> , */
L10560:
    i__ = stacks_1.fixv[stacks_1.mp];
    i__1 = -i__;
    i__ = wrdata_(&i__1);
    goto L99999;
/*     <VARIABLE> ::= <IDENTIFIER> */
L10600:
    i__ = lookup_(&stacks_1.mp);
    if (i__ != 0) {
	goto L10650;
    }
    error_(&c__29, &c__1);
    i__ = enter_(&types_1.varb);
L10650:
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    j = (i__1 = sym_1.symbol[i__], abs(i__1));
    j = right_(&j, &c__4);
    if (j == types_1.label) {
	error_(&c__47, &c__1);
    }
    if (j != types_1.proc && j != types_1.intr) {
	goto L99999;
    }
    if (shr_(&sym_1.symbol[i__], &c__8) != 0) {
	error_(&c__38, &c__1);
    }
    i__1 = shr_(&sym_1.symbol[i__], &c__4);
    j = right_(&i__1, &c__4);
/*     IN THE STATEMENTS BELOW, 30 IS THE TOKEN FOR 'CALL' */
    if (stacks_1.pstack[stacks_1.mp - 2] == 30 && j != 0) {
	error_(&c__42, &c__1);
    }
    if (stacks_1.pstack[stacks_1.mp - 2] != 30 && j == 0) {
	error_(&c__43, &c__1);
    }
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    i__ = shl_(&i__, &c__15) + i__ + 1;
    stacks_1.fixc[stacks_1.mp - 1] = 0;
    goto L10760;
/*     <VARIABLE> ::= <SUBSCRIPT HEAD> <EXPRESSION> ) */
L10700:
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    if (i__ < 0) {
	goto L10740;
    }
    stacks_1.fixv[stacks_1.mp - 1] = -i__;
    i__ = opcod_1.inx;
    goto L88888;
L10740:
    i__ = -i__;
    i__1 = right_(&i__, &c__15);
    emit_(&i__1, &opcod_1.adr);
    if (stacks_1.fixc[stacks_1.mp - 1] != 1) {
	emit_(&opcod_1.std, &opcod_1.opr);
    }
    if ((i__1 = stacks_1.fixc[stacks_1.mp - 1], abs(i__1)) == 0) {
	error_(&c__37, &c__1);
    }
    if ((i__1 = stacks_1.fixc[stacks_1.mp - 1], abs(i__1)) > 1) {
	error_(&c__38, &c__1);
    }
L10760:
    i__1 = shr_(&i__, &c__15);
    emit_(&i__1, &opcod_1.vlu);
    stacks_1.fixc[stacks_1.mp - 1] = shr_(&i__, &c__15);
    i__ = opcod_1.pro;
    stacks_1.fixv[stacks_1.mp - 1] = 0;
    goto L88888;
/*     <SUBSCRIPT HEAD> ::= <IDENTIFIER> ( */
L10800:
    i__ = lookup_(&stacks_1.mp);
    if (i__ != 0) {
	goto L10840;
    }
    error_(&c__30, &c__1);
    i__ = enter_(&types_1.varb);
L10840:
    j = (i__1 = sym_1.symbol[i__], abs(i__1));
    j = right_(&j, &c__4);
    if (j == types_1.varb) {
	goto L10860;
    }
    if (j == types_1.proc || j == types_1.intr) {
	goto L10880;
    }
    error_(&c__31, &c__1);
L10860:
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    i__ = sym_1.symbol[i__ - 2];
    i__1 = shr_(&i__, &c__16);
    emit_(&i__1, &opcod_1.adr);
    goto L99999;
L10880:
    stacks_1.fixc[stacks_1.mp - 1] = shr_(&sym_1.symbol[i__], &c__8);
    if (j == types_1.intr) {
	stacks_1.fixc[stacks_1.mp - 1] = -stacks_1.fixc[stacks_1.mp - 1];
    }
    i__1 = shr_(&sym_1.symbol[i__], &c__4);
    j = right_(&i__1, &c__4);
/*     IN THE STATEMENTS BELOW, 30 IS THE TOKEN FOR 'CALL' */
    if (stacks_1.pstack[stacks_1.mp - 2] == 30 && j != 0) {
	error_(&c__42, &c__1);
    }
    if (stacks_1.pstack[stacks_1.mp - 2] != 30 && j == 0) {
	error_(&c__43, &c__1);
    }
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    stacks_1.fixv[stacks_1.mp - 1] = -(shl_(&i__, &c__15) + i__ + 1);
    goto L99999;
/*     <SUBSCRIPT HEAD> ::= <SUBSCRIPT HEAD> <EXPRESSION> , */
L10900:
    i__ = -stacks_1.fixv[stacks_1.mp - 1];
    if (i__ > 0) {
	goto L10910;
    }
    error_(&c__32, &c__1);
    goto L99999;
L10910:
    stacks_1.fixv[stacks_1.mp - 1] = -(i__ + 1);
    j = right_(&i__, &c__15);
    emit_(&j, &opcod_1.adr);
    if (stacks_1.fixc[stacks_1.mp - 1] != 0) {
	goto L10920;
    }
    error_(&c__37, &c__1);
    goto L99999;
L10920:
    if (stacks_1.fixc[stacks_1.mp - 1] != 2) {
	emit_(&opcod_1.std, &opcod_1.opr);
    }
    i__ = -1;
    if (stacks_1.fixc[stacks_1.mp - 1] < 0) {
	i__ = 1;
    }
    stacks_1.fixc[stacks_1.mp - 1] += i__;
    goto L99999;
/*     <CONSTANT> ::= <STRING> */
L11000:
/*     MAY WISH TO TREAT THIS STRING AS A CONSTANT LATER */
    j = stacks_1.var[stacks_1.sp - 1];
    i__ = shr_(&j, &c__12);
    l = 3;
    k = 0;
    if (i__ <= 0 || i__ > 2) {
	goto L11010;
    }
/*         CONVERT INTERNAL CHARACTER FORM TO ASCII */
    j = right_(&j, &c__12);
    k = 0;
    i__1 = i__;
    for (l = 1; l <= i__1; ++l) {
	ltemp = j + l - 1;
	kp = stacks_1.varc[ltemp - 1];
	k = (k << 8) + asc_1.ascii[kp - 1];
/* L11005: */
    }
    l = i__;
L11010:
    i__ = lookup_(&stacks_1.sp);
    if (i__ == 0) {
	i__1 = shl_(&k, &c__8) + shl_(&l, &c__4) + types_1.liter;
	i__ = enter_(&i__1);
    }
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
/*     <CONSTANT> :: = <NUMBER> */
L11100:
    i__ = lookup_(&stacks_1.sp);
    if (i__ != 0) {
	goto L11120;
    }
/*     ENTER NUMBER INTO SYMBOL TABLE */
    i__ = stacks_1.fixv[stacks_1.mp - 1];
    j = 1;
    if (i__ > 255) {
	j = 2;
    }
    i__1 = shl_(&i__, &c__8) + shl_(&j, &c__4) + types_1.liter + 1;
    i__ = enter_(&i__1);
L11120:
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
/*     <TO>  ::=  TO */
L11200:
    i__ = stacks_1.fixv[stacks_1.mp - 4];
    if (i__ > 0) {
	goto L11210;
    }
    error_(&c__33, &c__1);
    stacks_1.fixv[stacks_1.mp - 1] = 1;
    goto L99999;
L11210:
    i__ = sym_1.symbol[i__ - 2];
    i__ = shr_(&i__, &c__16);
    stacks_1.fixv[stacks_1.mp - 4] = i__;
    emit_(&i__, &opcod_1.adr);
    emit_(&opcod_1.std, &opcod_1.opr);
    i__1 = -(types_1.label + 64);
    j = enter_(&i__1);
    j = shr_(&sym_1.symbol[j - 2], &c__16);
    emit_(&j, &opcod_1.def);
    stacks_1.fixv[stacks_1.mp - 1] = j;
    emit_(&i__, &opcod_1.vlu);
    goto L99999;
/*     <BY>  ::=  BY */
L11300:
    emit_(&opcod_1.leq, &opcod_1.opr);
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
/*     SAVE SYMBOL NUMBER AT <TO> (END LOOP NUMBER) */
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    j = stacks_1.fixv[stacks_1.mp - 3];
    stacks_1.fixv[stacks_1.mp - 3] = i__;
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.trc, &opcod_1.opr);
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    stacks_1.fixv[stacks_1.mp - 1] = shl_(&j, &c__14) + i__;
/*     <BY> IS (TO NUMBER/STATEMENT NUMBER) */
    emit_(&i__, &opcod_1.vlu);
    emit_(&opcod_1.tra, &opcod_1.opr);
/*     NOW DEFINE BY LABEL */
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
/*     SAVE BY LABEL IN <TO> AS BRANCH BACK NUMBER */
    stacks_1.fixv[stacks_1.mp - 3] = shl_(&i__, &c__14) + stacks_1.fixv[
	    stacks_1.mp - 3];
    emit_(&i__, &opcod_1.def);
    goto L99999;
/*     <WHILE>  ::=  WHILE */
L11400:
    i__1 = -(types_1.label + 64);
    i__ = enter_(&i__1);
    i__ = shr_(&sym_1.symbol[i__ - 2], &c__16);
    emit_(&i__, &opcod_1.def);
    stacks_1.fixv[stacks_1.mp - 1] = i__;
    goto L99999;
L88888:
    emit_(&i__, &opcod_1.opr);
L99999:
    return 0;
} /* synth_ */

integer gnc_(integer *q)
{
    /* Format strings */
    static char fmt_1000[] = "(80a1)";

    /* System generated locals */
    integer ret_val, i__1;

    /* Builtin functions */
    integer s_rsfe(cilist *), do_fio(integer *, char *, ftnlen), e_rsfe(void);

    /* Local variables */
    static integer i__, j, k, l, ii, lp;
    extern integer shl_(integer *, integer *), shr_(integer *, integer *);
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer icon_(integer *);
    extern /* Subroutine */ int emit_(integer *, integer *), form_(integer *, 
	    integer *, integer *, integer *, integer *);
    static integer ifile;
    extern integer right_(integer *, integer *);
    extern /* Subroutine */ int error_(integer *, integer *), writel_(integer 
	    *), conout_(integer *, integer *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___123 = { 0, 0, 0, fmt_1000, 0 };


/*     GET NEXT CHARACTER FROM THE INPUT STREAM (OR 0 IF */
/*     NO CHARACTER IS FOUND) */

L4000:
    if (macro_1.curmac <= macro_1.maxmac) {
	goto L2000;
    }
    if (files_1.ibp <= cntrl_1.contrl[28]) {
	goto L200;
    }
/*     READ ANOTHER RECORD FROM COMMAND STREAM */
    if (cntrl_1.contrl[30] == 0) {
	goto L1;
    }
    if (cntrl_1.contrl[19] == 1) {
	pad_(&c__0, &c__1, &c__1);
    }
    writel_(&c__0);
L1:
    ifile = cntrl_1.contrl[19];
    io___123.ciunit = ifile;
    s_rsfe(&io___123);
    do_fio(&c__80, (char *)&files_1.ibuff[0], (ftnlen)sizeof(integer));
    e_rsfe();
/* L100: */
    for (i__ = 1; i__ <= 80; ++i__) {
	j = files_1.ibuff[i__ - 1];
	j = icon_(&j);
	files_1.ibuff[i__ - 1] = files_1.itran[j - 1];
/* L110: */
    }

    lp = cntrl_1.contrl[22];
    if (files_1.ibuff[lp - 1] == 38) {
	goto L300;
    }
L115:
    files_1.ibp = lp;
    ++cntrl_1.contrl[13];
    emit_(&cntrl_1.contrl[13], &opcod_1.lin);
    if (cntrl_1.contrl[26] == 0) {
	goto L200;
    }
    conout_(&c__0, &c__5, &cntrl_1.contrl[13], &c__10);
    i__1 = blk_1.curblk - 1;
    conout_(&c__1, &c_n3, &i__1, &c__10);
    pad_(&c__1, &c__1, &c__3);
    if (cntrl_1.contrl[22] == 1) {
	goto L120;
    }
    i__1 = cntrl_1.contrl[22] - 1;
    form_(&c__1, files_1.ibuff, &c__1, &i__1, &c__80);
    pad_(&c__1, &c__1, &c__3);
L120:
    form_(&c__1, files_1.ibuff, &cntrl_1.contrl[22], &cntrl_1.contrl[28], &
	    c__80);
    if (cntrl_1.contrl[28] == 80) {
	goto L130;
    }
    pad_(&c__1, &c__1, &c__3);
    i__1 = cntrl_1.contrl[28] + 1;
    form_(&c__1, files_1.ibuff, &i__1, &c__80, &c__80);
L130:
L200:
    ret_val = files_1.ibuff[files_1.ibp - 1];
    ++files_1.ibp;
    return ret_val;
L300:
    if (files_1.ibuff[1] == 1) {
	goto L115;
    }
    ++lp;
/*     SCANNER PARAMETERS FOLLOW */
L305:
    j = files_1.ibuff[lp - 1];
    if (j == 38) {
	goto L400;
    }
    ++lp;

    for (i__ = lp; i__ <= 80; ++i__) {
	ii = i__;
	if (files_1.ibuff[i__ - 1] == 39) {
	    goto L330;
	}
	if (files_1.ibuff[i__ - 1] == 38) {
	    goto L315;
	}
/* L310: */
    }

L315:
    k = cntrl_1.contrl[j - 1];
    lp = ii;
    if (k > 1 || k < 0) {
	goto L320;
    }
    cntrl_1.contrl[j - 1] = 1 - k;
    goto L325;
L320:
    error_(&c__34, &c__1);
L325:
    if (ii == 80) {
	goto L1;
    }
    ++lp;
    goto L305;
L330:
    k = 0;
    ++ii;

    for (i__ = ii; i__ <= 80; ++i__) {
	lp = ii;
	l = files_1.ibuff[i__ - 1];
	if (l <= 1) {
	    goto L340;
	}
	if (l > 11) {
	    goto L350;
	}
	k = k * 10 + (l - 2);
L340:
	;
    }

L350:
    cntrl_1.contrl[j - 1] = k;
/*     MAY BE MORE $ IN INPUT LINE */
L360:
    ii = lp + 1;
    for (i__ = ii; i__ <= 80; ++i__) {
	lp = i__;
	if (files_1.ibuff[i__ - 1] == 38) {
	    goto L380;
	}
/* L370: */
    }
/*     NO MORE $ FOUND */
    goto L1;
L380:
    ++lp;
    goto L305;
L400:
/*     DISPLAY $ PARAMETERS */
    l = 2;
    k = 64;
    ++lp;
    j = files_1.ibuff[lp - 1];
    if (j == 1) {
	goto L410;
    }
    l = j;
    k = j;
L410:
    i__1 = k;
    for (i__ = l; i__ <= i__1; ++i__) {
	j = cntrl_1.contrl[i__ - 1];
	if (j < 0) {
	    goto L420;
	}
	pad_(&c__0, &c__38, &c__1);
	pad_(&c__1, &i__, &c__1);
	pad_(&c__1, &c__39, &c__1);
	conout_(&c__2, &c_n10, &j, &c__10);
L420:
	;
    }
    if (cntrl_1.contrl[30] != 0) {
	pad_(&c__0, &c__1, &c__1);
    }
    writel_(&c__0);
    goto L360;
/* L990: */
    if (files_1.inptr < 1) {
	goto L999;
    }
    cntrl_1.contrl[15] = 0;
    --files_1.inptr;
    cntrl_1.contrl[19] = files_1.instk[files_1.inptr - 1];
    goto L1;
L999:
    ret_val = 0;
    return ret_val;
L2000:
    i__ = macro_1.macros[macro_1.curmac - 1];
    j = shr_(&i__, &c__12);
    i__ = right_(&i__, &c__12);
    if (j >= i__) {
	goto L2100;
    }
    ++j;
    ret_val = macro_1.macros[j - 1];
    macro_1.macros[macro_1.curmac - 1] = shl_(&j, &c__12) + i__;
    return ret_val;
L2100:
    ++macro_1.curmac;
    goto L4000;
} /* gnc_ */

/* Subroutine */ int writel_(integer *nspac)
{
    /* Format strings */
    static char fmt_1000[] = "(\002 \002,121a1)";

    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static integer i__, j, np;
    extern integer imin_(integer *, integer *);
    static integer ofile, nblank, nspace;

    /* Fortran I/O blocks */
    static cilist io___136 = { 0, 0, 0, fmt_1000, 0 };



    nspace = *nspac;
    np = cntrl_1.contrl[35] - 1;
    if (files_1.obp <= np) {
	goto L998;
    }
    nblank = 1;

    i__1 = files_1.obp;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = files_1.obuff[i__ - 1];
	if (j != 1) {
	    nblank = i__;
	}
/* L5: */
	files_1.obuff[i__ - 1] = files_1.otran[j - 1];
    }

    files_1.obp = imin_(&cntrl_1.contrl[14], &nblank);
    ofile = cntrl_1.contrl[25] + 10;
L9:
/* L10: */
    io___136.ciunit = ofile;
    s_wsfe(&io___136);
    i__1 = files_1.obp;
    for (i__ = 1; i__ <= i__1; ++i__) {
	do_fio(&c__1, (char *)&files_1.obuff[i__ - 1], (ftnlen)sizeof(integer)
		);
    }
    e_wsfe();
/* L11: */
    if (nspace <= 0) {
	goto L998;
    }

    i__1 = files_1.obp;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L12: */
	files_1.obuff[i__ - 1] = files_1.otran[0];
    }
    --nspace;
    goto L9;
L998:
    if (np <= 0) {
	goto L997;
    }
    i__1 = np;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L999: */
	files_1.obuff[i__ - 1] = 1;
    }
L997:
    files_1.obp = np;
    return 0;
/* L1001: */
} /* writel_ */

integer icon_(integer *i__)
{
    /* System generated locals */
    integer ret_val;

    /* Local variables */
    static integer j, k;

/*     ICON IS CALLED WITH AN INTEGER VARIABLE I WHICH CONTAINS A */
/*     CHARACTER READ WITH AN A1 FORMAT.  ICON MUST REDUCE THIS CHARACTER */
/*     TO A VALUE SOMEWHERE BETWEEN 1 AND 256.  NORMALLY, THIS WOULD BE */
/*     ACCOMPLISHED BY SHIFTING THE CHARACTER TO THE RIGHTMOST BIT POSI- */
/*     TIONS OF THE WORD AND MASKING THE RIGHT 8 BITS.  IT IS DONE RATHER */
/*     INEFFICIENTLY HERE, HOWEVER, TO GAIN SOME MACHINE INDEPENDENCE. */
    for (k = 1; k <= 52; ++k) {
	j = k;
	if (*i__ == files_1.otran[k - 1]) {
	    goto L200;
	}
/* L100: */
    }
    j = 1;
L200:
    ret_val = j;
    return ret_val;
} /* icon_ */

/* Subroutine */ int decibp_(void)
{
    static integer i__;

    if (macro_1.curmac <= macro_1.maxmac) {
	goto L100;
    }
    --files_1.ibp;
    return 0;
L100:
    i__ = macro_1.macros[macro_1.curmac - 1];
    macro_1.macros[macro_1.curmac - 1] = i__ - 4096;
    return 0;
} /* decibp_ */

/* Subroutine */ int conv_(integer *prec)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);

    /* Local variables */
    static integer i__, j;

    if (scanc_1.stype <= 1) {
	goto L200;
    }
    scanc_1.value = 0;
    i__1 = scanc_1.acclen;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = scanc_1.accum[i__ - 1] - 2;
/* L100: */
	scanc_1.value = scanc_1.value * scanc_1.stype + j;
    }
    if (*prec <= 0) {
	goto L999;
    }
    i__ = pow_ii(&c__2, prec);
    if (scanc_1.value < i__) {
	goto L999;
    }
L200:
    scanc_1.value = -1;
L999:
    return 0;
} /* conv_ */

integer imin_(integer *i__, integer *j)
{
    /* System generated locals */
    integer ret_val;

    if (*i__ < *j) {
	goto L10;
    }
    ret_val = *j;
    goto L20;
L10:
    ret_val = *i__;
L20:
    return ret_val;
} /* imin_ */

/* Subroutine */ int form_(integer *cc, integer *chars, integer *start, 
	integer *finish, integer *length)
{
    static integer i__, j;
    extern /* Subroutine */ int writel_(integer *);

/*     CC = 0 DUMP BUFFER, GO TO NEXT LINE */
/*     CC = 1 APPEND TO CURRENT BUFFER */
/*     CC = 2 DELETE LEADING BLANKS AND APPEND */
    /* Parameter adjustments */
    --chars;

    /* Function Body */
    j = *start;
    i__ = *cc + 1;
    switch (i__) {
	case 1:  goto L100;
	case 2:  goto L200;
	case 3:  goto L300;
    }
L100:
    writel_(&c__0);
L200:
    if (j > *finish) {
	goto L999;
    }
    ++files_1.obp;
    files_1.obuff[files_1.obp - 1] = chars[j];
    ++j;
    if (files_1.obp >= cntrl_1.contrl[33]) {
	goto L100;
    }
    goto L200;
L300:
    if (j > *finish) {
	goto L999;
    }
    if (chars[j] != 1) {
	goto L200;
    }
    ++j;
    goto L300;
L999:
    return 0;
} /* form_ */

/* Subroutine */ int conout_(integer *cc, integer *k, integer *n, integer *
	base)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, t[20], ip, kp, np;
    extern integer imin_(integer *, integer *);
    extern /* Subroutine */ int form_(integer *, integer *, integer *, 
	    integer *, integer *);
    static logical zsup;
    static integer ltemp;

    np = *n;
    zsup = *k < 0;
    i__1 = abs(*k);
    kp = imin_(&i__1, &c__19);

    i__1 = kp;
    for (i__ = 1; i__ <= i__1; ++i__) {
/* L10: */
	t[i__ - 1] = 1;
    }

    ip = kp + 1;

    i__1 = kp;
    for (i__ = 1; i__ <= i__1; ++i__) {
	ltemp = ip - i__;
	t[ltemp - 1] = np % *base + 2;
	np /= *base;
	if (zsup && np == 0) {
	    goto L30;
	}
/* L20: */
    }

L30:
    if (*base == 8) {
	goto L40;
    }
    if (*base == 2) {
	goto L45;
    }
    if (*base != 16) {
	goto L50;
    }
    ++kp;
    t[kp - 1] = 19;
    goto L50;
L40:
    ++kp;
    t[kp - 1] = 28;
    goto L50;
L45:
    ++kp;
    t[kp - 1] = 13;
L50:
    form_(cc, t, &c__1, &kp, &c__20);
    return 0;
} /* conout_ */

/* Subroutine */ int pad_(integer *cc, integer *chr, integer *i__)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer j, k, t[20];
    extern integer imin_(integer *, integer *);
    extern /* Subroutine */ int form_(integer *, integer *, integer *, 
	    integer *, integer *);

    j = imin_(i__, &c__20);

    i__1 = j;
    for (k = 1; k <= i__1; ++k) {
/* L10: */
	t[k - 1] = *chr;
    }

    form_(cc, t, &c__1, &j, &c__20);
    return 0;
} /* pad_ */

/* Subroutine */ int stackc_(integer *i__)
{
    extern /* Subroutine */ int error_(integer *, integer *);

    ++files_1.inptr;
    if (files_1.inptr > 7) {
	goto L100;
    }
    files_1.instk[files_1.inptr - 1] = cntrl_1.contrl[19];
    cntrl_1.contrl[19] = *i__;
    return 0;
L100:
    error_(&c__35, &c__5);
    return 0;
} /* stackc_ */

/* Subroutine */ int enterb_(void)
{
    extern integer shl_(integer *, integer *);
    extern /* Subroutine */ int error_(integer *, integer *);

/*     ENTRY TO BLOCK GOES THROUGH HERE */
    ++blk_1.curblk;
    blk_1.proctp[blk_1.curblk - 1] = blk_1.proctp[blk_1.curblk - 2];
    if (blk_1.curblk <= blk_1.maxblk) {
	goto L100;
    }
    error_(&c__36, &c__5);
    blk_1.curblk = 1;
L100:
    blk_1.block[blk_1.curblk - 1] = sym_1.symtop;
    blk_1.dopar[blk_1.curblk - 1] = 0;
/*     SAVE THE MACRO PARAMETERS */
    blk_1.macblk[blk_1.curblk - 1] = shl_(&macro_1.mactop, &c__12) + 
	    macro_1.curmac;
    blk_1.blksym = sym_1.symtop;
    return 0;
} /* enterb_ */

/* Subroutine */ int dumpin_(void)
{
    static integer i__, j, k, jp, kp, kq, kt;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *);
    extern integer shr_(integer *, integer *);
    extern /* Subroutine */ int form_(integer *, integer *, integer *, 
	    integer *, integer *);
    extern integer right_(integer *, integer *), wrdata_(integer *);
    extern /* Subroutine */ int writel_(integer *), conout_(integer *, 
	    integer *, integer *, integer *);

/*     DUMP THE INITIALIZATION TABLE */
/*     WRDATA(X) WRITES THE DATA AT LOCATION X IN SYMBOL TABLE */
/*     AND RETURNS THE NUMBER OF BYTES WRITTEN */
    if (cntrl_1.contrl[29] != 2) {
	goto L1000;
    }
    i__ = sym_1.symabs + 1;
L100:
    --i__;
    if (i__ <= sym_1.maxsym) {
	goto L1000;
    }
    j = sym_1.symbol[i__ - 1];
    jp = right_(&j, &c__15);
    j = shr_(&j, &c__15);
    pad_(&c__0, &c__1, &c__1);
    writel_(&c__0);
    form_(&c__0, messag_1.mssg, &c__42, &c__48, &c__77);
    pad_(&c__1, &c__30, &c__1);
    conout_(&c__1, &c__5, &j, &c__10);
    pad_(&c__1, &c__1, &c__1);
    pad_(&c__1, &c__39, &c__1);
L200:
    if (jp <= 0) {
	goto L100;
    }
    --jp;
    --i__;
    pad_(&c__1, &c__1, &c__1);
    pad_(&c__1, &c__30, &c__1);
/*         GET THE SYMBOL NUMBER */
    k = shr_(&sym_1.symbol[i__ - 1], &c__16);
    conout_(&c__1, &c__5, &k, &c__10);
    goto L200;
L1000:
    writel_(&c__0);
    kt = cntrl_1.contrl[25];
    cntrl_1.contrl[25] = cntrl_1.contrl[31];
    kq = cntrl_1.contrl[33];
    cntrl_1.contrl[33] = cntrl_1.contrl[32];
/*     READY TO WRITE THE INITIALIZATION TABLE */
    i__ = sym_1.symabs + 1;
L3000:
    pad_(&c__1, &c__41, &c__1);
/* L3100: */
    --i__;
    if (i__ <= sym_1.maxsym) {
	goto L4000;
    }
    j = sym_1.symbol[i__ - 1];
    jp = right_(&j, &c__15);
    j = shr_(&j, &c__15);
/*     WRITE SYMBOL NUMBERS */
    for (k = 1; k <= 3; ++k) {
	kp = j % 32 + 2;
	pad_(&c__1, &kp, &c__1);
/* L3300: */
	j /= 32;
    }

/*     WRITE OUT DATA CORRESPONDING TO EACH CONSTANT */
L3400:
    if (jp <= 0) {
	goto L3000;
    }
    --jp;
    --i__;
    k = right_(&sym_1.symbol[i__ - 1], &c__16);
    k = wrdata_(&k);
    goto L3400;

L4000:
    pad_(&c__1, &c__41, &c__1);
    writel_(&c__0);
    cntrl_1.contrl[25] = kt;
    cntrl_1.contrl[33] = kq;
    return 0;
} /* dumpin_ */

/* Subroutine */ int error_(integer *i__, integer *level)
{
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), form_(
	    integer *, integer *, integer *, integer *, integer *), writel_(
	    integer *), conout_(integer *, integer *, integer *, integer *);

/*     I IS ERROR NUMBER, LEVEL IS SEVERITY CODE */
/*     TERR CONTAINS THE TERMINAL ERROR MESSAGE - COMPILATION TERMINATED */
    ++cntrl_1.contrl[0];
    form_(&c__0, messag_1.mssg, &c__21, &c__21, &c__41);
    conout_(&c__1, &c__5, &cntrl_1.contrl[13], &c__10);
    form_(&c__1, messag_1.mssg, &c__22, &c__22, &c__41);
    pad_(&c__1, &c__1, &c__2);
    form_(&c__1, messag_1.mssg, &c__16, &c__20, &c__41);
    pad_(&c__1, &c__1, &c__1);
    conout_(&c__2, &c_n4, i__, &c__10);
    pad_(&c__1, &c__1, &c__2);
    form_(&c__1, messag_1.mssg, &c__23, &c__26, &c__41);
    pad_(&c__1, &c__1, &c__1);
    form_(&c__1, scanc_1.accum, &c__1, &scanc_1.acclen, &c__32);
    writel_(&c__0);
/*     CHECK FOR TERMINAL ERROR - LEVEL GREATER THAN 4 */
    if (*level <= 4) {
	goto L999;
    }
/*         TERMINATE COMPILATION */
    form_(&c__0, terrm_1.terr, &c__1, &c__22, &c__22);
    writel_(&c__0);
    stacks_1.compil = FALSE_;
L999:
    return 0;
} /* error_ */

integer shr_(integer *i__, integer *j)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);

    ret_val = *i__ / pow_ii(&c__2, j);
    return ret_val;
} /* shr_ */

integer shl_(integer *i__, integer *j)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);

    ret_val = *i__ * pow_ii(&c__2, j);
    return ret_val;
} /* shl_ */

integer right_(integer *i__, integer *j)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);

    ret_val = *i__ % pow_ii(&c__2, j);
    return ret_val;
} /* right_ */

/* Subroutine */ int sdump_(void)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, j;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), form_(
	    integer *, integer *, integer *, integer *, integer *), prsym_(
	    integer *, integer *), writel_(integer *);

/*     CHECK FOR STACK DUMP BYPASS */
    if (cntrl_1.contrl[12] != 0) {
	goto L400;
    }
    form_(&c__0, messag_1.mssg, &c__29, &c__41, &c__41);
    if (stacks_1.sp < 5) {
	goto L200;
    }
    i__1 = stacks_1.sp;
    for (i__ = 5; i__ <= i__1; ++i__) {
	j = stacks_1.pstack[i__ - 1];
	prsym_(&c__1, &j);
	pad_(&c__1, &c__1, &c__1);
/* L100: */
    }
L200:
    writel_(&c__0);
L400:
    return 0;
} /* sdump_ */

/* Subroutine */ int redpr_(integer *prod, integer *sym)
{
    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__;
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), prsym_(
	    integer *, integer *), writel_(integer *), conout_(integer *, 
	    integer *, integer *, integer *);

    conout_(&c__0, &c_n5, prod, &c__10);
    pad_(&c__1, &c__1, &c__2);
    prsym_(&c__1, sym);
    pad_(&c__1, &c__1, &c__1);
    pad_(&c__1, &c__51, &c__2);
    pad_(&c__1, &c__39, &c__1);
    i__1 = stacks_1.sp;
    for (i__ = stacks_1.mp; i__ <= i__1; ++i__) {
	pad_(&c__1, &c__1, &c__1);
/* L50: */
	prsym_(&c__1, &stacks_1.pstack[i__ - 1]);
    }
    writel_(&c__0);
    return 0;
} /* redpr_ */

/* Subroutine */ int emit_(integer *val, integer *typ)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, k, l, jp, kp, lp;
    extern integer shr_(integer *, integer *), shl_(integer *, integer *);
    extern /* Subroutine */ int pad_(integer *, integer *, integer *), form_(
	    integer *, integer *, integer *, integer *, integer *);
    static integer lcode;
    extern integer right_(integer *, integer *);
    extern /* Subroutine */ int error_(integer *, integer *), writel_(integer 
	    *), conout_(integer *, integer *, integer *, integer *);

/*     TYP      MEANING */
/*      0      OPERATOR */
/*      1      LOAD ADDRESS */
/*      2      LOAD VALUE */
/*      3      DEFINE LOCATION */
/*      4      LITERAL VALUE */
/*      5      LINE NUMBER */
/*      6      UNUSED */
/*      7        " */
    ++pole_1.poltop;
    if (pole_1.poltop <= pole_1.maxpol) {
	goto L100;
    }
    error_(&c__37, &c__1);
    pole_1.poltop = 1;
L100:
    ++pole_1.polcnt;
    if (cntrl_1.contrl[17] == 0) {
	goto L1200;
    }
    conout_(&c__0, &c_n5, &pole_1.polcnt, &c__10);
    pad_(&c__1, &c__1, &c__1);
    i__ = *typ * 3 + 1;
    i__1 = i__ + 2;
    form_(&c__1, pole_1.polchr, &i__, &i__1, &c__18);
    pad_(&c__1, &c__1, &c__1);
    i__ = *typ + 1;
    j = 1;
    switch (i__) {
	case 1:  goto L1000;
	case 2:  goto L1001;
	case 3:  goto L1001;
	case 4:  goto L1001;
	case 5:  goto L1004;
	case 6:  goto L1004;
    }
L1000:
    j = opcod_1.opcval[*val];
    for (i__ = 1; i__ <= 3; ++i__) {
	i__1 = (3 - i__) * 6;
	k = shr_(&j, &i__1);
	i__1 = right_(&k, &c__6);
	pad_(&c__1, &i__1, &c__1);
/* L200: */
    }
    goto L1100;
L1001:
    j = 30;
L1004:
    pad_(&c__1, &j, &c__1);
    conout_(&c__1, &c__5, val, &c__10);
L1100:

/*     NOW STORE THE POLISH ELEMENT IN THE POLISH ARRAY. */

    writel_(&c__0);
L1200:
    pole_1.polish[pole_1.poltop - 1] = shl_(val, &c__3) + *typ;
    lcode = cntrl_1.contrl[21] / 3;
    if (pole_1.poltop < lcode) {
	goto L9999;
    }
/*     WRITE THE CURRENT BUFFER */
    writel_(&c__0);
    kp = cntrl_1.contrl[33];
    cntrl_1.contrl[33] = cntrl_1.contrl[21];
    k = cntrl_1.contrl[25];
    cntrl_1.contrl[25] = cntrl_1.contrl[20];

    jp = 0;
    i__1 = lcode;
    for (i__ = 1; i__ <= i__1; ++i__) {
	j = pole_1.polish[i__ - 1];
	for (l = 1; l <= 3; ++l) {
	    i__3 = (3 - l) * 5;
	    i__2 = shr_(&j, &i__3);
	    lp = right_(&i__2, &c__5) + 2;
	    pad_(&jp, &lp, &c__1);
	    jp = 1;
/* L2000: */
	}
    }

    writel_(&c__0);
    cntrl_1.contrl[33] = kp;
    cntrl_1.contrl[25] = k;
    pole_1.poltop = 0;
L9999:
    return 0;
} /* emit_ */

/*      GLOBAL TABLES */
/*     COMPILATION TERMINATED */

/*     THE '48' USED IN BLOCK INITIALIZATION AND IN SYMBOL TABLE */
/*     INITIALIZATION IS DERIVED FROM THE PROGRAM 'SYMCS' WHICH */
/*     BUILDS THE INITIAL SYMBOL TABLE.  IF THIS NUMBER CHANGES, BE */
/*     SURE TO ALTER 'BLOCK', 'BLKSYM', 'SYMTOP', AND 'SYMCNT'. */
/*     TWO ARRAYS, SYM1 AND SYM2, ARE EQUIVALENCED OVER THE */
/*     SYMBOL TABLE ARRAY IN ORDER TO LIMIT THE NUMBER OF */
/*     CONTINUATION CARDS IN SYMBOL TABLE INITIALIZATION */
/*     BELOW.  THE LENGTHS OF SYM1 AND SYM2, THEREFORE, MUST */
/*     TOTAL THE LENGTH OF THE SYMBOL TABLE.  CURRENTLY, THESE */
/*     ARRAYS ARE DECLARED AS FOLLOWS */

/*         SYM1(60) + SYM2(3940) = SYMBOL(4000) */

/*     IF YOU INCREASE (DECREASE) THE SIZE OF SYMBOL, YOU MUST */
/*     INCREASE (DECREASE) THE SIZE OF SYM2 AS WELL. */

/*     NOTE ALSO THAT THE REMAINING ENTRIES OF THE SYMBOL */
/*     TABLE ARE SET TO ZERO AT THE END OF THE DATA STATEMENT */
/*     FOR SYM2.  CURRENTLY, THIS IS ACCOMPLISHED WITH THE LAST */
/*     ENTRY IN THE DATA STATEMENT */

/*                   3880*0 */

/*     AGAIN, IF YOU CHANGE THE SIZE OF SYMBOL, YOU MUST */
/*     ALSO CHANGE THIS LAST ENTRY.  IF FOR EXAMPLE, YOU ALTER */
/*     THE SIZE OF SYMBOL TO 3000, THE LAST ENTRY 1880*0 BECOMES */

/*                   2880*0 */

/*     SYNTAX ANALYZER TABLES */
/*     ... PLM1 VERS ... */
/*     TRANSLATION TABLE FROM INTERNAL TO ASCII */
/*     COMPILATION TERMINATED */
/*     PASS-NO PROGRAM */
/*     ERROR */
/*     ()NEARAT */
/*     PARSE STACK */
/*     SYMBOL  ADDR WDS CHRS   LENGTH PR TY */

/*     OPRADRVALDEFLITLIN */

