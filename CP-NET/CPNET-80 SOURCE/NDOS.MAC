;  NETWORK DISK OPERATING SYSTEM FOR CP/NET
;
;  1982.8.4. FOR BASE
;
TITLE	NETWORK DISK OPERATING SYSTEM FOR CP/NET SLAVE
;
;
;  EQUATIONS OF DATA
;
LF	EQU	0AH		;LINE FEED
CR	EQU	0DH		;CARRIAGE RETURN
EOF	EQU	1AH		;CTRL-Z IS END OF FILE
;
FSEND	EQU	0		;SEND FORMAT CODE
FRECV	EQU	1		;RECEIVE FORMAT CODE
;
TOP	EQU	0		;TOP OF MEMORY
CDISK	EQU	4		;CURRENT DISK & USER CODE
BDOS	EQU	5		;BDOS ENTRY
SYSDMA	EQU	80H		;SYSTEM DMA ADDRESS
;
SCTLNG	EQU	128		;ONE SECTOR LENGTH
;
NOFUNC	EQU	8000H		;NO FUNCTION CODE IN CP/NET
;
;  EQUATIONS OF DOS FUNCTION
;
CCNDIN	EQU	3		;CONSOLE INPUT WITH DEVICE CODE
CCNDOT	EQU	4		;CONSOLE OUTPUT WITH DEVICE CODE
CBUFPR	EQU	9		;BUFFER PRINT
CCONST	EQU	11		;GET CONSOLE STATUS
CGETVR	EQU	12		;GET VERSION NUMBER
CRSDSK	EQU	13		;RESET DISK
COPEN	EQU	15		;OPEN FILE
CSRFST	EQU	17		;SEARCH FIRST
CSRNXT	EQU	18		;SEARCH NEXT DIRECTORY
CREAD	EQU	20		;READ FILE
CSTDMA	EQU	26		;SET DMA ADDRESS
CSTUSC	EQU	32		;SET USER CODE
CRSDSN	EQU	37		;RESET DISK BY DISK VERCTOR
CBMAX	EQU	47		;MAX OF BDOS FUNCTION
;
CLOGIN	EQU	64		;LOGIN
CLOGOF	EQU	65		;LOGOFF
CNMAX	EQU	74		;MAX OF NDOS FUNCTION
;
;  SLAVE CONFIGRATION TABLE
;
; -1	NETWORK STATUS
;  0	SLAVE PROCESSOR ID
;  1-32	A - P DISK DEVICE CODE
; 33-34	CONSOLE DEVICE
; 35-36	LIST DEVICE
; 37	LIST BUFFER COUNTER
; 38-42	MESSAGE HEADER FOR LIST OUT
; 43	LISTER DEVICE NUMBER
; 44-171 LIST OUT DATA BUFFER
;
;  EACH DEVICE DATA USED 2 BYTES
;  IN 1-36
;  1B:BIT 7 H ON NETWORK
;     BIT 6 H SET UP IN DISK
;     BIT 0-3 DEVICE NUMBER IN MASTER
;  2B:MASTER ID
;
;
;  BIAS TO DATA IN CONFIGRATION TABLE
;
BSCONS	EQU	33		;BIAS TO CONSOLE DATA
BSLIST	EQU	35		;BIAS TO LISTER DATA
;
;
;  ENTRY POINTS
;
NDOSTP:				;NDOS TOP FOR CCP LOADING
;
;
CPMIDC:				;CP/M ID CODE AREA  6 BYTES
;
	JMP	NDOSE		;DOS ENTRY
	JMP	COLDST		;COLD START ENTRY
;
NDOS:				;NDOS ENTRY
	JMP	NDOSE		;DOS ENTRY MAIN
	JMP	COLDST		;COLD START POINTER
;
;  COMMENT
;
;
	DB	'COPYRIGHT (C) 1980, DIGITAL RESEARCH '
;
;  USER ID CODE FOR CP/NET
;
	DB	0,0,0,0,0,0
;
;  PARAMETER AREA
;
CONTAD:	DW	0		;CONFIGRATION TABLE ADDRESS
BDOSE:	DW	0		;BDOS ENTRY ADDRESS
CURDSK:	DB	1		;CURRENT DISK
DMAADD:	DW	SYSDMA		;DMA ADDRESS
USRCOD:	DB	0		;USER CODE
VERSION:DW	0		;VERSION NUMBER
FLSRCH:	DB	0		;SEARCH DIRECTORY MODE  -1 ON NETWORK
PNSRCH:	DW	0		;FCB POINTER FOR SEARCH NEXT
;
;  MESSAGE DATA
;
MSGTOP:				;MESSAGE AREA TOP
	DB	0		;MESSAGE FORMAT CODE
MSGID:	DB	0		;DESTINATION DEVICE ID CODE
	DB	0		;SOURCE DEVICE ID CODE
MSGFUN:	DB	0		;FUNCTION CODE
MSGSIZ:	DB	0		;MESSAGE SIZE-1
MSGDAT:				;DATA
	DS	256		;MESSAGE DATA AREA
;
;  STACK AREA
;
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
	DB	0C7H,0C7H,0C7H,0C7H,0C7H,0C7H
STACK:
;
;  DOS WORKING
;
USTACK:	DW	0		;USER STACK SAVE BUFFER
FUNCOD:	DB	0		;FUNCTION CODE
PARAMT:	DW	0		;INPUT PARAMETER
MCRPNT:	DW	0		;MESSAGE CURRENT POINTER
LSTUNT:	DB	0		;LISTER UNIT IN MASTER
;
;  BIOS ROUTINE TABLE	0 NO ROUTINE IN NDOS
;
TLBIOS:
	DW	0		;COLD BOOT
	DW	NWBOOT		;WARM BOOT
BCONST:	DW	NCONST		;CONSOLE STATUS
BCONIN:	DW	NCONIN		;CONSOLE INPUT
BCONOT:	DW	NCONOT		;CONSOLE OUTPUT
BLIST:	DW	NLIST		;LIST OUTPUT
	DW	0,0,0,0,0,0,0,0,0
BLSTST:	DW	NLSTST		;LIST STATUS
	DW	0
;
;  FILE CONTROL BLOCK FOR CCP.SPR
;
CCPFCB:
	DB	1,'CCP     SPR',0
;
;  COLD START ROUTINE  BROKEN BY CCP.SPR LOADING
;
COLDST:
	CALL	NTWKIN
	ORA	A
	JNZ	COLDSE		;INITIALIZE ERROR
	MVI	C,17		;BIOS JUMP TABLE COUNT
	LHLD	TOP+1		;GET BIOS WARM BOOT ROUTINE POINT
	DCX	H
	LXI	D,TLBIOS	;BIOS TRAP ROUTINE TABLE
COLDLP:				;BIOS ROUTINE POINTER CHANGE LOOP
	PUSH	B
	LDAX	D
	MOV	C,A
	INX	D
	LDAX	D		;GET TRAP DATA
	MOV	B,A
	INX	D
	ORA	C
	JZ	COLDLS		;NO TRAP ROUTINE IN NDOS
	MOV	A,M
	DCX	D
	STAX	D
	DCX	H
	MOV	A,M
	DCX	D
	STAX	D		;GET & SAVE CURRENT BIOS ROUTINE POINTER
	INX	D
	INX	D
	MOV	M,C
	INX	H
	MOV	M,B		;CHANGE TO TRAP ROUTINE
COLDLS:
	INX	H
	INX	H
	INX	H
	POP	B
	DCR	C
	JNZ	COLDLP		;TO NEXT POINT
	CALL	CNFTBL
	INX	H
	SHLD	CONTAD
	LHLD	BDOS+1		;GET BDOS ENTRY POINT
	SHLD	BDOSE
	LXI	D,CPMIDC+6	;CP/M ID CODE SET UP POINT
	MVI	B,6		;CODE LENGTH IS 6 BYTES
	DCX	D
	DCX	H
	MOV	A,M
	STAX	D		;SET SAME CODE TO NDOS TOP
	DCR	B
	JNZ	$-5
	MVI	C,CGETVR
	CALL	BDOS		;GET VERSION NUMBER
	SHLD	VERSION
	MVI	C,CBUFPR
	LXI	D,CSTUP
	CALL	BDOS		;START UP COMMENT
	JMP	NWBOOT
;
COLDSE:				;INITIALIZE ERROR
	MVI	C,CBUFPR
	LXI	D,CSTFIL
	CALL	BDOS		;START UP FAILURE
	JMP	TOP		;RETURN TO CP/M SYSTEM
;
;  COMMENTS FOR COLD START
;
CSTFIL:	DB	'Failed to initialize network.',CR,LF
	DB	'Cold Starting.$'
CSTUP:	DB	'NDOS initialization complete.',CR,LF,'$'
;
;  NDOS FUNCTION DECODING BODDY
;
NDOSE:
	LXI	H,0
	MOV	A,C
	CPI	CNMAX+1
	JC	$+6		;OK IN RANGE
	DCX	H		;OVER SO ERROR RETURN
	MOV	A,H
	RET
;
	DAD	SP
	SHLD	USTACK		;SAVE USER STACK
	LXI	SP,STACK	;SET NDOS STACK
	LXI	H,NDEND
	PUSH	H		;SET END ROUTINE POINTER
	MVI	A,CSRNXT
	SUB	C
	JNZ	NDOSES		;NOT SEARCH NEXT DIRECTORY
	LHLD	PNSRCH		;SEARCH NEXT DIRECTORY, SO SET UP FCB POINT
	SHLD	PARAMT
	LDA	FLSRCH
	ORA	A
	JNZ	NDOSEN		;ON NETWORK
	LHLD	BDOSE		;LOCAL DISK
	PCHL
;
NDOSES:
	DCR	A
	JNZ	$+6		;NOT SEARCH FIRST
	STA	FLSRCH		;SEARCH FIRST, SO FLAG CLEAR
	XCHG
	SHLD	PARAMT		;SAVE PARAMETER
NDOSEN:
	MOV	A,C
	STA	FUNCOD		;SAVE FUNCTION CODE
	STA	MSGFUN
	LXI	H,MSGSIZ
	MVI	M,0		;CLEAR SIZE
	INX	H
	SHLD	MCRPNT		;INITIALIZE MESSAGE POINTER
	MVI	B,0
	LXI	H,FNINDX
	MOV	A,C
	CPI	CBMAX+1
	JC	NDOSEB		;BDOS FUNCTION
	SUI	CLOGIN		;SUBTRUCT NDOS TOP VALUE
	JNC	$+8		;NDOS FUNCTIONS
	LXI	H,0FFFFH	;ILLEGAL FUNCTIONS
	MOV	A,H
	RET
;
	ADI	CBMAX+1		;ADD FUNCTION BIAS
	MOV	C,A
NDOSEB:
	DAD	B
	DAD	B
	DAD	B
	DAD	B		;GET INDEX POINT
	MOV	A,M
	MOV	E,A
	INX	H
	MOV	D,M		;GET ROUTINE POINTER
	ORA	D
	JZ	$+5		;NOT ROUTINE TYPE
	XCHG			;ROUTINE TYPE
	PCHL			;TO EACH ROUTINE
;
	INX	H		;NOT ROUTINE TYPE
	INX	H
	MOV	A,M
	ANI	80H
	JNZ	TBDOSP		;NOT NDOS MODE, TO BODS
	XCHG			;BY BIT MAP PROCESS
	CALL	CHKDSK		;CHECK DISK & OVERRIDING GOTO BDOS, IF LOCAL
	XCHG
	DCX	H
	DCX	H
	MVI	B,2		;BYTE COUNT
	LXI	D,INBMAP	;BIT MAP INDEX TOP
NDOSBM:				;BYTE LOOP FOR SET UP
	INX	H
	MVI	C,8		;BIT COUNT
	MOV	A,M
NDOSBT:				;BIT LOOP
	RAR
	JNC	NDOSBS		;OFF BIT
	PUSH	H		;ON BIT
	PUSH	PSW
	LDAX	D
	MOV	L,A
	INX	D
	LDAX	D
	MOV	H,A		;GET ROUTINE POINT
	DCX	D
	POP	PSW
	XTHL			;PUSH ROUTINE ADDRESS
NDOSBS:
	INX	D
	INX	D		;TO NEXT INDEX POINT
	DCR	C
	JNZ	NDOSBT		;TO NEXT BIT
	DCR	B
	RZ			;OK ALL SET UP, TO FIRST PROCESS
	PUSH	H
	LXI	H,RCVPAR	;SET RECEIVE ROUTINE
	XTHL
	PUSH	H
	LXI	H,SNDHDR	;SET SEND ROUTINE
	XTHL
	JMP	NDOSBM		;TO PREPROCESS SET UP
;
;  SEND MESSAGE WITH HEADER SET UP
;
SNDHDR:
	LHLD	CONTAD
	XCHG
	LXI	H,MSGTOP
	MVI	M,FSEND		;FORMAT CODE TO SEND MODE
	LDAX	D		;GET SLAVE ID
	INX	H
	INX	H
	MOV	M,A		;SET SLAVE ID
	INX	H
	MOV	A,M
	CPI	CSRFST
	JNZ	SNDHDS		;NOT SEARCH FIRST
	MVI	A,-1
	STA	FLSRCH		;SET SEARCH FCB ON NETWORK MODE
	XCHG
	LHLD	PARAMT
	SHLD	PNSRCH		;SAVE FCB POINT
	XCHG
SNDHDS:
	INX	H
	INX	H
	XCHG
	LHLD	MCRPNT		;GET CURRENT POINT OF MESSAGE (= END POINT)
	XRA	A
	SUB	E
	MOV	C,A
	MVI	A,0
	SBB	D
	MOV	B,A
	DAD	B		;GET LENGTH OF MESSAGE
	MOV	A,L
	ORA	H
	JNZ	$+4		;SOME DATA
	INX	H		;ZERO BECOMES ONE DATA
	DCX	H
	XCHG
	DCX	H
	MOV	M,E		;SET SIZE
	LXI	B,MSGTOP
	JMP	SDMSGE		;SEND MESSAGE
;
;  RECEIVE MESSAGE WITH INITIALIZATION OF MESSAGE POINTER
;
RCVPAR:
	LXI	B,MSGTOP
	CALL	RVMSGE		;RECEIVE
	LXI	H,MSGDAT
	SHLD	MCRPNT		;INITIALIZE POINTER
	RET
;
;  BIT MAP FUNCTION ROUTINES
;
SUBTTL	BIT MAP FUNCTION ROUTINES
;
;  INDEX FOR BIT MAP FUNCTIONS OF DOS FUNCTION
;
INBMAP:
				;POST PROCESS ROUTINES
	DW	GTRPA		;0 GET RETURN PARAMETER
	DW	RSRRCN		;1 RESTORE RANDOM RECODE NUMBER
	DW	GTDRDT		;2 GET DIRECTORY DATA
	DW	GTOSCT		;3 GET ONE SECTOR DATA
	DW	RSEXCR		;4 RESTORE EXTENT & CURRENT RECORD
	DW	BMNOP		;5 NO OPERATION (NOT USED)
	DW	BMNOP		;6 NO OPERATION (NOT USED)
	DW	BMNOP		;7 NO OPERATION (NOT USED)
				;PRE PROCESS ROUTINES
	DW	BMNOP		;0 NO OPERATION (NOT USED)
	DW	STRRCN		;1 SET RANDOM RECODE NUMBER
	DW	STFLNM		;2 SET FILE NAME FOR RENAME
	DW	WTDTCP		;3 SET ONE SETOR DATA
	DW	STEXCR		;4 SET EXTENT & CURRENT RECODE
	DW	SETFCB		;5 SET FCB
	DW	STFCBP		;6 SET FCB POINT
	DW	TBDOSP		;7 TO BDOS (NOT USED)
;
;  NO OPERATION   POST 5,6,7  PRE 0	(NOT USED)
;
BMNOP:
	RET
;
;  POST OPERATIONS
;
;  POST 1
;  35:COMPUTE FILE SIZE
;  36:SET CURRENT RECODE NUMBER
;
;  RESTORE RANDOM RECORD NUMBER
;
RSRRCN:
	LHLD	PARAMT		;GET FCB TOP
	LXI	D,33		;BIAS TO RANDOM RECODE NUMBER
	DAD	D
	MVI	B,3
	JMP	MCPYFS		;COPY RANDOM RECODE NUMBER
;
;  POST 2
;  17:SEARCH FIRST
;  18:SEARCH NEXT
;
;  GET DIRECTORY DATA
;  OUTPUT
;   A:DIRECTORY CODE
;
GTDRDT:
	LHLD	MCRPNT
	XCHG
	LDAX	D
	INX	D
	CPI	-1
	RZ			;ERROR (NOT FOUND)
	LHLD	DMAADD
	LXI	B,32
	PUSH	PSW		;SAVE DIRECTORY CODE
	ANI	03H		;GET DIRECTORY BIAS CODE
	INR	A
	DCR	A
	JZ	GTDRDL		;GET BIAS
	DAD	B
	JMP	$-5		;MAKE DATA TOP POINT
;
GTDRDL:				;COPY LOOP OF DIRECTORY DATA
	LDAX	D
	MOV	M,A
	INX	D
	INX	H
	DCR	C
	JNZ	GTDRDL
	POP	PSW		;RESTORE DIRECTORY CODE
	RET
;
;  POST 3
;  20:READ SEQUENTIAL
;  33:READ RANDOM
;
;  GET ONE SECTOR DATA
;
GTOSCT:
	LHLD	DMAADD
	MVI	B,SCTLNG
	JMP	MCPYFS		;COPY ONE SECTOR DATA TO DMA ADDRESS
;
;  POST 4
;  20:READ SEQUENTIAL
;  21:WRITE SEQUENTIAL
;  33:READ RANDOM
;  34:WRITE RANDOM
;  35:COMPUTE FILE SIZE
;  40:WRITE RANDOM WITH ZERO FILL
;
;  RESTORE EXTENT & CURRENT RECORD
;
RSEXCR:
	LHLD	MCRPNT
	XCHG
	LHLD	PARAMT		;FCB TOP
	LXI	B,12
	DAD	B
	LDAX	D
	MOV	M,A		;SET EXTENT
	INX	D
	LXI	B,20
	DAD	B
	LDAX	D
	MOV	M,A		;SET CURRENT RECODE
	INX	D
	XCHG
	SHLD	MCRPNT
	RET
;
;  POST 0
;  15:OPEN FILE
;  16:CLOSE FILE
;  19:DELETE FILE
;  20:READ SEQUENTIAL
;  21:WRITE SEQUENTIAL
;  22:MAKE FILE
;  23:RENAME
;  30:SET ATTRIBUTE
;  33:READ RANDOM
;  34:WRITE RANDOM
;  35:COMPUTE FILE SIZE
;  36:GET CURRENT RECODE NUMBER
;  40:WRITE RANDOM WITH ZERO FILL
;
;  GET RETURN PARAMETER
;  OUTPUT
;  HL:TWO BYTE PARAMETER
;   A:ONE BYTE PARAMETER  SAME WITH L
;
GTRPA:
	LHLD	MCRPNT
	MOV	E,M
	INX	H
	MOV	D,M		;GET PARAMETER
	INX	H
	SHLD	MCRPNT		;SAVE NEXT POINT
	XCHG
	MOV	A,L		;SET FOR ONE BYTE PARAMETER
	RET
;
;  PRE OPERATIONS
;
;  PRE 1
;  33:READ RANDOM
;  34:WRITE RANDOM
;  40:WRITE RANDOM WITH ZERO FILL
;
;  SET RANDOM RECORD NUMBER
;
STRRCN:
	LHLD	PARAMT		;FCB TOP
	LXI	D,33
	DAD	D		;RANDOM RECODE NUMBER POINT
	MVI	B,3
	JMP	MCPYTS
;
;  PRE 2
;  23:RENAME
;
;  SET FILE NAME FOR RENAME
;
STFLNM:
	LHLD	MCRPNT
	PUSH	H
	MVI	B,32
	CALL	MCPYTO		;SET TWO FILE NAMES
	CALL	CHKDSK		;GET DISK PARAMETER POINT
	DCX	H
	MOV	A,M
	ANI	0FH		;GET DISK NUMBER
	INR	A
	POP	H
	MOV	M,A		;SET DISK CODE
	LXI	D,16
	DAD	D
	MOV	M,A		;SET DISK CODE FOR SECOND NAME
	RET
;
;  PRE 3
;  21:WRITE SEQUENTIAL
;  34:WRITE RANDOM
;  40 WRITE RANDOM WITH ZERO FILL
;
;  SET ONE SECTOR DATA COPY TO MESSAGE BUFFER
;
WTDTCP:
	LHLD	DMAADD
	MVI	B,SCTLNG
	JMP	MCPYTS
;
	RET
;
;  PRE 4
;  20:READ SEQUENTIAL
;  21:WRITE SEQUENTIAL
;  36:GET CURRENT RECODE COUNT
;
;  SET EXTENT & CURRENT RECODE
;
STEXCR:
	LHLD	MCRPNT
	XCHG
	LHLD	PARAMT
	LXI	B,12
	DAD	B
	MOV	A,M		;SET EXTENT
	STAX	D
	INX	D
	LXI	B,20
	DAD	B
	MOV	A,M		;SET CURRENT RECORD
	STAX	D
	INX	D
	XCHG
	SHLD	MCRPNT
	RET
;
;  PRE 5
;  15:OPEN FILE
;  17:SEARCH FIRST
;  19:DELETE
;  22:MAKE FILE
;  30:SET ATTRIBUTE
;
;  SET FCB
;
SETFCB:
	LHLD	MCRPNT
	PUSH	H
	MVI	B,13
	CALL	MCPYTO		;COPY FCB
	CALL	CHKDSK
	DCX	H
	MOV	A,M
	ANI	0FH
	INR	A
	POP	H
	MOV	M,A		;SET DISK CODE
	RET
;
;  PRE 6
;  15:OPEN FILE
;  16:CLOSE FILE
;  20:READ SEQUENTIAL
;  21:WRITE SEQUENTIAL
;  22:MAKE FILE
;  33:READ RANDOM
;  34:WRITE RANDOM
;  35:COMPUTE FILE SIZE
;  36:GET CURRENT RECODE NUMBER
;  40:WRITE RANDOM WITH ZERO FILL
;
;  SET FCB POINT
;
STFCBP:
	LXI	H,PARAMT
	MVI	B,2
	JMP	MCPYTS
;
;  GENERAL SUBROUTINES
;
SUBTTL	GENERAL SUBROUTINES
;
;  MESSAGE COPY FROM MESSAGE BUFFER
;  INPUT
;   B:COUNT
;
MCPYFR:				;NOT USED HERE
	LHLD	PARAMT		;GET DATA POINT
MCPYFS:
	XCHG
	LHLD	MCRPNT		;GET MESSAGE BUFFER POINT
	MOV	A,M		;COPY DATA
	STAX	D
	INX	D
	INX	H
	DCR	B
	JNZ	$-5		;TO NEXT BYTE
	SHLD	MCRPNT		;SAVE NEXT POINT
	RET
;
;  MESSAGE COPY TO MESSAGE BUFFER
;  INPUT
;   B:COUNT
;
MCPYTO:
	LHLD	PARAMT		;GET PARAMETER POINT
MCPYTS:
	XCHG
	LHLD	MCRPNT		;GET MESSAGE POINT
	LDAX	D		;COPY DATA
	MOV	M,A
	INX	D
	INX	H
	DCR	B
	JNZ	$-5
	SHLD	MCRPNT		;SAVE NEXT POINT
	RET
;
;  GET DISK PARAMETER POINT
;  INPUT
;   A:DISK NUMBER
;  OUTPUT
;  HL:PARAMETER POINT
;
GETDPT:
	LHLD	CONTAD
	DCX	H		;ADJUST A:DATA -2 POINT
	ADD	A		;GET BIAS
	ADD	L
	MOV	L,A
	MOV	A,H
	ACI	0
	MOV	H,A
	RET
;
;  CHECK & SET UP DISK & OVERRIDING GOTO BDOS, IF LOCAL
;  OUTPUT
;  DE:DE
;  HL:DISK PARAMETER POINT+1
;
CHKDSK:
	LHLD	PARAMT		;GET FCB POINT
	MOV	A,M		;GET ENTRY TYPE
	ORA	A
	JNZ	CHKDSS		;HAS ENTRY TYPE
	LDA	CURDSK
	INR	A		;MAKE ENTRY TYPE
CHKDSS:
	CALL	GETDPT		;GET DISK PARAMETER POINT
	MOV	A,M
	RAL
	JNC	TBDOSS		;LOCAL, SO OVERRIDING GOTO BDOS
	RAL
CHKDSL:
	INX	H
	MOV	A,M
	STA	MSGID		;SET MASTER ID
	RC			;ALREADY SET UP DISK
	DCX	H
	MVI	A,40H
	ORA	M		;ON SET UP BIT
	MOV	M,A
	PUSH	H
	PUSH	D
	MVI	A,CSTUSC
	STA	MSGFUN		;SET FUNCTION FOR SET UP USER CODE
	LDA	USRCOD
	STA	MSGDAT
	CALL	SNDHDR		;SET UP USER CODE
	CALL	RCVPAR
	LDA	FUNCOD
	LXI	H,MSGFUN
	MOV	M,A		;RESTOTRE FUNCTION CODE
	INX	H
	MVI	M,0		;CLEAR SIZE
	INX	H
	SHLD	MCRPNT		;ESTORE POINTER
	POP	D
	POP	H
	STC			;SET OK FLAG
	JMP	CHKDSL
;
;  TO BDOS WITH PARAMETER
;
TBDOSS:				;OVERRIDING TO BDOS
	POP	H
TBDOSP:
	LHLD	PARAMT		;GET PARAMETER
	XCHG
	LDA	FUNCOD		;GET FUNCTION CODE
	MOV	C,A
;
;  TO BDOS
;
TOBDOS:
	LHLD	BDOSE
	PCHL
;
;  SEND MESSAGE WITH ERROR PROCESS
;  INPUT
;  BC:MESSAGE ADDRESS
;
SDMSGE:
	CALL	SNDMSG		;SEND IN SNIOS
	INR	A
	RNZ			;NOT ERROR
	JMP	NERROR		;ERROR
;
;  RECEIVE MESSAGE WITH ERROR PROCESS
;  INPUT
;  BC:MESSAGE ADDRESS
;
RVMSGE:
	CALL	RCVMSG		;RECEIVE IN SNIOS
	INR	A
	RNZ			;NOT ERROR
;
;  ERROR END OF NDOS FUNCTION
;
NERROR:
	LXI	H,0FFFFH
	MOV	A,H
;
;  END OF DOS FUNCTION
;  INPUT
;  HL:RETURN PARAMETER
;   A:RETURN PARAMETER
;
NDEND:
	XCHG
	LHLD	USTACK		;GET USER STACK
	SPHL			;RESTORE USER STACK
	XCHG
	RET
;
;  BDOS & NDOS FUNCTION INDEX
;
;  2B:ROUTINE POINTER  0 BY BIT MAP
;  2B:BIT MAP	BIT 0-7   PRE PROCESS
;		BIT 8-14  POST PROCESS
;		BIT 15 H  NOT BY NDOS FUNCTION
;
FNINDX:
	DW	NWBOOT,0	; 0 SYSTEM RESET  WARM BOOT
	DW	0,NOFUNC	; 1 CONSOLE INPUT
	DW	0,NOFUNC	; 2 CONSOLE OUTPUT
	DW	0,NOFUNC	; 3 READER INPUT
	DW	0,NOFUNC	; 4 PUNCHER OUTPUT
	DW	0,NOFUNC	; 5 LISTER OUTPUT
	DW	0,NOFUNC	; 6 DIRECT CONSOLE I/O
	DW	0,NOFUNC	; 7 GET I/O BYTE
	DW	0,NOFUNC	; 8 SET I/O BYTE
	DW	0,NOFUNC	; 9 PRINT STRING
	DW	0,NOFUNC	;10 READ CONSOLE BUFFER
	DW	0,NOFUNC	;11 GET CONSOLE STATUS
	DW	GETVER,0	;12 GET VERSION NUMBER
	DW	0,NOFUNC	;13 RESET DISK
	DW	SELDSK,0	;14 SELECT DISK
;
	DW	0,6001H		;15 OPEN FILE
	DW	0,4001H		;16 CLOSE FILE
	DW	0,2004H		;17 SEARCH FIRST
	DW	0,0004H		;18 SEARCH NEXT
	DW	0,2001H		;19 DELETE FILE
	DW	0,5019H		;20 READ SEQUENTIAL
	DW	0,5811H		;21 WRITE SEQUENTIAL
	DW	0,6001H		;22 MAKE FILE
	DW	0,0401H		;23 RENAME
	DW	0,NOFUNC	;24 GET LOGIN VECTOR
	DW	GETCDK,0	;25 GET CURRENT DISK
	DW	SETDMA,0	;26 SET DMA ADDRESS
	DW	0,NOFUNC	;27 GET ALLOCATION VECTOR
	DW	SETROD,0	;28 SET TO R/O DISK
	DW	0,NOFUNC	;29 GET R/O VECTOR
	DW	0,2001H		;30 SET ATTRIBUTE
	DW	0,NOFUNC	;31 GET DISK PARAMETER ADDRESS
	DW	SETUSR,0	;32 SET USER CODE
	DW	0,4219H		;33 READ RANDOM
	DW	0,4A11H		;34 WRITE RANDOM
	DW	0,4013H		;35 COMPUTE FILE SIZE
	DW	0,5003H		;36 GET CURRENT RECODE NUMBER
	DW	DSKACC,0	;37 RESET DISK
	DW	DSKACC,0	;38 ACCESS DISK
	DW	DSKACC,0	;39 FREE DISK
	DW	0,4A11H		;40 WRITE RANDOM WITH ZERO FILL
	DW	FUNERR,0	;41 ----ERROR----
	DW	FUNERR,0	;42 ----ERROR----
	DW	FUNERR,0	;43 ----ERROR----
	DW	FUNERR,0	;44 ----ERROR----
	DW	FUNERR,0	;45 ----ERROR----
	DW	FUNERR,0	;46 ----ERROR----
	DW	FUNERR,0	;47 ----ERROR----
;
	DW	LOGIN,0		;64 LOGIN
	DW	LOGOFF,0	;65 LOGOFF
	DW	SENDMS,0	;66 SEND MESSAGE
	DW	RECVMS,0	;67 RECEIVE MESSAGE
	DW	NTWKST,0	;68 NETWORK STATUS
	DW	CNFTBL,0	;69 GET CONFIGRATION TABLE
	DW	FUNOVR,0	;70 ----OVER----
	DW	FUNOVR,0	;71 ----OVER----
	DW	FUNOVR,0	;72 ----OVER----
	DW	FUNOVR,0	;73 ----OVER----
	DW	FUNOVR,0	;74 ----OVER----
;
;  NDOS FUNCTION ROUTINES
;
SUBTTL	NDOS FUNCTION ROUTINES
;
;  WARM BOOT
;
NWBOOT:
	LXI	SP,STACK
	LXI	H,NDOS
	SHLD	BDOS+1		;SET NDOS ENTRY POINT
	MVI	E,0
	CALL	SETUSS
	XRA	A
	STA	CCPFCB+32	;CLEAR CURRENT RECORD
	LXI	D,CCPFCB
	LXI	H,NDOSTP	;LOADING POINT
	CALL	LOAD		;LOAD CCP.SPR
	ORA	A
	JNZ	NWBOTE		;LOAD ERROR
	LDA	CDISK		;GET CCURRENT DISK CODE
	MOV	C,A
	SPHL			;STACK TO TPA BOTTOM
	PUSH	H		;SET UP START POINT IN STACK
	PUSH	B		;SAVE DISK CODE
	LDA	USRCOD
	MOV	E,A
	CALL	SETUSS		;SET USER CODE
	CALL	NTWKBT		;WARM BOOT OF SNIOS
	POP	B
	RET			;TO CCP
;
NWBOTE:				;CCP.SPR LOAD ERROR
	MVI	C,CBUFPR
	LXI	D,CLDERR
	CALL	BDOS		;LOAD ERROR
	JMP	$		;STOP HERE
;
;  ERROR COMMENT
;
CLDERR:
	DB	'Failed to load the CP/Net CCP$'
;
;  GET VERSION NUMBER
;  OUTPUT
;  HL:VERSION NUMBER
;
GETVER:
	LHLD	VERSION		;GET ORIGINAL VERSION NUMBER
	MVI	A,02H
	ORA	H		;TO CP/NET VERSION
	MOV	H,A
	MOV	A,L
	RET
;
;  SELECT DISK
;
SELDSK:
	LDA	PARAMT
	STA	CURDSK		;SAVE NEW DISK
;
;  SET R/O DISK
;
SETROD:
	LDA	PARAMT
	INR	A
	CALL	CHKDSS		;CHECK DISK & TO BDOS IF LOCAL
	DCX	H
	MOV	A,M		;GET MASTER DISK
	ANI	00FH
	STA	MSGDAT		;SET DISK
	CALL	SNDHDR		;SEND
	CALL	RCVPAR		;RECEIVE
	JMP	GTRPA		;GET RETURN PARAMETER
;
;  GET CURRENT DISK
;  OUTPUT
;   A:CURRENT DISK
;
GETCDK:
	LDA	CURDSK
	RET
;
;  SET DMA ADDRESS
;
SETDMA:
	LHLD	PARAMT
	SHLD	DMAADD
	JMP	TBDOSP		;TO BDOS, ALSO SET UP IN BDOS
;
;  GET OR SET USER CODE
;
SETUSR:
	LDA	PARAMT
	CPI	-1
	MOV	B,A
	LDA	USRCOD
	RZ			;INTEROGATE MODE
	CMP	B
	RZ			;SAME CODE
	MOV	A,B
	ANI	0FH
	STA	USRCOD		;SAVE NEW CODE
	LHLD	CONTAD
	MVI	C,16		;DISK COUNT
	INX	H
	MOV	A,M
	ANI	0BFH		;RESET USER CODE SET UP MODE OF EACH DISK
	MOV	M,A
	INX	H
	DCR	C
	JNZ	$-7
	LHLD	PARAMT
	XCHG
SETUSS:
	LDA	VERSION
	CPI	20H		;CHECK VERSION
	RC			;TOO LOWER VERSION
	MVI	C,CSTUSC
	JMP	TOBDOS		;SET USER CODE
;
;  SET UP DISK ACCESS MODE
;  RESET DISK, ACCESS DISK & FREE DISK
;
DSKACC:
	LHLD	CONTAD
	LXI	D,31
	DAD	D		;GET DISK DATA BOTTOM
	XCHG
	LXI	H,0
	MVI	C,16
DSKACM:				;MAKE NETWORK DISK VECTOR
	DAD	H
	LDAX	D
	DCX	D
	DCX	D
	RAL
	JNC	$+4		;LOACL DISK
	INX	H		;NETWORK DISK  SET VECTOR BIT
	DCR	C
	JNZ	DSKACM		;TO NEXT CHANEL
	XCHG
	LHLD	PARAMT
	MOV	A,E
	ANA	L
	MOV	L,A
	MOV	A,D
	ANA	H
	MOV	H,A		;GET DISK VECTOR ON NETWORK
	ORA	L
	JNZ	DSKANT		;SOME DISK ON NETWORK
DSKACL:				;MAKE PROCESS FOR LOCAL DISK
	MOV	A,E
	CMA
	MOV	E,A
	MOV	A,D
	CMA
	LHLD	PARAMT
	ANA	H
	MOV	H,A
	MOV	A,L
	ANA	E
	MOV	L,A		;OFF BIT OF NETWORK DISK
	SHLD	PARAMT
	LDA	VERSION
	CPI	20H
	JNC	TBDOSP		;TO BDOS
	LDA	FUNCOD		;TOO LOWER VERSION
	CPI	CRSDSN		;CHECK DISK RESET
	MVI	C,CRSDSK	;RESET ALL DISK CODE
	JZ	TOBDOS		;TO RESET ALL DISK
	RET			;NO PROCESS
;
DSKANT:				;RESET WITH NETWORK DISK
	PUSH	H
	CALL	DSKACL		;RESET LOCAL DISK
	MVI	C,16
	LHLD	CONTAD
	LXI	D,31
	DAD	D		;GET BOTTOM OF DISK PARAMETER
	POP	D
	XCHG
DSKANL:				;NETWORK DISK RESET LOOP
	DAD	H
	JNC	DSKANS		;NOT RESET DISK
	PUSH	B
	PUSH	D
	PUSH	H
	XCHG
	MOV	A,M
	ANI	0FH		;GET DISK IN MASTER
	MOV	C,A
	INR	C
	INX	H
	MOV	A,M		;GET MASTER ID
	LXI	H,1
	DCR	C
	JZ	$+7		;GET BIT POINT OF DISK
	DAD	H
	JMP	$-5		;UP BIT POINT
;
	XCHG
	LXI	H,MSGID		;SET MASTER ID
	MOV	M,A
	INX	H
	INX	H
	LDA	FUNCOD
	MOV	M,A		;SET FUNCTION
	LXI	H,MSGDAT
	MOV	M,E
	INX	H
	MOV	M,D		;SET DISK VECTOR
	INX	H
	SHLD	MCRPNT
	CALL	SNDHDR		;SEND
	CALL	RCVPAR		;RECEIVE
	CALL	GTRPA		;GET RETURN PARAMETER
	POP	H
	POP	D
	POP	B
	CPI	-1
	RZ			;ERROR
DSKANS:
	DCX	D
	DCX	D
	DCR	C
	JNZ	DSKANL		;TO NEXT DISK
	XRA	A		;SUCCESS END
	RET
;
;  ERROR OF FUNCTION CODE
;
FUNERR:
	LXI	H,0FFFFH
	MOV	A,H
	RET
;
;  LOGIN
;
LOGIN:
	LHLD	PARAMT
	PUSH	H
	INX	H		;GET PASSWORD POINT
	MVI	B,8		;PASSWORD LENGTH
	CALL	MCPYTS		;SET PASSWORD
	POP	H
	MOV	A,M		;GET MASTER ID
	MVI	B,CLOGIN	;FUNCTION CODE
	JMP	LOGCOM
;
;  LOGOFF
;
LOGOFF:
	MVI	B,CLOGOF	;FUNCTION CODE
	LDA	PARAMT		;MASTER ID
LOGCOM:				;LOGIN LOGOFF COMMON
	LXI	H,MSGID
	MOV	M,A		;SET MASTER ID
	INX	H
	INX	H
	MOV	M,B		;GET FUNCTION
	CALL	SNDHDR
	CALL	RCVPAR
	JMP	GTRPA
;
;  SEND MESSAGE FOR NDOS FUNCTION
;
SENDMS:
	LHLD	PARAMT
	MOV	B,H
	MOV	C,L		;GET MESSAGE BUFFER POINT
	JMP	SNDMSG
;
;  RECEIVE MESSAGE FOR NDOS FUNCTION
;
RECVMS:
	LHLD	PARAMT
	MOV	B,H
	MOV	C,L		;GET MESSAGE BUFFER POINT
	JMP	RCVMSG
;
;  FUNCTION CODE ERROR  TOO LARGE CODE
;
FUNOVR:
	LXI	H,0FFFFH
	MOV	A,H
	RET
;
;  BIOS TRAP ROUTINES
;
SUBTTL	BIOS TRAP ROUTINES
;
;  CONSOLE STATUS
;
NCONST:
	LHLD	BCONST
	LXI	D,CCONST	;CONSOLE STATUS FUNCTION CODE
	JMP	NCONCM
;
;  CONSOLE INPUT
;
NCONIN:
	LHLD	BCONIN
	LXI	D,CCNDIN	;CONSOLE INPUT WITH DEVICE CODE
	JMP	NCONCM
;
;  CONSOLE OUTPUT
;  INPUT
;   C:DATA
;
NCONOT:
	LHLD	BCONOT
	LXI	D,100H+CCNDOT	;COUNT & CODE
;
;  CONSOLE I/O COMMON ROUTINE
;  INPUT
;  HL:BIOS ROUTINE ADDRESS
;   E:FUNCTION CODE OF NETWORK
;   D:SIZE
;
NCONCM:
	PUSH	H
	PUSH	B
	LHLD	CONTAD
	LXI	B,BSCONS
	DAD	B
	POP	B
	MOV	A,M		;GET CONSOLE MODE
	RAL
	RNC			;LOCAL  SO TO BIOS ROUTINE
	MOV	A,M
	ANI	00FH		;GET CONSOLE NUMBER
	MOV	B,A		;SAVE CONSOLE NUMBER
	INX	H
	MOV	A,M		;GET MASTER ID
	LXI	H,MSGTOP
	MVI	M,FSEND		;FORMAT CODE TO SEND
	INX	H
	MOV	M,A		;DESTINATION ID
	XTHL
	LHLD	CONTAD
	MOV	A,M		;GET SLAVE ID
	POP	H
	INX	H
	MOV	M,A
	INX	H
	MOV	M,E		;SET FUNCTION
	INX	H
	MOV	M,D		;SET SIZE
	INX	H
	MOV	M,B		;SET MASTER CONSOLE NUMBER
	INX	H
	MOV	M,C		;SET DATA
	LXI	B,MSGTOP
	CALL	SDMSGE		;SEND
	LXI	B,MSGTOP
	CALL	RVMSGE		;RECEIVE
	LDA	MSGDAT		;GET RETUNR PARAMETER
	RET
;
;  LIST OUT
;
NLIST:
	LHLD	CONTAD
	LXI	D,BSLIST
	DAD	D
	MOV	A,M		;GET LISTER MODE
	RAL
	JC	$+7		;NETWORK
	LHLD	BLIST		;LOCAL
	PCHL
;
	MOV	A,M		;ON NETWORK
	ANI	00FH
	STA	LSTUNT		;SAVE UNIT CODE
	PUSH	B
	MOV	B,C
	INX	H
	INX	H
	MOV	C,M		;GET COUNT
	INR	M		;COUNT UP
	MVI	A,SCTLNG	;ONE SECTOR LENGTH
	CMP	M
	JZ	$+9		;SECTOR BOUNDARY
	MOV	A,B
	CPI	EOF
	JNZ	$+5		;NOT END OF FILE
	MVI	M,0		;CLEAR COUNT FOR SEND
	LXI	D,7
	DAD	D
	MVI	B,0
	DAD	B
	POP	D
	MOV	M,E		;SET DATA
	RNZ			;NOT TRANSFER MODE
	LHLD	CONTAD		;TRANSFER ONE BLOCK
	LXI	D,BSLIST+1
	DAD	D
	MOV	A,M		;GET MASTER ID
	INX	H
	INX	H
	MOV	E,C
	MOV	B,H
	MOV	C,L
	INX	H
	MOV	M,A		;SET MASTER ID
	INX	H
	INX	H
	INX	H
	INR	E
	MOV	M,E		;SET SIZE
	INX	H
	LDA	LSTUNT
	MOV	M,A		;SET UNIT CODE
	CALL	SDMSGE		;SEND
	LXI	B,MSGTOP
	JMP	RVMSGE		;RECEIVE
;
;  LIST STATUS
;
NLSTST:
	LHLD	CONTAD
	LXI	D,BSLIST
	DAD	D
	MOV	A,M
	RAL
	JC	$+7		;ON NETWORK
	LHLD	BLSTST		;LOCAL
	PCHL
;
	RET
;
;  LOADING ROUTINES
;
SUBTTL	PROGRAM LOADING ROUTINES
;
;  LOAD ONE FILE
;  INPUT
;  HL:BOTTOM OF FREE AREA
;  DE:FCB
;  OUTPUT
;   A:-1 ERROR
;  HL:TOP OF PROGRAM
;
LOAD:
	SHLD	LDBOTM		;SAVE BOTTOM
	XCHG
	SHLD	LDFCB		;SAVE FCB POINT
	MVI	C,CSTDMA
	LXI	H,-SCTLNG	;SUBTRUCT ONE SECTOR LENGTH
	DAD	D
	SHLD	LDDMA		;SAVE DMA POINT FOR PARAMETER READ
	XCHG
	CALL	TOBDOS		;SET DMA ADDRESS TO SCRATCH AREA
	LHLD	LDFCB
	XCHG
	MVI	C,COPEN
	CALL	TOBDOS		;OPEN FILE
	CPI	-1
	RZ			;OPEN ERROR (NOT FOUND)
	CALL	OSREAD		;GET PARAMETER SECTOR
	LHLD	LDDMA
	INX	H
	MOV	E,M
	INX	H
	MOV	D,M		;GET CODE AREA LENGTH
	INX	H
	INX	H
	MOV	C,M
	INX	H
	MOV	B,M		;GET DATA AREA LENGTH
	XCHG
	SHLD	LDLNGT		;SAVE CODE AREA LENGTH
	DAD	B		;GET TOTAL LENGTH
	XCHG
	LHLD	LDBOTM		;GET BOTTOM
	XCHG
	XRA	A
	SUB	L
	MOV	L,A
	MVI	A,0
	SBB	H
	MOV	H,A
	DAD	D		;SUBTRUCT LENGTH FROM BOTTOM POINT
	MVI	L,000H		;GET LOADING TOP
	SHLD	LDTOP		;SAVE LOADING TOP (PROGRAM TOP)
	XCHG
	LXI	H,-SCTLNG
	DAD	D		;SUBTRUCT ONE SECTOR LENGTH
	SHLD	LDDMA		;SET RELOCATION DATA BUFFER TOP
	CALL	OSREAD		;GET DATA & IGNORE
	LHLD	LDLNGT
	LXI	D,SCTLNG-1
	DAD	D		;ADJUST BOUNDARY
	MOV	A,L
	RAL
	MOV	A,H
	RAL			;GET SECTOR COUNT OF CODE AREA
	LHLD	LDTOP		;GET LOADING TOP
LOADLP:				;ONE SECTOR LOADING LOOP
	STA	LDCNT		;SAVE COUNT
	SHLD	LDPNT		;SAVE LOADING POINT
	XCHG
	MVI	C,CSTDMA
	CALL	TOBDOS		;SET DMA ADDRESS
	CALL	OSREAD		;READ ONE SECTOR DATA
	LHLD	LDPNT
	LXI	D,SCTLNG	;ONE SECTOR LENGTH
	DAD	D		;GET NEXT DMA ADDRESS
	LDA	LDCNT
	DCR	A		;SECTOR COUNT DOWN
	JNZ	LOADLP		;TO NEXT SECTOR
	LHLD	LDDMA		;GET BUFFER POINT FOR RELOCATION DATA
	XCHG
	MVI	C,CSTDMA
	CALL	TOBDOS		;SET TO RELOCATION BUFFER POINT
	LHLD	LDLNGT		;GET LENGTH TO GET RELOCATION DATA TOP
	MOV	B,H
	MOV	C,L
	XCHG
	LHLD	LDTOP		;CODE TOP
	XCHG
	DAD	D		;GET TOP OF RELOCATION DATA
	PUSH	H		;SAVE RELOCATION DATA POINT
	MOV	H,D		;SET RELOCATION BIAS
LOADRL:				;RELOCATION LOOP
	MOV	A,B
	ORA	C
	JNZ	$+8		;NOT TO END
	POP	H		;END OF RELOCATION
	LHLD	LDTOP		;TOP OF PROGRAM
	RET			;END OF LOADING
;
	DCX	B
	MOV	A,E
	ANI	07H
	JNZ	LOADRB		;NOT BYTE BOUNDARY
	XTHL			;BYTE BOUNDARY,  GET DATA POINT
	MOV	A,L
	ANI	07FH
	JNZ	LOADRS		;NOT SECTOR BOUNDARY
	PUSH	B
	PUSH	D
	PUSH	H
	LHLD	LDFCB		;GET FCB POINT
	XCHG
	MVI	C,CREAD
	CALL	TOBDOS		;GET ONE SECTOR DATA
	POP	H
	POP	D
	POP	B
	LHLD	LDDMA		;GET DATA TOP POINT
	ORA	A
	JNZ	OSRDER		;NO DATA, SO ERROR
LOADRS:
	MOV	A,M		;GET NEXT RELOCATION DATA
	INX	H
	XTHL
	MOV	L,A
LOADRB:
	MOV	A,L
	RAL			;GET ONE BIT DATA
	MOV	L,A
	JNC	$+6		;NOT RELOCATE
	LDAX	D		;RELOCATE
	ADD	H
	STAX	D
	INX	D
	JMP	LOADRL		;TO NEXT DATA
;
;  READ ONE SECTOR DATA
;
OSREAD:
	LHLD	LDFCB		;GET FCB
	XCHG
	MVI	C,CREAD
	CALL	TOBDOS		;READ ONE SECTOR
	ORA	A
	RZ			;NOT ERROR
OSRDER:				;NO DATA, SO ERROR
	MVI	A,-1
	POP	H		;OVERRIDING RETURN
	RET
;
;  LOADING ROUTINE WORKING
;
LDDMA:	DS	2		;DMA ADDRESS
LDLNGT:	DS	2		;CODE AREA LENGTH
LDFCB:	DS	2		;FCB POINTER
LDBOTM:	DS	2		;BOTTOM POINT OF FREE AREA
LDTOP:	DS	2		;TOP POINT OF PROGRAM
LDCNT:	DS	1		;LOAD SECTOR COUNT
LDPNT:	DS	2		;LOADING POINTER
;
;
	ORG	9FFH
	DB	0		;NDOS BOTTOM
;
;  SNIOS ROUTINES
;
NTWKIN	EQU	$		;NETWORK INITIALIZE
NTWKST	EQU	$+3		;NETWORK STATUS
CNFTBL	EQU	$+6		;GET CONFIGRATION TABLE ADDRESS
SNDMSG	EQU	$+9		;SEND MESSAGE
RCVMSG	EQU	$+12		;RECEIVE MESSAGE
NTWKER	EQU	$+15		;NETWORK ERROR
NTWKBT	EQU	$+18		;NETWORL WARM BOOT
;
;
	END
